<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.20"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>libevdev: Initialization and setup</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="bootstrap.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="libevdevdoxygen.css" rel="stylesheet" type="text/css"/>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">libevdev 1.11.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Initialization and setup</div>  </div>
</div><!--header-->
<div class="contents">

<p>Initialization, initial setup and file descriptor handling.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa282ec9badaa6bc11b1dc5bb124dbd5b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__init.html#gaa282ec9badaa6bc11b1dc5bb124dbd5b">libevdev_grab_mode</a> { <a class="el" href="group__init.html#ggaa282ec9badaa6bc11b1dc5bb124dbd5bad3ac6f5f3ebf7d38a6aad74a88396c88">LIBEVDEV_GRAB</a>, 
<a class="el" href="group__init.html#ggaa282ec9badaa6bc11b1dc5bb124dbd5ba6c0930d0c280753504cd05ebdcda09eb">LIBEVDEV_UNGRAB</a>
 }</td></tr>
<tr class="separator:gaa282ec9badaa6bc11b1dc5bb124dbd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga332c8ee260b4ef864345abe5d04e820c"><td class="memItemLeft" align="right" valign="top">struct libevdev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__init.html#ga332c8ee260b4ef864345abe5d04e820c">libevdev_new</a> (void)</td></tr>
<tr class="memdesc:ga332c8ee260b4ef864345abe5d04e820c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new libevdev device.  <a href="group__init.html#ga332c8ee260b4ef864345abe5d04e820c">More...</a><br /></td></tr>
<tr class="separator:ga332c8ee260b4ef864345abe5d04e820c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89bb5bce1c23e293293484b05b12aaf4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__init.html#ga89bb5bce1c23e293293484b05b12aaf4">libevdev_new_from_fd</a> (int fd, struct libevdev **dev)</td></tr>
<tr class="memdesc:ga89bb5bce1c23e293293484b05b12aaf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new libevdev device from the given fd.  <a href="group__init.html#ga89bb5bce1c23e293293484b05b12aaf4">More...</a><br /></td></tr>
<tr class="separator:ga89bb5bce1c23e293293484b05b12aaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd9fe760d15be25fc99ce469034bd78c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__init.html#gacd9fe760d15be25fc99ce469034bd78c">libevdev_free</a> (struct libevdev *dev)</td></tr>
<tr class="memdesc:gacd9fe760d15be25fc99ce469034bd78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up and free the libevdev struct.  <a href="group__init.html#gacd9fe760d15be25fc99ce469034bd78c">More...</a><br /></td></tr>
<tr class="separator:gacd9fe760d15be25fc99ce469034bd78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d434af74fee20f273db568e2cbbd13f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__init.html#ga5d434af74fee20f273db568e2cbbd13f">libevdev_grab</a> (struct libevdev *dev, enum <a class="el" href="group__init.html#gaa282ec9badaa6bc11b1dc5bb124dbd5b">libevdev_grab_mode</a> grab)</td></tr>
<tr class="memdesc:ga5d434af74fee20f273db568e2cbbd13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grab or ungrab the device through a kernel EVIOCGRAB.  <a href="group__init.html#ga5d434af74fee20f273db568e2cbbd13f">More...</a><br /></td></tr>
<tr class="separator:ga5d434af74fee20f273db568e2cbbd13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6658ac490d68c307ff8b8d1536c12b44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44">libevdev_set_fd</a> (struct libevdev *dev, int fd)</td></tr>
<tr class="memdesc:ga6658ac490d68c307ff8b8d1536c12b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the fd for this struct and initialize internal data.  <a href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44">More...</a><br /></td></tr>
<tr class="separator:ga6658ac490d68c307ff8b8d1536c12b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac71c9cca4c572ed1b1a8c233be70a17c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__init.html#gac71c9cca4c572ed1b1a8c233be70a17c">libevdev_change_fd</a> (struct libevdev *dev, int fd)</td></tr>
<tr class="memdesc:gac71c9cca4c572ed1b1a8c233be70a17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the fd for this device, without re-reading the actual device.  <a href="group__init.html#gac71c9cca4c572ed1b1a8c233be70a17c">More...</a><br /></td></tr>
<tr class="separator:gac71c9cca4c572ed1b1a8c233be70a17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9bfc800859ac3aa63f41d58ec4b616c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__init.html#gab9bfc800859ac3aa63f41d58ec4b616c">libevdev_get_fd</a> (const struct libevdev *dev)</td></tr>
<tr class="separator:gab9bfc800859ac3aa63f41d58ec4b616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Initialization, initial setup and file descriptor handling. </p>
<p>These functions are the main entry points for users of libevdev, usually a caller will use this series of calls:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>libevdev *dev;</div>
<div class="line"><span class="keywordtype">int</span> err;</div>
<div class="line"> </div>
<div class="line">dev = <a class="code" href="group__init.html#ga332c8ee260b4ef864345abe5d04e820c">libevdev_new</a>();</div>
<div class="line"><span class="keywordflow">if</span> (!dev)</div>
<div class="line">        <span class="keywordflow">return</span> ENOMEM;</div>
<div class="line"> </div>
<div class="line">err = <a class="code" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44">libevdev_set_fd</a>(dev, fd);</div>
<div class="line"><span class="keywordflow">if</span> (err &lt; 0) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed (errno %d): %s\n&quot;</span>, -err, strerror(-err));</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__init.html#gacd9fe760d15be25fc99ce469034bd78c">libevdev_free</a>(dev);</div>
</div><!-- fragment --><p><a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44" title="Set the fd for this struct and initialize internal data.">libevdev_set_fd()</a> is the central call and initializes the internal structs for the device at the given fd. libevdev functions will fail if called before <a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44" title="Set the fd for this struct and initialize internal data.">libevdev_set_fd()</a> unless documented otherwise. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa282ec9badaa6bc11b1dc5bb124dbd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa282ec9badaa6bc11b1dc5bb124dbd5b">&#9670;&nbsp;</a></span>libevdev_grab_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__init.html#gaa282ec9badaa6bc11b1dc5bb124dbd5b">libevdev_grab_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa282ec9badaa6bc11b1dc5bb124dbd5bad3ac6f5f3ebf7d38a6aad74a88396c88"></a>LIBEVDEV_GRAB&#160;</td><td class="fielddoc"><p>Grab the device if not currently grabbed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa282ec9badaa6bc11b1dc5bb124dbd5ba6c0930d0c280753504cd05ebdcda09eb"></a>LIBEVDEV_UNGRAB&#160;</td><td class="fielddoc"><p>Ungrab the device if currently grabbed. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac71c9cca4c572ed1b1a8c233be70a17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac71c9cca4c572ed1b1a8c233be70a17c">&#9670;&nbsp;</a></span>libevdev_change_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_change_fd </td>
          <td>(</td>
          <td class="paramtype">struct libevdev *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the fd for this device, without re-reading the actual device. </p>
<p>If the fd changes after initializing the device, for example after a VT-switch in the X.org X server, this function updates the internal fd to the newly opened. No check is made that new fd points to the same device. If the device has changed, libevdev's behavior is undefined.</p>
<p>libevdev does not sync itself after changing the fd and keeps the current device state. Use libevdev_next_event with the <a class="el" href="group__events.html#gga56c288d9f2e4c1632986c4e218c494e9a5198e5c9cc98b75f73f61b104d6a674c">LIBEVDEV_READ_FLAG_FORCE_SYNC</a> flag to force a re-sync.</p>
<p>The example code below illustrates how to force a re-sync of the library-internal state. Note that this code doesn't handle the events in the caller, it merely forces an update of the internal library state. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>input_event ev;</div>
<div class="line"><a class="code" href="group__init.html#gac71c9cca4c572ed1b1a8c233be70a17c">libevdev_change_fd</a>(dev, new_fd);</div>
<div class="line"><a class="code" href="group__events.html#gabb96c864e836c0b98788f4ab771c3a76">libevdev_next_event</a>(dev, <a class="code" href="group__events.html#gga56c288d9f2e4c1632986c4e218c494e9a5198e5c9cc98b75f73f61b104d6a674c">LIBEVDEV_READ_FLAG_FORCE_SYNC</a>, &amp;ev);</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code" href="group__events.html#gabb96c864e836c0b98788f4ab771c3a76">libevdev_next_event</a>(dev, <a class="code" href="group__events.html#gga56c288d9f2e4c1632986c4e218c494e9a1f13a19641d6dafcf01a86a6389800f8">LIBEVDEV_READ_FLAG_SYNC</a>, &amp;ev) == <a class="code" href="group__events.html#gga4a96221b3c7f54dfb86035d952154e3aa8d70b14a38204fde4ad433023baa545a">LIBEVDEV_READ_STATUS_SYNC</a>)</div>
<div class="line">                        ; <span class="comment">// noop</span></div>
</div><!-- fragment --><p>The fd may be open in O_RDONLY or O_RDWR.</p>
<p>After changing the fd, the device is assumed ungrabbed and a caller must call <a class="el" href="group__init.html#ga5d434af74fee20f273db568e2cbbd13f" title="Grab or ungrab the device through a kernel EVIOCGRAB.">libevdev_grab()</a> again.</p>
<p>It is an error to call this function before calling <a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44" title="Set the fd for this struct and initialize internal data.">libevdev_set_fd()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The evdev device, already initialized with <a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44" title="Set the fd for this struct and initialize internal data.">libevdev_set_fd()</a> </td></tr>
    <tr><td class="paramname">fd</td><td>The new fd</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -1 on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44" title="Set the fd for this struct and initialize internal data.">libevdev_set_fd</a> </dd></dl>

</div>
</div>
<a id="gacd9fe760d15be25fc99ce469034bd78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd9fe760d15be25fc99ce469034bd78c">&#9670;&nbsp;</a></span>libevdev_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libevdev_free </td>
          <td>(</td>
          <td class="paramtype">struct libevdev *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up and free the libevdev struct. </p>
<p>After completion, the <code>struct libevdev</code> is invalid and must not be used.</p>
<p>Note that calling <a class="el" href="group__init.html#gacd9fe760d15be25fc99ce469034bd78c" title="Clean up and free the libevdev struct.">libevdev_free()</a> does not close the file descriptor currently associated with this instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The evdev device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function may be called before <a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44" title="Set the fd for this struct and initialize internal data.">libevdev_set_fd()</a>. </dd></dl>

</div>
</div>
<a id="gab9bfc800859ac3aa63f41d58ec4b616c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9bfc800859ac3aa63f41d58ec4b616c">&#9670;&nbsp;</a></span>libevdev_get_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_get_fd </td>
          <td>(</td>
          <td class="paramtype">const struct libevdev *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The evdev device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previously set fd, or -1 if none had been set previously. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function may be called before <a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44" title="Set the fd for this struct and initialize internal data.">libevdev_set_fd()</a>. </dd></dl>

</div>
</div>
<a id="ga5d434af74fee20f273db568e2cbbd13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d434af74fee20f273db568e2cbbd13f">&#9670;&nbsp;</a></span>libevdev_grab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_grab </td>
          <td>(</td>
          <td class="paramtype">struct libevdev *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__init.html#gaa282ec9badaa6bc11b1dc5bb124dbd5b">libevdev_grab_mode</a>&#160;</td>
          <td class="paramname"><em>grab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grab or ungrab the device through a kernel EVIOCGRAB. </p>
<p>This prevents other clients (including kernel-internal ones such as rfkill) from receiving events from this device.</p>
<p>This is generally a bad idea. Don't do this.</p>
<p>Grabbing an already grabbed device, or ungrabbing an ungrabbed device is a noop and always succeeds.</p>
<p>A grab is an operation tied to a file descriptor, not a device. If a client changes the file descriptor with <a class="el" href="group__init.html#gac71c9cca4c572ed1b1a8c233be70a17c" title="Change the fd for this device, without re-reading the actual device.">libevdev_change_fd()</a>, it must also re-issue a grab with <a class="el" href="group__init.html#ga5d434af74fee20f273db568e2cbbd13f" title="Grab or ungrab the device through a kernel EVIOCGRAB.">libevdev_grab()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The evdev device, already initialized with <a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44" title="Set the fd for this struct and initialize internal data.">libevdev_set_fd()</a> </td></tr>
    <tr><td class="paramname">grab</td><td>If true, grab the device. Otherwise ungrab the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the device was successfully grabbed or ungrabbed, or a negative errno in case of failure. </dd></dl>

</div>
</div>
<a id="ga332c8ee260b4ef864345abe5d04e820c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga332c8ee260b4ef864345abe5d04e820c">&#9670;&nbsp;</a></span>libevdev_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct libevdev* libevdev_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new libevdev device. </p>
<p>This function only allocates the required memory and initializes the struct to sane default values. To actually hook up the device to a kernel device, use <a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44" title="Set the fd for this struct and initialize internal data.">libevdev_set_fd()</a>.</p>
<p>Memory allocated through <a class="el" href="group__init.html#ga332c8ee260b4ef864345abe5d04e820c" title="Initialize a new libevdev device.">libevdev_new()</a> must be released by the caller with <a class="el" href="group__init.html#gacd9fe760d15be25fc99ce469034bd78c" title="Clean up and free the libevdev struct.">libevdev_free()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44" title="Set the fd for this struct and initialize internal data.">libevdev_set_fd</a> </dd>
<dd>
<a class="el" href="group__init.html#gacd9fe760d15be25fc99ce469034bd78c" title="Clean up and free the libevdev struct.">libevdev_free</a> </dd></dl>

</div>
</div>
<a id="ga89bb5bce1c23e293293484b05b12aaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89bb5bce1c23e293293484b05b12aaf4">&#9670;&nbsp;</a></span>libevdev_new_from_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_new_from_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct libevdev **&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new libevdev device from the given fd. </p>
<p>This is a shortcut for</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> err;</div>
<div class="line"><span class="keyword">struct </span>libevdev *dev = <a class="code" href="group__init.html#ga332c8ee260b4ef864345abe5d04e820c">libevdev_new</a>();</div>
<div class="line">err = <a class="code" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44">libevdev_set_fd</a>(dev, fd);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fd</td><td>A file descriptor to the device in O_RDWR or O_RDONLY mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dev</td><td>The newly initialized evdev device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned and dev is set to the newly allocated struct. On failure, a negative errno is returned and the value of dev is undefined.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__init.html#gacd9fe760d15be25fc99ce469034bd78c" title="Clean up and free the libevdev struct.">libevdev_free</a> </dd></dl>

</div>
</div>
<a id="ga6658ac490d68c307ff8b8d1536c12b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6658ac490d68c307ff8b8d1536c12b44">&#9670;&nbsp;</a></span>libevdev_set_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_set_fd </td>
          <td>(</td>
          <td class="paramtype">struct libevdev *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the fd for this struct and initialize internal data. </p>
<p>The fd must be in O_RDONLY or O_RDWR mode.</p>
<p>This function may only be called once per device. If the device changed and you need to re-read a device, use <a class="el" href="group__init.html#gacd9fe760d15be25fc99ce469034bd78c" title="Clean up and free the libevdev struct.">libevdev_free()</a> and <a class="el" href="group__init.html#ga332c8ee260b4ef864345abe5d04e820c" title="Initialize a new libevdev device.">libevdev_new()</a>. If you need to change the fd after closing and re-opening the same device, use <a class="el" href="group__init.html#gac71c9cca4c572ed1b1a8c233be70a17c" title="Change the fd for this device, without re-reading the actual device.">libevdev_change_fd()</a>.</p>
<p>A caller should ensure that any events currently pending on the fd are drained before the file descriptor is passed to libevdev for initialization. Due to how the kernel's ioctl handling works, the initial device state will reflect the current device state <em>after</em> applying all events currently pending on the fd. Thus, if the fd is not drained, the state visible to the caller will be inconsistent with the events immediately available on the device. This does not affect state-less events like EV_REL.</p>
<p>Unless otherwise specified, libevdev function behavior is undefined until a successful call to <a class="el" href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44" title="Set the fd for this struct and initialize internal data.">libevdev_set_fd()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The evdev device </td></tr>
    <tr><td class="paramname">fd</td><td>The file descriptor for the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative errno on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__init.html#gac71c9cca4c572ed1b1a8c233be70a17c" title="Change the fd for this device, without re-reading the actual device.">libevdev_change_fd</a> </dd>
<dd>
<a class="el" href="group__init.html#ga332c8ee260b4ef864345abe5d04e820c" title="Initialize a new libevdev device.">libevdev_new</a> </dd>
<dd>
<a class="el" href="group__init.html#gacd9fe760d15be25fc99ce469034bd78c" title="Clean up and free the libevdev struct.">libevdev_free</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__init_html_ga332c8ee260b4ef864345abe5d04e820c"><div class="ttname"><a href="group__init.html#ga332c8ee260b4ef864345abe5d04e820c">libevdev_new</a></div><div class="ttdeci">struct libevdev * libevdev_new(void)</div><div class="ttdoc">Initialize a new libevdev device.</div></div>
<div class="ttc" id="agroup__init_html_ga6658ac490d68c307ff8b8d1536c12b44"><div class="ttname"><a href="group__init.html#ga6658ac490d68c307ff8b8d1536c12b44">libevdev_set_fd</a></div><div class="ttdeci">int libevdev_set_fd(struct libevdev *dev, int fd)</div><div class="ttdoc">Set the fd for this struct and initialize internal data.</div></div>
<div class="ttc" id="agroup__init_html_gacd9fe760d15be25fc99ce469034bd78c"><div class="ttname"><a href="group__init.html#gacd9fe760d15be25fc99ce469034bd78c">libevdev_free</a></div><div class="ttdeci">void libevdev_free(struct libevdev *dev)</div><div class="ttdoc">Clean up and free the libevdev struct.</div></div>
<div class="ttc" id="agroup__events_html_gga56c288d9f2e4c1632986c4e218c494e9a5198e5c9cc98b75f73f61b104d6a674c"><div class="ttname"><a href="group__events.html#gga56c288d9f2e4c1632986c4e218c494e9a5198e5c9cc98b75f73f61b104d6a674c">LIBEVDEV_READ_FLAG_FORCE_SYNC</a></div><div class="ttdeci">@ LIBEVDEV_READ_FLAG_FORCE_SYNC</div><div class="ttdoc">Pretend the next event is a SYN_DROPPED and require the caller to sync.</div><div class="ttdef"><b>Definition:</b> libevdev.h:763</div></div>
<div class="ttc" id="agroup__events_html_gga4a96221b3c7f54dfb86035d952154e3aa8d70b14a38204fde4ad433023baa545a"><div class="ttname"><a href="group__events.html#gga4a96221b3c7f54dfb86035d952154e3aa8d70b14a38204fde4ad433023baa545a">LIBEVDEV_READ_STATUS_SYNC</a></div><div class="ttdeci">@ LIBEVDEV_READ_STATUS_SYNC</div><div class="ttdoc">Depending on the libevdev_next_event() read flag:</div><div class="ttdef"><b>Definition:</b> libevdev.h:1090</div></div>
<div class="ttc" id="agroup__events_html_gabb96c864e836c0b98788f4ab771c3a76"><div class="ttname"><a href="group__events.html#gabb96c864e836c0b98788f4ab771c3a76">libevdev_next_event</a></div><div class="ttdeci">int libevdev_next_event(struct libevdev *dev, unsigned int flags, struct input_event *ev)</div><div class="ttdoc">Get the next event from the device.</div></div>
<div class="ttc" id="agroup__init_html_gac71c9cca4c572ed1b1a8c233be70a17c"><div class="ttname"><a href="group__init.html#gac71c9cca4c572ed1b1a8c233be70a17c">libevdev_change_fd</a></div><div class="ttdeci">int libevdev_change_fd(struct libevdev *dev, int fd)</div><div class="ttdoc">Change the fd for this device, without re-reading the actual device.</div></div>
<div class="ttc" id="agroup__events_html_gga56c288d9f2e4c1632986c4e218c494e9a1f13a19641d6dafcf01a86a6389800f8"><div class="ttname"><a href="group__events.html#gga56c288d9f2e4c1632986c4e218c494e9a1f13a19641d6dafcf01a86a6389800f8">LIBEVDEV_READ_FLAG_SYNC</a></div><div class="ttdeci">@ LIBEVDEV_READ_FLAG_SYNC</div><div class="ttdoc">Process data in sync mode.</div><div class="ttdef"><b>Definition:</b> libevdev.h:761</div></div>
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.20
</small></address>
</body>
</html>
