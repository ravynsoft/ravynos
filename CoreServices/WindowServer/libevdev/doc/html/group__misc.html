<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.20"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>libevdev: Miscellaneous helper functions</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="bootstrap.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="libevdevdoxygen.css" rel="stylesheet" type="text/css"/>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">libevdev 1.11.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Miscellaneous helper functions</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for printing or querying event ranges.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab8b6b80740e028261300b8952b61a596"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gab8b6b80740e028261300b8952b61a596">libevdev_event_is_type</a> (const struct input_event *ev, unsigned int type)</td></tr>
<tr class="memdesc:gab8b6b80740e028261300b8952b61a596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check if an event is of a specific type.  <a href="group__misc.html#gab8b6b80740e028261300b8952b61a596">More...</a><br /></td></tr>
<tr class="separator:gab8b6b80740e028261300b8952b61a596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37766a6a498fef3294d589abcce688bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga37766a6a498fef3294d589abcce688bb">libevdev_event_is_code</a> (const struct input_event *ev, unsigned int type, unsigned int code)</td></tr>
<tr class="memdesc:ga37766a6a498fef3294d589abcce688bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check if an event is of a specific type and code.  <a href="group__misc.html#ga37766a6a498fef3294d589abcce688bb">More...</a><br /></td></tr>
<tr class="separator:ga37766a6a498fef3294d589abcce688bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac99720fd926bf288764f9a81bf37ed09"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gac99720fd926bf288764f9a81bf37ed09">libevdev_event_type_get_name</a> (unsigned int type)</td></tr>
<tr class="separator:gac99720fd926bf288764f9a81bf37ed09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab407b3c2caaae502859c28460cad17bb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gab407b3c2caaae502859c28460cad17bb">libevdev_event_code_get_name</a> (unsigned int type, unsigned int code)</td></tr>
<tr class="separator:gab407b3c2caaae502859c28460cad17bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd45c5e963cba245e944ea66e72fcc3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gabcd45c5e963cba245e944ea66e72fcc3">libevdev_event_value_get_name</a> (unsigned int type, unsigned int code, int value)</td></tr>
<tr class="memdesc:gabcd45c5e963cba245e944ea66e72fcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resolves the event value for a code.  <a href="group__misc.html#gabcd45c5e963cba245e944ea66e72fcc3">More...</a><br /></td></tr>
<tr class="separator:gabcd45c5e963cba245e944ea66e72fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc12bdb7b912070ac9c375428f2c9892"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gacc12bdb7b912070ac9c375428f2c9892">libevdev_property_get_name</a> (unsigned int prop)</td></tr>
<tr class="separator:gacc12bdb7b912070ac9c375428f2c9892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfad87ea78d034631cf3e5322ac383a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gabfad87ea78d034631cf3e5322ac383a1">libevdev_event_type_get_max</a> (unsigned int type)</td></tr>
<tr class="separator:gabfad87ea78d034631cf3e5322ac383a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ce3bf1e66bd172e583b86a11fc41f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga61ce3bf1e66bd172e583b86a11fc41f1">libevdev_event_type_from_name</a> (const char *name)</td></tr>
<tr class="memdesc:ga61ce3bf1e66bd172e583b86a11fc41f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an event-type by its name.  <a href="group__misc.html#ga61ce3bf1e66bd172e583b86a11fc41f1">More...</a><br /></td></tr>
<tr class="separator:ga61ce3bf1e66bd172e583b86a11fc41f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee03d650200bb04a23233570667fa84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga4ee03d650200bb04a23233570667fa84">libevdev_event_type_from_name_n</a> (const char *name, size_t len)</td></tr>
<tr class="memdesc:ga4ee03d650200bb04a23233570667fa84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an event-type by its name.  <a href="group__misc.html#ga4ee03d650200bb04a23233570667fa84">More...</a><br /></td></tr>
<tr class="separator:ga4ee03d650200bb04a23233570667fa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6620301a67f467489e4a7f93afe81621"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga6620301a67f467489e4a7f93afe81621">libevdev_event_code_from_name</a> (unsigned int type, const char *name)</td></tr>
<tr class="memdesc:ga6620301a67f467489e4a7f93afe81621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an event code by its type and name.  <a href="group__misc.html#ga6620301a67f467489e4a7f93afe81621">More...</a><br /></td></tr>
<tr class="separator:ga6620301a67f467489e4a7f93afe81621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17a760a9eea9dc25011f39e1d5c282a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga17a760a9eea9dc25011f39e1d5c282a0">libevdev_event_code_from_name_n</a> (unsigned int type, const char *name, size_t len)</td></tr>
<tr class="memdesc:ga17a760a9eea9dc25011f39e1d5c282a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an event code by its type and name.  <a href="group__misc.html#ga17a760a9eea9dc25011f39e1d5c282a0">More...</a><br /></td></tr>
<tr class="separator:ga17a760a9eea9dc25011f39e1d5c282a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga314903beeafedabe45f879637e7254b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga314903beeafedabe45f879637e7254b0">libevdev_event_value_from_name</a> (unsigned int type, unsigned int code, const char *name)</td></tr>
<tr class="memdesc:ga314903beeafedabe45f879637e7254b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an event value by its type, code and name.  <a href="group__misc.html#ga314903beeafedabe45f879637e7254b0">More...</a><br /></td></tr>
<tr class="separator:ga314903beeafedabe45f879637e7254b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd41b7514cca16c8b8920f16e562e08a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gadd41b7514cca16c8b8920f16e562e08a">libevdev_event_type_from_code_name</a> (const char *name)</td></tr>
<tr class="memdesc:gadd41b7514cca16c8b8920f16e562e08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an event type for a event code name.  <a href="group__misc.html#gadd41b7514cca16c8b8920f16e562e08a">More...</a><br /></td></tr>
<tr class="separator:gadd41b7514cca16c8b8920f16e562e08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab214498fca7a328f8a712ce15bf21982"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gab214498fca7a328f8a712ce15bf21982">libevdev_event_type_from_code_name_n</a> (const char *name, size_t len)</td></tr>
<tr class="memdesc:gab214498fca7a328f8a712ce15bf21982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an event type for a event code name.  <a href="group__misc.html#gab214498fca7a328f8a712ce15bf21982">More...</a><br /></td></tr>
<tr class="separator:gab214498fca7a328f8a712ce15bf21982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabad00f68481d83747a134c0a37aca003"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gabad00f68481d83747a134c0a37aca003">libevdev_event_code_from_code_name</a> (const char *name)</td></tr>
<tr class="memdesc:gabad00f68481d83747a134c0a37aca003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an event code by its name.  <a href="group__misc.html#gabad00f68481d83747a134c0a37aca003">More...</a><br /></td></tr>
<tr class="separator:gabad00f68481d83747a134c0a37aca003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf9af4b8c372d87793e8a3c2dbeb466"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga5bf9af4b8c372d87793e8a3c2dbeb466">libevdev_event_code_from_code_name_n</a> (const char *name, size_t len)</td></tr>
<tr class="memdesc:ga5bf9af4b8c372d87793e8a3c2dbeb466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an event code by its name.  <a href="group__misc.html#ga5bf9af4b8c372d87793e8a3c2dbeb466">More...</a><br /></td></tr>
<tr class="separator:ga5bf9af4b8c372d87793e8a3c2dbeb466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebfc6b0ebb70169c9fec61620f1ea85f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaebfc6b0ebb70169c9fec61620f1ea85f">libevdev_event_value_from_name_n</a> (unsigned int type, unsigned int code, const char *name, size_t len)</td></tr>
<tr class="memdesc:gaebfc6b0ebb70169c9fec61620f1ea85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an event value by its type, code and name.  <a href="group__misc.html#gaebfc6b0ebb70169c9fec61620f1ea85f">More...</a><br /></td></tr>
<tr class="separator:gaebfc6b0ebb70169c9fec61620f1ea85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f4418c98aa475a2fc34d58a197f7edd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga6f4418c98aa475a2fc34d58a197f7edd">libevdev_property_from_name</a> (const char *name)</td></tr>
<tr class="memdesc:ga6f4418c98aa475a2fc34d58a197f7edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an input property by its name.  <a href="group__misc.html#ga6f4418c98aa475a2fc34d58a197f7edd">More...</a><br /></td></tr>
<tr class="separator:ga6f4418c98aa475a2fc34d58a197f7edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa0bc4c7d0d2aedc84c7dcffee9ce29b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaaa0bc4c7d0d2aedc84c7dcffee9ce29b">libevdev_property_from_name_n</a> (const char *name, size_t len)</td></tr>
<tr class="memdesc:gaaa0bc4c7d0d2aedc84c7dcffee9ce29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an input property by its name.  <a href="group__misc.html#gaaa0bc4c7d0d2aedc84c7dcffee9ce29b">More...</a><br /></td></tr>
<tr class="separator:gaaa0bc4c7d0d2aedc84c7dcffee9ce29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions for printing or querying event ranges. </p>
<p>The list of names is compiled into libevdev and is independent of the run-time kernel. Likewise, the max for each event type is compiled in and does not check the kernel at run-time. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabad00f68481d83747a134c0a37aca003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabad00f68481d83747a134c0a37aca003">&#9670;&nbsp;</a></span>libevdev_event_code_from_code_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_code_from_code_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an event code by its name. </p>
<p>For example, the name "ABS_Y" returns 1. For the lookup to succeed, the name must be unique, which is the case for all defines as of kernel 5.0 and likely to be the case in the future.</p>
<p>This is equivalent to <a class="el" href="group__misc.html#ga6620301a67f467489e4a7f93afe81621" title="Look up an event code by its type and name.">libevdev_event_code_from_name()</a> without the need for knowing the event type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input-event value ("ABS_X", "REL_Y", "KEY_A", ...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given event code for the name or -1 if not found. </dd></dl>

</div>
</div>
<a id="ga5bf9af4b8c372d87793e8a3c2dbeb466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bf9af4b8c372d87793e8a3c2dbeb466">&#9670;&nbsp;</a></span>libevdev_event_code_from_code_name_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_code_from_code_name_n </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an event code by its name. </p>
<p>For example, the name "ABS_Y" returns 1. For the lookup to succeed, the name must be unique, which is the case for all defines as of kernel 5.0 and likely to be the case in the future.</p>
<p>This is equivalent to <a class="el" href="group__misc.html#ga17a760a9eea9dc25011f39e1d5c282a0" title="Look up an event code by its type and name.">libevdev_event_code_from_name_n()</a> without the need for knowing the event type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input-event value ("ABS_X", "REL_Y", "KEY_A", ...) </td></tr>
    <tr><td class="paramname">len</td><td>The length of the passed string excluding any terminating 0 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given event code for the name or -1 if not found. </dd></dl>

</div>
</div>
<a id="ga6620301a67f467489e4a7f93afe81621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6620301a67f467489e4a7f93afe81621">&#9670;&nbsp;</a></span>libevdev_event_code_from_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_code_from_name </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an event code by its type and name. </p>
<p>Event codes start with a fixed prefix followed by their name (eg., "ABS_X"). The prefix must be included in the name. It returns the constant assigned to the event code or -1 if not found.</p>
<p>You have to pass the event type where to look for the name. For instance, to resolve "ABS_X" you need to pass EV_ABS as type and "ABS_X" as string. Supported event codes are codes starting with SYN_, KEY_, BTN_, REL_, ABS_, MSC_, SND_, SW_, LED_, REP_, FF_.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The event type (EV_* constant) where to look for the name. </td></tr>
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input-event code ("KEY_A", "ABS_X", "BTN_Y", ...), zero-terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given code constant for the passed name or -1 if not found. </dd></dl>

</div>
</div>
<a id="ga17a760a9eea9dc25011f39e1d5c282a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17a760a9eea9dc25011f39e1d5c282a0">&#9670;&nbsp;</a></span>libevdev_event_code_from_name_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_code_from_name_n </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an event code by its type and name. </p>
<p>Event codes start with a fixed prefix followed by their name (eg., "ABS_X"). The prefix must be included in the name. It returns the constant assigned to the event code or -1 if not found.</p>
<p>You have to pass the event type where to look for the name. For instance, to resolve "ABS_X" you need to pass EV_ABS as type and "ABS_X" as string. Supported event codes are codes starting with SYN_, KEY_, BTN_, REL_, ABS_, MSC_, SND_, SW_, LED_, REP_, FF_.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The event type (EV_* constant) where to look for the name. </td></tr>
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input-event code ("KEY_A", "ABS_X", "BTN_Y", ...). </td></tr>
    <tr><td class="paramname">len</td><td>The length of the string in <code>name</code> excluding any terminating 0 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given code constant for the name or -1 if not found. </dd></dl>

</div>
</div>
<a id="gab407b3c2caaae502859c28460cad17bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab407b3c2caaae502859c28460cad17bb">&#9670;&nbsp;</a></span>libevdev_event_code_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* libevdev_event_code_get_name </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The event type for the code to query (EV_SYN, EV_REL, etc.) </td></tr>
    <tr><td class="paramname">code</td><td>The event code to return the name for (e.g. ABS_X)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the given event code (e.g. ABS_X) or NULL for an invalid type or code</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The list of names is compiled into libevdev. If the kernel adds new defines for new event codes, libevdev will not automatically pick these up. </dd></dl>

</div>
</div>
<a id="ga37766a6a498fef3294d589abcce688bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37766a6a498fef3294d589abcce688bb">&#9670;&nbsp;</a></span>libevdev_event_is_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_is_code </td>
          <td>(</td>
          <td class="paramtype">const struct input_event *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to check if an event is of a specific type and code. </p>
<p>This is virtually the same as: </p><pre class="fragment"> ev-&gt;type == type &amp;&amp; ev-&gt;code == code
</pre><p>with the exception that some sanity checks are performed to ensure type and code are valid.</p>
<dl class="section note"><dt>Note</dt><dd>The ranges for types and codes are compiled into libevdev. If the kernel changes the max value, libevdev will not automatically pick these up.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>The input event to check </td></tr>
    <tr><td class="paramname">type</td><td>Input event type to compare the event against (EV_REL, EV_ABS, etc.) </td></tr>
    <tr><td class="paramname">code</td><td>Input event code to compare the event against (ABS_X, REL_X, etc.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the event type matches the given type and code, 0 otherwise (or if type/code are invalid) </dd></dl>

</div>
</div>
<a id="gab8b6b80740e028261300b8952b61a596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8b6b80740e028261300b8952b61a596">&#9670;&nbsp;</a></span>libevdev_event_is_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_is_type </td>
          <td>(</td>
          <td class="paramtype">const struct input_event *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to check if an event is of a specific type. </p>
<p>This is virtually the same as: </p><pre class="fragment"> ev-&gt;type == type
</pre><p>with the exception that some sanity checks are performed to ensure type is valid.</p>
<dl class="section note"><dt>Note</dt><dd>The ranges for types are compiled into libevdev. If the kernel changes the max value, libevdev will not automatically pick these up.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>The input event to check </td></tr>
    <tr><td class="paramname">type</td><td>Input event type to compare the event against (EV_REL, EV_ABS, etc.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the event type matches the given type, 0 otherwise (or if type is invalid) </dd></dl>

</div>
</div>
<a id="gadd41b7514cca16c8b8920f16e562e08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd41b7514cca16c8b8920f16e562e08a">&#9670;&nbsp;</a></span>libevdev_event_type_from_code_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_type_from_code_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an event type for a event code name. </p>
<p>For example, the name "ABS_Y" returns EV_ABS. For the lookup to succeed, the name must be unique, which is the case for all defines as of kernel 5.0 and likely to be the case in the future.</p>
<p>This is equivalent to <a class="el" href="group__misc.html#ga61ce3bf1e66bd172e583b86a11fc41f1" title="Look up an event-type by its name.">libevdev_event_type_from_name()</a> but takes the code name instead of the type name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input-event value ("ABS_X", "REL_Y", "KEY_A", ...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given event code for the name or -1 if not found. </dd></dl>

</div>
</div>
<a id="gab214498fca7a328f8a712ce15bf21982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab214498fca7a328f8a712ce15bf21982">&#9670;&nbsp;</a></span>libevdev_event_type_from_code_name_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_type_from_code_name_n </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an event type for a event code name. </p>
<p>For example, the name "ABS_Y" returns EV_ABS. For the lookup to succeed, the name must be unique, which is the case for all defines as of kernel 5.0 and likely to be the case in the future.</p>
<p>This is equivalent to <a class="el" href="group__misc.html#ga4ee03d650200bb04a23233570667fa84" title="Look up an event-type by its name.">libevdev_event_type_from_name_n()</a> but takes the code name instead of the type name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input-event value ("ABS_X", "REL_Y", "KEY_A", ...) </td></tr>
    <tr><td class="paramname">len</td><td>The length of the passed string excluding any terminating 0 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given event code for the name or -1 if not found. </dd></dl>

</div>
</div>
<a id="ga61ce3bf1e66bd172e583b86a11fc41f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61ce3bf1e66bd172e583b86a11fc41f1">&#9670;&nbsp;</a></span>libevdev_event_type_from_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_type_from_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an event-type by its name. </p>
<p>Event-types start with "EV_" followed by the name (eg., "EV_ABS"). The "EV_" prefix must be included in the name. It returns the constant assigned to the event-type or -1 if not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input-event type ("EV_KEY", "EV_ABS", ...), zero-terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given type constant for the passed name or -1 if not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>EV_MAX is also recognized. </dd></dl>

</div>
</div>
<a id="ga4ee03d650200bb04a23233570667fa84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ee03d650200bb04a23233570667fa84">&#9670;&nbsp;</a></span>libevdev_event_type_from_name_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_type_from_name_n </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an event-type by its name. </p>
<p>Event-types start with "EV_" followed by the name (eg., "EV_ABS"). The "EV_" prefix must be included in the name. It returns the constant assigned to the event-type or -1 if not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input-event type ("EV_KEY", "EV_ABS", ...). </td></tr>
    <tr><td class="paramname">len</td><td>The length of the passed string excluding any terminating 0 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given type constant for the passed name or -1 if not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>EV_MAX is also recognized. </dd></dl>

</div>
</div>
<a id="gabfad87ea78d034631cf3e5322ac383a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfad87ea78d034631cf3e5322ac383a1">&#9670;&nbsp;</a></span>libevdev_event_type_get_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_type_get_max </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The event type to return the maximum for (EV_ABS, EV_REL, etc.). No max is defined for EV_SYN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The max value defined for the given event type, e.g. ABS_MAX for a type of EV_ABS, or -1 for an invalid type.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The max value is compiled into libevdev. If the kernel changes the max value, libevdev will not automatically pick these up. </dd></dl>

</div>
</div>
<a id="gac99720fd926bf288764f9a81bf37ed09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac99720fd926bf288764f9a81bf37ed09">&#9670;&nbsp;</a></span>libevdev_event_type_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* libevdev_event_type_get_name </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The event type to return the name for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the given event type (e.g. EV_ABS) or NULL for an invalid type</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The list of names is compiled into libevdev. If the kernel adds new defines for new event types, libevdev will not automatically pick these up. </dd></dl>

</div>
</div>
<a id="ga314903beeafedabe45f879637e7254b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga314903beeafedabe45f879637e7254b0">&#9670;&nbsp;</a></span>libevdev_event_value_from_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_value_from_name </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an event value by its type, code and name. </p>
<p>Event values start with a fixed prefix followed by their name (eg., "MT_TOOL_PALM"). The prefix must be included in the name. It returns the constant assigned to the event code or -1 if not found.</p>
<p>You have to pass the event type and code where to look for the name. For instance, to resolve "MT_TOOL_PALM" you need to pass EV_ABS as type, ABS_MT_TOOL_TYPE as code and "MT_TOOL_PALM" as string.</p>
<p>As of kernel 4.17, only EV_ABS/ABS_MT_TOOL_TYPE support name resolution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The event type (EV_* constant) where to look for the name. </td></tr>
    <tr><td class="paramname">code</td><td>The event code (ABS_* constant) where to look for the name. </td></tr>
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input-event value ("MT_TOOL_TYPE", ...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given value constant for the name or -1 if not found. </dd></dl>

</div>
</div>
<a id="gaebfc6b0ebb70169c9fec61620f1ea85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebfc6b0ebb70169c9fec61620f1ea85f">&#9670;&nbsp;</a></span>libevdev_event_value_from_name_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_event_value_from_name_n </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an event value by its type, code and name. </p>
<p>Event values start with a fixed prefix followed by their name (eg., "MT_TOOL_PALM"). The prefix must be included in the name. It returns the constant assigned to the event code or -1 if not found.</p>
<p>You have to pass the event type and code where to look for the name. For instance, to resolve "MT_TOOL_PALM" you need to pass EV_ABS as type, ABS_MT_TOOL_TYPE as code and "MT_TOOL_PALM" as string.</p>
<p>As of kernel 4.17, only EV_ABS/ABS_MT_TOOL_TYPE support name resolution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The event type (EV_* constant) where to look for the name. </td></tr>
    <tr><td class="paramname">code</td><td>The event code (ABS_* constant) where to look for the name. </td></tr>
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input-event value ("MT_TOOL_TYPE", ...) </td></tr>
    <tr><td class="paramname">len</td><td>The length of the string in <code>name</code> excluding any terminating 0 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given value constant for the name or -1 if not found. </dd></dl>

</div>
</div>
<a id="gabcd45c5e963cba245e944ea66e72fcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd45c5e963cba245e944ea66e72fcc3">&#9670;&nbsp;</a></span>libevdev_event_value_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* libevdev_event_value_get_name </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resolves the event value for a code. </p>
<p>For almost all event codes this will return NULL as the value is just a numerical value. As of kernel 4.17, the only event code that will return a non-NULL value is EV_ABS/ABS_MT_TOOL_TYPE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The event type for the value to query (EV_ABS, etc.) </td></tr>
    <tr><td class="paramname">code</td><td>The event code for the value to query (e.g. ABS_MT_TOOL_TYPE) </td></tr>
    <tr><td class="paramname">value</td><td>The event value to return the name for (e.g. MT_TOOL_PALM)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the given event value (e.g. MT_TOOL_PALM) or NULL for an invalid type or code or NULL for an axis that has numerical values only.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The list of names is compiled into libevdev. If the kernel adds new defines for new event values, libevdev will not automatically pick these up. </dd></dl>

</div>
</div>
<a id="ga6f4418c98aa475a2fc34d58a197f7edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f4418c98aa475a2fc34d58a197f7edd">&#9670;&nbsp;</a></span>libevdev_property_from_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_property_from_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an input property by its name. </p>
<p>Properties start with the fixed prefix "INPUT_PROP_" followed by their name (eg., "INPUT_PROP_POINTER"). The prefix must be included in the name. It returns the constant assigned to the property or -1 if not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input property</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given code constant for the name or -1 if not found. </dd></dl>

</div>
</div>
<a id="gaaa0bc4c7d0d2aedc84c7dcffee9ce29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa0bc4c7d0d2aedc84c7dcffee9ce29b">&#9670;&nbsp;</a></span>libevdev_property_from_name_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libevdev_property_from_name_n </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an input property by its name. </p>
<p>Properties start with the fixed prefix "INPUT_PROP_" followed by their name (eg., "INPUT_PROP_POINTER"). The prefix must be included in the name. It returns the constant assigned to the property or -1 if not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A non-NULL string describing an input property </td></tr>
    <tr><td class="paramname">len</td><td>The length of the string in <code>name</code> excluding any terminating 0 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given code constant for the name or -1 if not found. </dd></dl>

</div>
</div>
<a id="gacc12bdb7b912070ac9c375428f2c9892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc12bdb7b912070ac9c375428f2c9892">&#9670;&nbsp;</a></span>libevdev_property_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* libevdev_property_get_name </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prop</td><td>The input prop to return the name for (e.g. INPUT_PROP_BUTTONPAD)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the given input prop (e.g. INPUT_PROP_BUTTONPAD) or NULL for an invalid property</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The list of names is compiled into libevdev. If the kernel adds new defines for new properties libevdev will not automatically pick these up. </dd>
<dd>
On older kernels input properties may not be defined and <a class="el" href="group__misc.html#gacc12bdb7b912070ac9c375428f2c9892">libevdev_property_get_name()</a> will always return NULL </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.20
</small></address>
</body>
</html>
