=head1 NAME

todo - Perl TO-DO list

=head1 DESCRIPTION

This is a list of wishes for Perl. The most up to date version of this file
is at L<https://github.com/Perl/perl5/blob/blead/Porting/todo.pod>.

The tasks we think are smaller or easier are listed first. Anyone is welcome
to work on any of these, but it's a good idea to first contact
I<perl5-porters@perl.org> to avoid duplication of effort, and to learn from
any previous attempts. By all means contact the Steering Council privately
first if you prefer.

Whilst patches to make the list shorter are most welcome, ideas to add to
the list are also encouraged. Check the perl5-porters archives for past
ideas, and any discussion about them. One set of archives may be found at
L<http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/>

What can we offer you in return? Fame, fortune, and everlasting glory? Maybe
not, but if your patch is incorporated, then we'll add your name to the
F<AUTHORS> file, which ships in the official distribution. How many other
programming languages offer you 1 line of immortality?

=head1 Tasks that only need Perl knowledge

=head2 Label bug tickets by type

Known bugs in Perl are tracked by L<https://github.com/Perl/perl5/issues>.
It shows bugs and can be filtered by assigned labels.  However, many are
L<unlabeled|https://github.com/Perl/perl5/issues?q=is%3Aopen+is%3Aissue+no%3Alabel>
or have the label L<"Needs Triage"|https://github.com/Perl/perl5/issues?q=is%3Aopen+is%3Aissue+label%3A%22Needs+Triage%22>.
This greatly lowers the chances of them getting
fixed, as the number of open bugs is overwhelming -- too many to wade
through for someone to try to find the bugs in the parts of
Perl that s/he knows well enough to try to fix.  This task involves
going through these bugs and assigning one or more labels, and removing the
"Needs Triage" label if present.

=head2 Ongoing: investigate new bug reports

When a bug report is filed, it would be very helpful to have someone do
a quick investigation to see if it is a real problem, and to reply to
the poster about it, asking for example code that reproduces the
problem.  Such code should be added to the test suite as TODO tests, and
the ticket should be classified by type.  To get started on this task,
look at the issues with no comments at
L<https://github.com/Perl/perl5/issues?q=is%3Aopen+is%3Aissue+comments%3A0>.

=head2 Migrate t/ from custom TAP generation

Many tests below F<t/> still generate TAP by "hand", rather than using library
functions. As explained in L<perlhack/TESTING>, tests in F<t/> are
written in a particular way to test that more complex constructions actually
work before using them routinely. Hence they don't use C<Test::More>, but
instead there is an intentionally simpler library, F<t/test.pl>. However,
quite a few tests in F<t/> have not been refactored to use it. Refactoring
any of these tests, one at a time, is a useful thing TODO.

The subdirectories F<base>, F<cmd>, F<comp> and F<opbasic>, that contain the
most basic tests, should be excluded from this task.

=head2 Automate perldelta generation

The perldelta file accompanying each release summaries the major changes.
It's mostly manually generated currently, but some of that could be
automated with a bit of perl, specifically the generation of

=over

=item Modules and Pragmata

=item New Documentation

=item New Tests

=back

See L<how_to_write_a_perldelta> for details.

=head2 Make Schwern poorer

We should have tests for everything. When all the core's modules are tested,
Schwern has promised to donate to $500 to TPF. We may need volunteers to
hold him upside down and shake vigorously in order to actually extract the
cash.

=head2 Write descriptions for all tests

Many individual tests in the test suite lack descriptions (or names, or labels
-- call them what you will).  Many files completely lack descriptions, meaning
that the only output you get is the test numbers.  If all tests had
descriptions, understanding what the tests are testing and why they sometimes
fail would both get a whole lot easier.

=head2 Improve the coverage of the core tests

Use Devel::Cover to ascertain the core modules' test coverage, then add
tests that are currently missing.

=head2 test B

A full test suite for the B module would be nice.

=head2 A decent benchmark

C<perlbench> seems impervious to any recent changes made to the perl core. It
would be useful to have a reasonable general benchmarking suite that roughly
represented what current perl programs do, and measurably reported whether
tweaks to the core improve, degrade or don't really affect performance, to
guide people attempting to optimise the guts of perl. Gisle would welcome
new tests for perlbench. Steffen Schwingon would welcome help with
L<Benchmark::Perl::Formance>

=head2 fix tainting bugs

Fix the bugs revealed by running the test suite with the C<-t> switch.
Setting the TEST_ARGS environment variable to C<-taintwarn> will accomplish
this.

=head2 Dual life everything

As part of the "dists" plan, anything that doesn't belong in the smallest perl
distribution needs to be dual lifed. Anything else can be too. Figure out what
changes would be needed to package that module and its tests up for CPAN, and
do so. Test it with older perl releases, and fix the problems you find.

To make a minimal perl distribution, it's useful to look at
F<t/lib/commonsense.t>.

=head2 POSIX memory footprint

Ilya observed that use POSIX; eats memory like there's no tomorrow, and at
various times worked to cut it down. There is probably still fat to cut out -
for example POSIX passes Exporter some very memory hungry data structures.

=head2 makedef.pl and conditional compilation

The script F<makedef.pl> generates the list of exported symbols on
platforms which need this. Functions are declared in F<embed.fnc>, variables
in F<intrpvar.h>. Quite a few of the functions and variables are conditionally
declared there, using C<#ifdef>. However, F<makedef.pl> doesn't understand the
C macros, so the rules about which symbols are present when is duplicated in
the Perl code. Writing things twice is bad, m'kay. It would be good to teach
F<.pl> to understand the conditional compilation, and hence remove the
duplication, and the mistakes it has caused.

=head2 use strict; and AutoLoad

Currently if you write

    package Whack;
    use AutoLoader 'AUTOLOAD';
    use strict;
    1;
    __END__
    sub bloop {
        print join (' ', No, strict, here), "!\n";
    }

then C<use strict;> isn't in force within the autoloaded subroutines. It would
be more consistent (and less surprising) to arrange for all lexical pragmas
in force at the __END__ block to be in force within each autoloaded subroutine.

There's a similar problem with SelfLoader.

=head2 profile installman

The F<installman> script is slow. All it is doing text processing, which we're
told is something Perl is good at. So it would be nice to know what it is doing
that is taking so much CPU, and where possible address it.

=head2 enable lexical enabling/disabling of individual warnings

Currently, warnings can only be enabled or disabled by category. There
are times when it would be useful to quash a single warning, not a
whole category.

=head2 document diagnostics

Many diagnostic messages are not currently documented.  The list is at the end
of t/porting/diag.t.

=head2 Write TODO tests for open bugs

Sometimes bugs get fixed as a side effect of something else, and
the bug remains open because no one realizes that it has been fixed.
Ideally, every open bug should have a TODO test in the core test suite.

=head2 deparse warnings nicely

Currently Deparse punts on deparsing the bitmask for warnings, which it
dumps uglily as-is. Try running this:

    $ ./perl -Ilib -MO=Deparse -e 'use warnings "pipe"; die'

Deparse.pm could use the package variables in warnings.pm that warnings.pm
itself uses to convert the list passed to it into a bitfield. Deparse just
needs to reverse that.

=head2 test and fix Deparse with perl's test suite

If you run perl's tests with the TEST_ARGS environment variable set to
C<-deparse> (e.g., run C<TEST=-deparse make test>), each test file will be
deparsed and the deparsed output will be run. Currently there are many 
failures, which ought to be fixed. There is in F<Porting/deparse-skips.txt>
a list of tests known to fail, but it is out of date. Updating it would
also help.

This is an incremental task. Every small bit helps. It is also a task that
may never end. As new tests are added, they tickle corner cases that
B::Deparse cannot yet handle correctly.

This task I<may> need a bit of perl guts knowledge. But what changes need
to be made is usually easy to see by dumping op trees with B::Concise:

    $ ./perl -Ilib -MO=Concise -e 'foo(); print @_; die $$_'

and adjusting B::Deparse to handle whatever you see B::Concise produce.
This is also a good way to I<learn> how perl's op trees work.

=head1 Tasks that need a little sysadmin-type knowledge

Or if you prefer, tasks that you would learn from, and broaden your skills
base...

=head2 make HTML install work

There is an C<install.html> target in the Makefile. It's marked as
"experimental". It would be good to get this tested, make it work reliably, and
remove the "experimental" tag. This would include

=over 4

=item 1

Checking that cross linking between various parts of the documentation works.
In particular that links work between the modules (files with POD in F<lib/>)
and the core documentation (files in F<pod/>)

=item 2

Improving the code that split C<perlfunc> into chunks, preferably with
general case code added to L<Pod::Functions> that could be used elsewhere.

Challenges here are correctly identifying the groups of functions that go
together, and making the right named external cross-links point to the right
page. Currently this works reasonably well in the general case, and correctly
parses two or more C<=items> giving the different parameter lists for the
same function, such used by C<substr>. However it fails completely where
I<different> functions are listed as a sequence of C<=items> but share the
same description. All the functions from C<getpwnam> to C<endprotoent> have
individual stub pages, with only the page for C<endservent> holding the
description common to all. Likewise C<q>, C<qq> and C<qw> have stub pages,
instead of sharing the body of C<qx>.

Note also the current code isn't ideal with the two forms of C<select>, mushing
them both into one F<select.html> with the two descriptions run together.
Fixing this may well be a special case.

=back

=head2 compressed man pages

Be able to install them. This would probably need a configure test to see how
the system does compressed man pages (same directory/different directory?
same filename/different filename), as well as tweaking the F<installman> script
to compress as necessary.

=head2 Add a code coverage target to the Makefile

Make it easy for anyone to run Devel::Cover on the core's tests. The steps
to do this manually are roughly

=over 4

=item *

do a normal C<Configure>, but include Devel::Cover as a module to install
(see L<INSTALL> for how to do this)

=item *

    make perl

=item *

 cd t; HARNESS_PERL_SWITCHES=-MDevel::Cover ./perl -I../lib harness

=item *

Process the resulting Devel::Cover database

=back

This just give you the coverage of the F<.pm>s. To also get the C level
coverage you need to

=over 4

=item *

Additionally tell C<Configure> to use the appropriate C compiler flags for
C<gcov>

=item *

    make perl.gcov

(instead of C<make perl>)

=item *

After running the tests run C<gcov> to generate all the F<.gcov> files.
(Including down in the subdirectories of F<ext/>

=item *

(From the top level perl directory) run C<gcov2perl> on all the C<.gcov> files
to get their stats into the cover_db directory.

=item *

Then process the Devel::Cover database

=back

It would be good to add a single switch to C<Configure> to specify that you
wanted to perform perl level coverage, and another to specify C level
coverage, and have C<Configure> and the F<Makefile> do all the right things
automatically.

=head2 Make Config.pm cope with differences between built and installed perl

Quite often vendors ship a perl binary compiled with their (pay-for)
compilers.  People install a free compiler, such as gcc. To work out how to
build extensions, Perl interrogates C<%Config>, so in this situation
C<%Config> describes compilers that aren't there, and extension building
fails. This forces people into choosing between re-compiling perl themselves
using the compiler they have, or only using modules that the vendor ships.

It would be good to find a way teach C<Config.pm> about the installation setup,
possibly involving probing at install time or later, so that the C<%Config> in
a binary distribution better describes the installed machine, when the
installed machine differs from the build machine in some significant way.

=head2 linker specification files

Some platforms mandate that you provide a list of a shared library's external
symbols to the linker, so the core already has the infrastructure in place to
do this for generating shared perl libraries. Florian Ragwitz has been working
to offer this for the GNU toolchain, to  allow Unix users to test that the
export list is correct, and to build a perl that does not pollute the global
namespace with private symbols, and will fail in the same way as msvc or mingw 
builds or when using PERL_DL_NONLAZY=1. See the branch smoke-me/rafl/ld_export

=head2 Cross-compile support

We get requests for "how to cross compile Perl". The vast majority of these
seem to be for a couple of scenarios:

=over 4

=item *

Platforms that could build natively using F<./Configure> (I<e.g.> Linux or
NetBSD on MIPS or ARM) but people want to use a beefier machine (and on the
same OS) to build more easily.

=item *

Platforms that can't build natively, but no (significant) porting changes
are needed to our current source code. Prime example of this is Android.

=back

There are several scripts and tools for cross-compiling perl for other
platforms. However, these are somewhat inconsistent and scattered across the
codebase, none are documented well, none are clearly flexible enough to
be confident that they can support any TARGET/HOST platform pair other than
that which they were developed on, and it's not clear how bitrotted they are.

For example, C<Configure> understands C<-Dusecrosscompile> option. This option
arranges for building C<miniperl> for TARGET machine, so this C<miniperl> is
assumed then to be copied to TARGET machine and used as a replacement of
full C<perl> executable. This code is almost 10 years old. Meanwhile, the
F<Cross/> directory contains two different approaches for cross compiling to
ARM Linux targets, relying on hand curated F<config.sh> files, but that code
is getting on for 5 years old, and requires insider knowledge of perl's
build system to draft a F<config.sh> for a new platform.

Jess Robinson has submitted a grant to TPF to work on cleaning this up.

=head2 Split "linker" from "compiler"

Right now, Configure probes for two commands, and sets two variables:

=over 4

=item * C<cc> (in F<cc.U>)

This variable holds the name of a command to execute a C compiler which
can resolve multiple global references that happen to have the same
name.  Usual values are F<cc> and F<gcc>.
Fervent ANSI compilers may be called F<c89>.  AIX has F<xlc>.

=item * C<ld> (in F<dlsrc.U>)

This variable indicates the program to be used to link
libraries for dynamic loading.  On some systems, it is F<ld>.
On ELF systems, it should be C<$cc>.  Mostly, we'll try to respect
the hint file setting.

=back

There is an implicit historical assumption from around Perl5.000alpha
something, that C<$cc> is also the correct command for linking object files
together to make an executable. This may be true on Unix, but it's not true
on other platforms, and there are a maze of work arounds in other places (such
as F<Makefile.SH>) to cope with this.

Ideally, we should create a new variable to hold the name of the executable
linker program, probe for it in F<Configure>, and centralise all the special
case logic there or in hints files.

A small bikeshed issue remains - what to call it, given that C<$ld> is already
taken (arguably for the wrong thing now, but on SunOS 4.1 it is the command
for creating dynamically-loadable modules) and C<$link> could be confused with
the Unix command line executable of the same name, which does something
completely different. Andy Dougherty makes the counter argument "In parrot, I
tried to call the command used to link object files and  libraries into an
executable F<link>, since that's what my vaguely-remembered DOS and VMS
experience suggested. I don't think any real confusion has ensued, so it's
probably a reasonable name for perl5 to use."

"Alas, I've always worried that introducing it would make things worse, 
since now the module building utilities would have to look for 
C<$Config{link}> and institute a fall-back plan if it weren't found."
Although I can see that as confusing, given that C<$Config{d_link}> is true
when (hard) links are available.

=head2 Configure Windows using PowerShell

Currently, Windows uses hard-coded config files based to build the
config.h for compiling Perl.  Makefiles are also hard-coded and need to be 
hand edited prior to building Perl. While this makes it easy to create a perl.exe 
that works across multiple Windows versions, being able to accurately
configure a perl.exe for a specific Windows versions and VS C++ would be
a nice enhancement.  With PowerShell available on Windows XP and up, this 
may now be possible.  Step 1 might be to investigate whether this is possible
and use this to clean up our current makefile situation.  Step 2 would be to 
see if there would be a way to use our existing metaconfig units to configure a
Windows Perl or whether we go in a separate direction and make it so.  Of 
course, we all know what step 3 is.

=head1 Tasks that need a little C knowledge

These tasks would need a little C knowledge, but don't need any specific
background or experience with XS, or how the Perl interpreter works

=head2 Weed out needless PERL_UNUSED_ARG

The C code uses the macro C<PERL_UNUSED_ARG> to stop compilers warning about
unused arguments. Often the arguments can't be removed, as there is an
external constraint that determines the prototype of the function, so this
approach is valid. However, there are some cases where C<PERL_UNUSED_ARG>
could be removed. Specifically

=over 4

=item *

The prototypes of (nearly all) static functions can be changed

=item *

Unused arguments generated by short cut macros are wasteful - the short cut
macro used can be changed.

=back

=head2 -Duse32bit*

Natively 64-bit systems need neither -Duse64bitint nor -Duse64bitall.
On these systems, it might be the default compilation mode, and there
is currently no guarantee that passing no use64bitall option to the
Configure process will build a 32bit perl. Implementing -Duse32bit*
options would be nice for a future version.

=head2 Profile Perl - am I hot or not?

The Perl source code is stable enough that it makes sense to profile it,
identify and optimise the hotspots. It would be good to measure the
performance of the Perl interpreter using free tools such as cachegrind,
gprof, and dtrace, and work to reduce the bottlenecks they reveal.

As part of this, the idea of F<pp_hot.c> is that it contains the I<hot> ops,
the ops that are most commonly used. The idea is that by grouping them, their
object code will be adjacent in the executable, so they have a greater chance
of already being in the CPU cache (or swapped in) due to being near another op
already in use.

Except that it's not clear if these really are the most commonly used ops. So
as part of exercising your skills with coverage and profiling tools you might
want to determine what ops I<really> are the most commonly used. And in turn
suggest evictions and promotions to achieve a better F<pp_hot.c>.

One piece of Perl code that might make a good testbed is F<installman>.

=head2 Use secure CRT functions when building with VC8 on Win32

Visual C++ 2005 (VC++ 8.x) deprecated a number of CRT functions on the basis
that they were "unsafe" and introduced differently named secure versions of
them as replacements, e.g. instead of writing

    FILE* f = fopen(__FILE__, "r");

one should now write

    FILE* f;
    errno_t err = fopen_s(&f, __FILE__, "r"); 

Currently, the warnings about these deprecations have been disabled by adding
-D_CRT_SECURE_NO_DEPRECATE to the CFLAGS. It would be nice to remove that
warning suppressant and actually make use of the new secure CRT functions.

There is also a similar issue with POSIX CRT function names like fileno having
been deprecated in favour of ISO C++ conformant names like _fileno. These
warnings are also currently suppressed by adding -D_CRT_NONSTDC_NO_DEPRECATE. It
might be nice to do as Microsoft suggest here too, although, unlike the secure
functions issue, there is presumably little or no benefit in this case.

=head2 Fix POSIX::access() and chdir() on Win32

These functions currently take no account of DACLs and therefore do not behave
correctly in situations where access is restricted by DACLs (as opposed to the
read-only attribute).

Furthermore, POSIX::access() behaves differently for directories having the
read-only attribute set depending on what CRT library is being used. For
example, the _access() function in the VC7 CRT (wrongly) claims that
such directories are not writable, whereas in fact all directories are writable
unless access is denied by DACLs. (In the case of directories, the read-only
attribute actually only means that the directory cannot be deleted.) This CRT
bug is fixed in the VC8 and VC9 CRTs (but, of course, the directory may still
not actually be writable if access is indeed denied by DACLs).

For the chdir() issue, see ActiveState bug #74552:
L<http://bugs.activestate.com/show_bug.cgi?id=74552>

Therefore, DACLs should be checked both for consistency across CRTs and for
the correct answer.

(Note that perl's -w operator should not be modified to check DACLs. It has
been written so that it reflects the state of the read-only attribute, even
for directories (whatever CRT is being used), for symmetry with chmod().)

=head2 Arenas for GPs? For MAGIC?

C<struct gp> and C<struct magic> are both currently allocated by C<malloc>.
It might be a speed or memory saving to change to using arenas. Or it might
not. It would need some suitable benchmarking first. In particular, C<GP>s
can probably be changed with minimal compatibility impact (probably nothing
outside of the core, or even outside of F<gv.c> allocates them), but they
probably aren't allocated/deallocated often enough for a speed saving. Whereas
C<MAGIC> is allocated/deallocated more often, but in turn, is also something
more externally visible, so changing the rules here may bite external code.

=head2 Shared arenas

Several SV body structs are now the same size, notably PVMG and PVGV, PVAV and
PVHV, and PVCV and PVFM. It should be possible to allocate and return same
sized bodies from the same actual arena, rather than maintaining one arena for
each. This could save 4-6K per thread, of memory no longer tied up in the
not-yet-allocated part of an arena.


=head1 Tasks that need a knowledge of XS

These tasks would need C knowledge, and roughly the level of knowledge of
the perl API that comes from writing modules that use XS to interface to
C.

=head2 Write an XS cookbook

Create pod/perlxscookbook.pod with short, task-focused 'recipes' in XS that
demonstrate common tasks and good practices.  (Some of these might be
extracted from perlguts.) The target audience should be XS novices, who need
more examples than perlguts but something less overwhelming than perlapi.
Recipes should provide "one pretty good way to do it" instead of TIMTOWTDI.

Rather than focusing on interfacing Perl to C libraries, such a cookbook
should probably focus on how to optimize Perl routines by re-writing them
in XS.  This will likely be more motivating to those who mostly work in
Perl but are looking to take the next step into XS.

Deconstructing and explaining some simpler XS modules could be one way to
bootstrap a cookbook.  (List::Util? Class::XSAccessor? Tree::Ternary_XS?)
Another option could be deconstructing the implementation of some simpler
functions in op.c.

=head2 Document how XSUBs can use C<cv_set_call_checker> to inline themselves as OPs

For a simple XSUB, often the subroutine dispatch takes more time than the
XSUB itself. v5.14.0 now allows XSUBs to register a function which will be
called when the parser is finished building an C<entersub> op which calls
them.

Registration is done with C<Perl_cv_set_call_checker>, is documented at the
API level in L<perlapi>, and L<perl5140delta/Custom per-subroutine check hooks>
notes that it can be used to inline a subroutine, by replacing it with a
custom op. However there is no further detail of the code needed to do this.
It would be useful to add one or more annotated examples of how to create
XSUBs that inline.

This should provide a measurable speed up to simple XSUBs inside
tight loops. Initially one would have to write the OP alternative
implementation by hand, but it's likely that this should be reasonably
straightforward for the type of XSUB that would benefit the most. Longer
term, once the run-time implementation is proven, it should be possible to
progressively update ExtUtils::ParseXS to generate OP implementations for
some XSUBs.

=head2 Document how XS modules can install lexical subs

There is an example in XS::APItest (look for C<lexical_import> in
F<ext/XS-APItest/APItest.xs>). The documentation could be based on it.

=head2 Remove the use of SVs as temporaries in dump.c

F<dump.c> contains debugging routines to dump out the contains of perl data
structures, such as C<SV>s, C<AV>s and C<HV>s. Currently, the dumping code
B<uses> C<SV>s for its temporary buffers, which was a logical initial
implementation choice, as they provide ready made memory handling.

However, they also lead to a lot of confusion when it happens that what you're
trying to debug is seen by the code in F<dump.c>, correctly or incorrectly, as
a temporary scalar it can use for a temporary buffer. It's also not possible
to dump scalars before the interpreter is properly set up, such as during
ithreads cloning. It would be good to progressively replace the use of scalars
as string accumulation buffers with something much simpler, directly allocated
by C<malloc>. The F<dump.c> code is (or should be) only producing 7 bit
US-ASCII, so output character sets are not an issue.

Producing and proving an internal simple buffer allocation would make it easier
to re-write the internals of the PerlIO subsystem to avoid using C<SV>s for
B<its> buffers, use of which can cause problems similar to those of F<dump.c>,
at similar times.

=head2 safely supporting POSIX SA_SIGINFO

Some years ago Jarkko supplied patches to provide support for the POSIX
SA_SIGINFO feature in Perl, passing the extra data to the Perl signal handler.

Unfortunately, it only works with "unsafe" signals, because under safe
signals, by the time Perl gets to run the signal handler, the extra
information has been lost. Moreover, it's not easy to store it somewhere,
as you can't call mutexs, or do anything else fancy, from inside a signal
handler.

So it strikes me that we could provide safe SA_SIGINFO support

=over 4

=item 1

Provide global variables for two file descriptors

=item 2

When the first request is made via C<sigaction> for C<SA_SIGINFO>, create a
pipe, store the reader in one, the writer in the other

=item 3

In the "safe" signal handler (C<Perl_csighandler()>/C<S_raise_signal()>), if
the C<siginfo_t> pointer non-C<NULL>, and the writer file handle is open,

=over 8

=item 1

serialise signal number, C<struct siginfo_t> (or at least the parts we care
about) into a small auto char buff

=item 2

C<write()> that (non-blocking) to the writer fd

=over 12

=item 1

if it writes 100%, flag the signal in a counter of "signals on the pipe" akin
to the current per-signal-number counts

=item 2

if it writes 0%, assume the pipe is full. Flag the data as lost?

=item 3

if it writes partially, croak a panic, as your OS is broken.

=back

=back

=item 4

in the regular C<PERL_ASYNC_CHECK()> processing, if there are "signals on
the pipe", read the data out, deserialise, build the Perl structures on
the stack (code in C<Perl_sighandler()>, the "unsafe" handler), and call as
usual.

=back

I think that this gets us decent C<SA_SIGINFO> support, without the current risk
of running Perl code inside the signal handler context. (With all the dangers
of things like C<malloc> corruption that that currently offers us)

For more information see the thread starting with this message:
L<http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2008-03/msg00305.html>

=head2 autovivification

Make all autovivification consistent w.r.t LVALUE/RVALUE and strict/no strict;

This task is incremental - even a little bit of work on it will help.

=head2 Unicode in Filenames

chdir, chmod, chown, chroot, exec, glob, link, lstat, mkdir, open,
opendir, qx, readdir, readlink, rename, rmdir, stat, symlink, sysopen,
system, truncate, unlink, utime, -X.  All these could potentially accept
Unicode filenames either as input or output (and in the case of system
and qx Unicode in general, as input or output to/from the shell).
Whether a filesystem - an operating system pair understands Unicode in
filenames varies.

Known combinations that have some level of understanding include
Microsoft NTFS, Apple HFS+ (In Mac OS 9 and X) and Apple UFS (in Mac
OS X), NFS v4 is rumored to be Unicode, and of course Plan 9.  How to
create Unicode filenames, what forms of Unicode are accepted and used
(UCS-2, UTF-16, UTF-8), what (if any) is the normalization form used,
and so on, varies.  Finding the right level of interfacing to Perl
requires some thought.  Remember that an OS does not implicate a
filesystem.

(The Windows -C command flag "wide API support" has been at least
temporarily retired in 5.8.1, and the -C has been repurposed, see
L<perlrun>.)

Most probably the right way to do this would be this:
L</"Virtualize operating system access">.

=head2 Unicode in %ENV

Currently the %ENV entries are always byte strings.
See L</"Virtualize operating system access">.

(See github issue gh12161 for information on Win32's handling of %ENV,
which was fixed to work with native ANSI codepage characters in the
environment, but still doesn't work with other characters outside of
that codepage present in the environment.)

=head2 Unicode and glob()

Currently glob patterns and filenames returned from File::Glob::glob()
are always byte strings.  See L</"Virtualize operating system access">.

=head2 use less 'memory'

Investigate trade offs to switch out perl's choices on memory usage.
Particularly perl should be able to give memory back.

This task is incremental - even a little bit of work on it will help.

=head2 Re-implement C<:unique> in a way that is actually thread-safe

The old implementation made bad assumptions on several levels. A good 90%
solution might be just to make C<:unique> work to share the string buffer
of SvPVs. That way large constant strings can be shared between ithreads,
such as the configuration information in F<Config>.

=head2 Make tainting consistent

Tainting would be easier to use if it didn't take documented shortcuts and
allow taint to "leak" everywhere within an expression.

=head2 readpipe(LIST)

system() accepts a LIST syntax (and a PROGRAM LIST syntax) to avoid
running a shell. readpipe() (the function behind qx//) could be similarly
extended. Note that changing readpipe() itself may not be the solution, as
it currently has unary precedence, and allowing a list would change the
precedence.

=head2 Audit the code for destruction ordering assumptions

Change 25773 notes

 /* Need to check SvMAGICAL, as during global destruction it may be that
    AvARYLEN(av) has been freed before av, and hence the SvANY() pointer
    is now part of the linked list of SV heads, rather than pointing to
    the original body.  */
 /* FIXME - audit the code for other bugs like this one.  */

adding the C<SvMAGICAL> check to

    if (AvARYLEN(av) && SvMAGICAL(AvARYLEN(av))) {
        MAGIC *mg = mg_find (AvARYLEN(av), PERL_MAGIC_arylen);

Go through the core and look for similar assumptions that SVs have particular
types, as all bets are off during global destruction.

=head2 Extend PerlIO and PerlIO::Scalar

PerlIO::Scalar doesn't know how to truncate().  Implementing this
would require extending the PerlIO vtable.

Similarly the PerlIO vtable doesn't know about formats (write()), or
about stat(), or chmod()/chown(), utime(), or flock().

(For PerlIO::Scalar it's hard to see what e.g. mode bits or ownership
would mean.)

PerlIO doesn't do directories or symlinks, either: mkdir(), rmdir(),
opendir(), closedir(), seekdir(), rewinddir(), glob(); symlink(),
readlink().

See also L</"Virtualize operating system access">.

=head2 Organize error messages

Perl's diagnostics (error messages, see L<perldiag>) could use
reorganizing and formalizing so that each error message has its
stable-for-all-eternity unique id, categorized by severity, type, and
subsystem.  (The error messages would be listed in a datafile outside
of the Perl source code, and the source code would only refer to the
messages by the id.)  This clean-up and regularizing should apply
for all croak() messages.

This would enable all sorts of things: easier translation/localization
of the messages (though please do keep in mind the caveats of
L<Locale::Maketext> about too straightforward approaches to
translation), filtering by severity, and instead of grepping for a
particular error message one could look for a stable error id.  (Of
course, changing the error messages by default would break all the
existing software depending on some particular error message...)

This kind of functionality is known as I<message catalogs>.  Look for
inspiration for example in the catgets() system, possibly even use it
if available-- but B<only> if available, all platforms will B<not>
have catgets().

For the really pure at heart, consider extending this item to cover
also the warning messages (see L<warnings>, F<regen/warnings.pl>).

=head1 Tasks that need a knowledge of the interpreter

These tasks would need C knowledge, and knowledge of how the interpreter works,
or a willingness to learn.

=head2 fix refaliasing with nested and recursive subroutines

Currently aliasing lexical variables via reference only applies to the
current subroutine, and does not propagate to inner closures, nor does
aliasing of outer variables within closures propagate to the outer
subroutine. This is because each subroutine has its own lexical pad and the
aliasing works by changing which SV the pad points to.

One possible way to fix this would be to create new ops for accessing
variables that are closed over. So C<my $x; sub {$x}> would use a new op
type, say C<padoutsv>, instead of the C<padsv> currently used in the
sub. That new op would possibly check a flag or some such and see if it
needs to fetch the variable from an outer pad. If we follow this approach,
it should be possible at compile time to detect cases where the more
complex C<padoutsv> op is unnecessary and revert back to the simpler,
faster C<padsv>. There would need to be corresponding ops for arrays,
hashes, and subs, too.

There is also a related issue with recursion and C<state> variables. A
subroutine actually has a list of lexical pads, each one used at a
different recursion level. If a C<state> variable is aliased to another
variable after a recursive call to the same subroutine, that higher call
depth will not see the effect of aliasing, because the second pad will have
been created already. Similarly, aliasing a state variable within a
recursive call will not affect outer calls, even though all call depths are
supposed to share the same C<state> variables.

Both of these bugs affect C<foreach> aliasing, too.

=head2 forbid labels with keyword names

Currently C<goto keyword> "computes" the label value:

    $ perl -e 'goto print'
    Can't find label 1 at -e line 1.

It is controversial if the right way to avoid the confusion is to forbid
labels with keyword names, or if it would be better to always treat
bareword expressions after a "goto" as a label and never as a keyword.

=head2 truncate() prototype

The prototype of truncate() is currently C<$$>. It should probably
be C<*$> instead. (This is changed in F<regen/opcodes>.)

=head2 error reporting of [$a ; $b]

Using C<;> inside brackets is a syntax error, and we don't propose to change
that by giving it any meaning. However, it's not reported very helpfully:

    $ perl -e '$a = [$b; $c];'
    syntax error at -e line 1, near "$b;"
    syntax error at -e line 1, near "$c]"
    Execution of -e aborted due to compilation errors.

It should be possible to hook into the tokeniser or the lexer, so that when a
C<;> is parsed where it is not legal as a statement terminator (ie inside
C<{}> used as a hashref, C<[]> or C<()>) it issues an error something like
I<';' isn't legal inside an expression - if you need multiple statements use a
do {...} block>. See the thread starting at
L<http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2008-09/msg00573.html>

=head2 strict as warnings

See L<http://markmail.org/message/vbrupaslr3bybmvk>, where Joshua ben Jore
writes:  I've been of the opinion that everything strict.pm does ought to be
able to considered just warnings that have been promoted to 'FATAL'.

=head2 lexicals used only once

This warns:

    $ perl -we '$pie = 42'
    Name "main::pie" used only once: possible typo at -e line 1.

This does not:

    $ perl -we 'my $pie = 42'

Logically all lexicals used only once should warn, if the user asks for
warnings.  An unworked ticket (gh3073) was open for many years for this
discrepancy.

=head2 state variable initialization in list context

Currently this is illegal:

    state ($a, $b) = foo(); 

In Raku, C<state ($a) = foo();> and C<(state $a) = foo();> have different
semantics, which is tricky to implement in Perl 5 as currently they produce
the same opcode trees. The Raku design is firm, so it would be good to
implement the necessary code in Perl 5. There are comments in
C<Perl_newASSIGNOP()> that show the code paths taken by various assignment
constructions involving state variables.

=head2 A does() built-in

Like ref(), only useful. It would call the C<DOES> method on objects; it
would also tell whether something can be dereferenced as an
array/hash/etc., or used as a regexp, etc.
L<http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2007-03/msg00481.html>

=head2 Tied filehandles and write() don't mix

There is no method on tied filehandles to allow them to be called back by
formats.

=head2 Propagate compilation hints to the debugger

Currently a debugger started with -dE on the command-line doesn't see the
features enabled by -E. More generally hints (C<$^H> and C<%^H>) aren't
propagated to the debugger. Probably it would be a good thing to propagate
hints from the innermost non-C<DB::> scope: this would make code eval'ed
in the debugger see the features (and strictures, etc.) currently in
scope.

=head2 Attach/detach debugger from running program

The old perltodo notes "With C<gdb>, you can attach the debugger to a running
program if you pass the process ID. It would be good to do this with the Perl
debugger on a running Perl program, although I'm not sure how it would be
done." ssh and screen do this with named pipes in /tmp. Maybe we can too.

=head2 regexp optimizer optional

The regexp optimizer is not optional. It should be configurable to be optional
and to allow its performance to be measured and its bugs to be easily
demonstrated.

=head2 C</w> regex modifier

That flag would enable to match whole words, and also to interpolate
arrays as alternations. With it, C<m/P/w> would be roughly equivalent to:

    do { local $"='|'; m/\b(?:P)\b/ }

See
L<http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2007-01/msg00400.html>
for the discussion.

=head2 optional optimizer

Make the peephole optimizer optional. Currently it performs two tasks as
it walks the optree - genuine peephole optimisations, and necessary fixups of
ops. It would be good to find an efficient way to switch out the
optimisations whilst keeping the fixups.

=head2 You WANT *how* many

Currently contexts are void, scalar and list. split has a special mechanism in
place to pass in the number of return values wanted. It would be useful to
have a general mechanism for this, backwards compatible and little speed hit.
This would allow proposals such as short circuiting sort to be implemented
as a module on CPAN.

=head2 Self-ties

Self-ties are currently illegal because they caused too many segfaults. Maybe
the causes of these could be tracked down and self-ties on all types
reinstated.

=head2 Optimize away @_

The old perltodo notes "Look at the "reification" code in C<av.c>".

=head2 Virtualize operating system access

Implement a set of "vtables" that virtualizes operating system access
(chdir(), chmod(), dbmopen(), getenv(), glob(), link(), mkdir(), open(),
opendir(), readdir(), rename(), rmdir(), stat(), sysopen(), uname(),
unlink(), etc.).  At the very least these interfaces should take SVs as
"name" arguments instead of bare char pointers; probably the most
flexible and extensible way would be for the Perl-facing interfaces to
accept HVs.  The system needs to be per-operating-system and
per-file-system hookable/filterable, preferably both from XS and Perl
level (L<perlport/"Files and Filesystems"> is good reading at this
point, in fact, all of L<perlport> is.)

This has actually already been implemented (but only for Win32),
take a look at F<iperlsys.h> and F<win32/perlhost.h>.  While all Win32
variants go through a set of "vtables" for operating system access,
non-Win32 systems currently go straight for the POSIX/Unix-style
system/library call.  Similar system as for Win32 should be
implemented for all platforms.  The existing Win32 implementation
probably does not need to survive alongside this proposed new
implementation, the approaches could be merged.

What would this give us?  One often-asked-for feature this would
enable is using Unicode for filenames, and other "names" like %ENV,
usernames, hostnames, and so forth.
(See L<perlunicode/"When Unicode Does Not Happen">.)

But this kind of virtualization would also allow for things like
virtual filesystems, virtual networks, and "sandboxes" (though as long
as dynamic loading of random object code is allowed, not very safe
sandboxes since external code of course know not of Perl's vtables).
An example of a smaller "sandbox" is that this feature can be used to
implement per-thread working directories: Win32 already does this.

See also L</"Extend PerlIO and PerlIO::Scalar">.

=head2 repack the optree

B<Note:> This entry was written in reference to the I<old> slab allocator,
removed in commit 7aef8e5bd14.

Repacking the optree after execution order is determined could allow
removal of NULL ops, and optimal ordering of OPs with respect to cache-line
filling.  I think that
the best way to do this is to make it an optional step just before the
completed optree is attached to anything else, and to use the slab allocator
unchanged--but allocate a single slab the right size, avoiding partial
slabs--, so that freeing ops is identical whether or not this step runs.
Note that the slab allocator allocates ops downwards in memory, so one would
have to actually "allocate" the ops in reverse-execution order to get them
contiguous in memory in execution order.

See
L<http://www.nntp.perl.org/group/perl.perl5.porters/2007/12/msg131975.html>

Note that running this copy, and then freeing all the old location ops would
cause their slabs to be freed, which would eliminate possible memory wastage if
the previous suggestion is implemented, and we swap slabs more frequently.

=head2 eliminate incorrect line numbers in warnings

This code

    use warnings;
    my $undef;

    if ($undef == 3) {
    } elsif ($undef == 0) {
    }

used to produce this output:

    Use of uninitialized value in numeric eq (==) at wrong.pl line 4.
    Use of uninitialized value in numeric eq (==) at wrong.pl line 4.

where the line of the second warning was misreported - it should be line 5.
Rafael fixed this - the problem arose because there was no nextstate OP
between the execution of the C<if> and the C<elsif>, hence C<PL_curcop> still
reports that the currently executing line is line 4. The solution was to inject
a nextstate OPs for each C<elsif>, although it turned out that the nextstate
OP needed to be a nulled OP, rather than a live nextstate OP, else other line
numbers became misreported. (Jenga!)

The problem is more general than C<elsif> (although the C<elsif> case is the
most common and the most confusing). Ideally this code

    use warnings;
    my $undef;

    my $a = $undef + 1;
    my $b
      = $undef
      + 1;

would produce this output

 Use of uninitialized value $undef in addition (+) at wrong.pl line 4.
 Use of uninitialized value $undef in addition (+) at wrong.pl line 7.

(rather than lines 4 and 5), but this would seem to require every OP to carry
(at least) line number information.

What might work is to have an optional line number in memory just before the
BASEOP structure, with a flag bit in the op to say whether it's present.
Initially during compile every OP would carry its line number. Then add a late
pass to the optimizer (potentially combined with L</repack the optree>) which
looks at the two ops on every edge of the graph of the execution path. If
the line number changes, flags the destination OP with this information.
Once all paths are traced, replace every op with the flag with a
nextstate-light op (that just updates C<PL_curcop>), which in turn then passes
control on to the true op. All ops would then be replaced by variants that
do not store the line number. (Which, logically, why it would work best in
conjunction with L</repack the optree>, as that is already copying/reallocating
all the OPs)

(Although I should note that we're not certain that doing this for the general
case is worth it)

=head2 optimize tail-calls

Tail-calls present an opportunity for broadly applicable optimization;
anywhere that C<< return foo(...) >> is called, the outer return can
be replaced by a goto, and foo will return directly to the outer
caller, saving (conservatively) 25% of perl's call&return cost, which
is relatively higher than in C.  The scheme language is known to do
this heavily.  B::Concise provides good insight into where this
optimization is possible, ie anywhere entersub,leavesub op-sequence
occurs.

 perl -MO=Concise,-exec,a,b,-main -e 'sub a{ 1 }; sub b {a()}; b(2)'

Bottom line on this is probably a new pp_tailcall function which
combines the code in pp_entersub, pp_leavesub.  This should probably
be done 1st in XS, and using B::Generate to patch the new OP into the
optrees.

=head2 Revisit the regex super-linear cache code

Perl executes regexes using the traditional backtracking algorithm, which
makes it possible to implement a variety of powerful pattern-matching
features (like embedded code blocks), at the cost of taking exponential time
to run on some pathological patterns.  The exponential-time problem is
mitigated by the I<super-linear cache>, which detects when we're processing
such a pathological pattern, and does some additional bookkeeping to avoid
much of the work.  However, that code has bit-rotted a little; some patterns
don't make as much use of it as they should.  The proposal is to analyse
where the current cache code has problems, and extend it to cover those cases.

See also
L<http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2013-01/msg00339.html>

=head1 Big projects

Tasks that will get your name mentioned in the description of the "Highlights
of 5.40.0"

=head2 make ithreads more robust

Generally make ithreads more robust.

This task is incremental - even a little bit of work on it will help, and
will be greatly appreciated.

One bit would be to determine how to clone directory handles on systems
without a C<fchdir> function (in sv.c:Perl_dirp_dup).

Fix Perl_sv_dup, et al so that threads can return objects.

=head1 Tasks for microperl


[ Each and every one of these may be obsolete, but they were listed
  in the old Todo.micro file]

=head2 do away with fork/exec/wait?

(system, popen should be enough?)

=head2 some of the uconfig.sh really needs to be probed (using cc) in buildtime:

(uConfigure? :-) native datatype widths and endianness come to mind

