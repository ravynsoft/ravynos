texinode(Completion System)(Completion Using compctl)(Completion Widgets)(Top)
chapter(Completion System)
cindex(completion system)
cindex(completion, programmable)
cindex(completion, controlling)
sect(Description)

This describes the shell code for the `new' completion system, referred
to as tt(compsys).  It is written in shell functions based on the
features described in
ifzman(zmanref(zshcompwid))\
ifnzman(the previous chapter, noderef(Completion Widgets)).

The features are contextual, sensitive to the point at which completion is
started.  Many completions are already provided.
For this reason, a user can perform a great many tasks without
knowing any details beyond how to initialize the system, which is
described
ifzman(below in INITIALIZATION)\
ifnzman(in noderef(Initialization)).

The context that decides what completion is to be performed may be
startitemize()
itemiz(\
an argument or option position: these describe the position on the
command line at which completion is requested.  For example `first argument
to rmdir, the word being completed names a directory';
)
itemiz(\
a special context, denoting an element in the shell's syntax.  For example
`a word in command position' or `an array subscript'.
)
enditemize()

A full context specification contains other elements, as we shall describe.

Besides commands names and contexts, the system employs two more
concepts, em(styles) and em(tags).  These provide ways for the user
to configure the system's behaviour.

Tags play a dual role.  They serve as a classification system for
the matches, typically indicating a class of object that the user
may need to distinguish.  For example, when completing arguments of the
tt(ls) command the user may prefer to try tt(files) before tt(directories),
so both of these are tags.  They also appear as the rightmost
element in a context specification.

Styles modify various operations of the completion system, such as
output formatting, but also what kinds of completers are used (and in
what order), or which tags are examined.  Styles may accept arguments
and are manipulated using the tt(zstyle) command described in
ifzman(zmanref(zshmodules))\
ifnzman(noderef(The zsh/zutil Module)).

In summary, tags describe em(what) the completion objects are, and style
tt(how) they are to be completed.  At various points of execution, the
completion system checks what styles and/or tags are defined for the
current context, and uses that to modify its behavior.  The full
description of context handling, which determines how tags and other
elements of the context influence the behaviour of styles, is described
ifzman(below in COMPLETION SYSTEM CONFIGURATION)\
ifnzman(in noderef(Completion System Configuration)).

When a completion is requested, a dispatcher function is called;
see the description of tt(_main_complete) in the list of control functions
below. This dispatcher decides which function should
be called to produce the completions, and calls it. The result is
passed to one or more em(completers), functions that implement
individual completion strategies: simple completion, error correction,
completion with error correction, menu selection, etc.

More generally, the shell functions contained in the completion system are
of two types:
startitemize()
itemiz(\
those beginning `tt(comp)' are to be called directly; there are only
a few of these;
)
itemiz(\
those beginning `tt(_)' are called by the
completion code.  The shell functions of this set, which implement
completion behaviour and may be bound to keystrokes, are referred to
as `widgets'.  These proliferate as new completions are required.
)
enditemize()

startmenu()
menu(Initialization)
menu(Completion System Configuration)
menu(Control Functions)
menu(Bindable Commands)
menu(Completion Functions)
menu(Completion Directories)
menu(Completion System Variables)
endmenu()

texinode(Initialization)(Completion System Configuration)()(Completion System)
sect(Initialization)
findex(compinstall)
cindex(completion system, installing)

If the system was installed completely, it should be enough to
call the shell function tt(compinit) from your initialization file; see the
next section.  However, the function tt(compinstall) can be run by a user
to configure various aspects of the completion system.

Usually, tt(compinstall) will insert code into tt(.zshrc), although if
that is not writable it will save it in another file and tell you that
file's location.  Note that it is up to you to make sure that the lines
added to tt(.zshrc) are actually run; you may, for example, need to move
them to an earlier place in the file if tt(.zshrc) usually returns early.
So long as you keep them all together (including the comment lines at the
start and finish), you can rerun tt(compinstall) and it will correctly
locate and modify these lines.  Note, however, that any code you add to
this section by hand is likely to be lost if you rerun tt(compinstall),
although lines using the command `tt(zstyle)' should be gracefully handled.

The new code will take effect next time you start the shell, or run
tt(.zshrc) by hand; there is also an option to make them take effect
immediately.  However, if tt(compinstall) has removed definitions, you will
need to restart the shell to see the changes.

To run tt(compinstall) you will need to make sure it is in a directory
mentioned in your tt(fpath) parameter, which should already be the case if
zsh was properly configured as long as your startup files do not remove the
appropriate directories from tt(fpath).  Then it must be autoloaded
(`tt(autoload -U compinstall)' is recommended).  You can abort the
installation any time you are being prompted for information, and your
tt(.zshrc) will not be altered at all; changes only take place right at the
end, where you are specifically asked for confirmation.

subsect(Use of compinit)
findex(compinit)
cindex(completion system, initializing)

This section describes the use of tt(compinit) to initialize completion for
the current session when called directly; if you have run
tt(compinstall) it will be called automatically from your tt(.zshrc).

To initialize the system, the function tt(compinit) should be in a
directory mentioned in the tt(fpath) parameter, and should be autoloaded
(`tt(autoload -U compinit)' is recommended), and then run simply as
`tt(compinit)'.  This will define a
few utility functions, arrange for all the necessary shell functions to be
autoloaded, and will then re-define all widgets that do completion to use the
new system.  If you use the tt(menu-select) widget, which is part of the
tt(zsh/complist) module, you should make sure that that module is loaded
before the call to tt(compinit) so that that widget is also
re-defined.  If completion styles (see below) are set up to perform
expansion as well as completion by default, and the TAB key is bound to
tt(expand-or-complete), tt(compinit) will rebind it to tt(complete-word);
this is necessary to use the correct form of expansion.

Should you need to use the original completion commands, you can still
bind keys to the old widgets by putting a `tt(.)' in front of the
widget name, e.g. `tt(.expand-or-complete)'.

To speed up the running of tt(compinit), it can be made to produce a dumped
configuration that will be read in on future invocations; this is the
default, but can be turned off by calling tt(compinit) with the
option tt(-D).  The dumped file is tt(.zcompdump) in the same
directory as the startup files (i.e. tt($ZDOTDIR) or tt($HOME));
alternatively, an explicit file name can be given by `tt(compinit -d)
var(dumpfile)'.  The next invocation of tt(compinit) will read the dumped
file instead of performing a full initialization.

If the number of completion files changes, tt(compinit) will recognise this
and produce a new dump file.  However, if the name of a function or the
arguments in the first line of a tt(#compdef) function (as described below)
change, it is easiest to delete the dump file by hand so that
tt(compinit) will re-create it the next time it is run.  The check
performed to see if there are new functions can be omitted by giving
the option tt(-C).  In this case the dump file will only be created if
there isn't one already.

The dumping is actually done by another function, tt(compdump), but you
will only need to run this yourself if you change the configuration
(e.g. using tt(compdef)) and then want to dump the new one.  The name of
the old dumped file will be remembered for this purpose.

If the parameter tt(_compdir) is set, tt(compinit) uses it as a directory
where completion functions can be found; this is only necessary if they are
not already in the function search path.

For security reasons tt(compinit) also checks if the completion system
would use files not owned by root or by the current user, or files in
directories that are world- or group-writable or that are not owned by 
root or by the current user.  If such files or directories are found,
tt(compinit) will ask if the completion system should really be used.  To
avoid these tests and make all files found be used without asking, use the
option tt(-u), and to make tt(compinit) silently ignore all insecure files
and directories use the option tt(-i).  This security check is skipped
entirely when the tt(-C) option is given, provided the dumpfile exists.

findex(compaudit)
The security check can be retried at any time by running the function
tt(compaudit).  This is the same check used by tt(compinit), but when it
is executed directly any changes to tt(fpath) are made local to the
function so they do not persist.  The directories to be checked may be
passed as arguments; if none are given, tt(compaudit) uses tt(fpath) and
tt(_compdir) to find completion system directories, adding missing ones
to tt(fpath) as necessary.  To force a check of exactly the directories
currently named in tt(fpath), set tt(_compdir) to an empty string before
calling tt(compaudit) or tt(compinit).

findex(bashcompinit)
The function tt(bashcompinit) provides compatibility with bash's programmable
completion system.  When run it will define the functions, tt(compgen) and
tt(complete) which correspond to the bash builtins with the same names.
It will then be possible to use completion specifications and functions
written for bash.

subsect(Autoloaded files)
cindex(completion system, autoloaded functions)

The convention for autoloaded functions used in completion is that they
start with an underscore; as already mentioned, the tt(fpath/FPATH)
parameter must contain the directory in which they are stored.  If tt(zsh)
was properly installed on your system, then tt(fpath/FPATH) automatically
contains the required directories for the standard functions.

For incomplete installations, if tt(compinit) does not find enough files
beginning with an underscore (fewer than twenty) in the search path, it
will try to find more by adding the directory tt(_compdir) to the search
path.  If that directory has a subdirectory named tt(Base), all
subdirectories will be added to the path.  Furthermore, if the subdirectory
tt(Base) has a subdirectory named tt(Core), tt(compinit) will add all
subdirectories of the subdirectories to the path: this allows
the functions to be in the same format as in the tt(zsh) source
distribution.

cindex(compdef, use of by compinit)
When tt(compinit) is run, it searches all such files accessible via
tt(fpath/FPATH) and reads the first line of each of them.  This line should
contain one of the tags described below.  Files whose first line does not
start with one of these tags are not considered to be part of the
completion system and will not be treated specially.

The tags are:

startitem()
item(tt(#compdef) var(name) ... [ tt(-){tt(p)|tt(P)} var(pattern) ... [ tt(-N) var(name) ... ] ])(
The file will be made autoloadable and the function defined 
in it will be called when completing var(name)s, each of which is
either the name of a command whose arguments are to be completed or one of
a number of special contexts in the form tt(-)var(context)tt(-) described
below.

Each var(name) may also be of the form `var(cmd)tt(=)var(service)'.
When completing the command var(cmd), the function typically behaves as
if the command (or special context) var(service) was being completed
instead.  This provides a way of altering the behaviour of functions
that can perform many different completions.  It is implemented
by setting the parameter tt($service) when calling the function;
the function may choose to interpret this how it wishes, and simpler
functions will probably ignore it.

If the tt(#compdef) line contains one of the options tt(-p) or tt(-P),
the words following are taken to be patterns.  The function will be
called when completion is attempted for a command or context that matches
one of the patterns.  The options tt(-p) and tt(-P) are used to specify
patterns to be tried before or after other completions respectively.
Hence tt(-P) may be used to specify default actions.

The option tt(-N) is used after a list following tt(-p) or tt(-P); it
specifies that remaining words no longer define patterns.  It is
possible to toggle between the three options as many times as necessary.
)
item(tt(#compdef -k) var(style key-sequence) ...)(
This option creates a widget behaving like the
builtin widget var(style) and binds it to the given var(key-sequence)s,
if any.  The var(style) must be one of the builtin widgets that perform
completion, namely tt(complete-word), tt(delete-char-or-list),
tt(expand-or-complete), tt(expand-or-complete-prefix), tt(list-choices),
tt(menu-complete), tt(menu-expand-or-complete), or
tt(reverse-menu-complete).  If the tt(zsh/complist) module is loaded (see
ifzman(zmanref(zshmodules))\
ifnzman(noderef(The zsh/complist Module))\
) the widget tt(menu-select) is also available.

When one of the var(key-sequence)s is typed, the function in the file will
be invoked to generate the matches.  Note that a key will not be re-bound
if it already was (that is, was bound to something other than
tt(undefined-key)).  The widget created has the same name as the file and
can be bound to any other keys using tt(bindkey) as usual.
)
item(tt(#compdef -K) var(widget-name) var(style) var(key-sequence) [ var(name) var(style) var(seq) ... ])(
This is similar to tt(-k) except that only one var(key-sequence)
argument may be given for each var(widget-name) var(style) pair.
However, the entire set of three arguments may be repeated with a
different set of arguments.  Note in particular that the
var(widget-name) must be distinct in each set.  If it does not begin with
`tt(_)' this will be added.  The var(widget-name) should not clash with
the name of any existing widget: names based on the name of the function
are most useful.  For example,

example(#compdef -K _foo_complete complete-word "^X^C" \ 
  _foo_list list-choices "^X^D")

(all on one line) defines a widget tt(_foo_complete) for completion, bound
to `tt(^X^C)', and a widget tt(_foo_list) for listing, bound to `tt(^X^D)'.
)
item(tt(#autoload) [ var(options) ])(
Functions with the tt(#autoload) tag are marked for autoloading but
are not otherwise treated specially.  Typically they are to be called
from within one of the completion functions.  Any var(options) supplied
will be passed to the tt(autoload) builtin; a typical use is tt(+X) to
force the function to be loaded immediately.  Note that the tt(-U) and
tt(-z) flags are always added implicitly.
)
enditem()

The tt(#) is part of the tag name and no white space is allowed after it.
The tt(#compdef) tags use the tt(compdef) function described below; the
main difference is that the name of the function is supplied implicitly.

The special contexts for which completion functions can be defined are:

startitem()
kindex(-array-value-, completion context)
item(tt(-array-value-))(
The right hand side of an array-assignment
(`var(name)tt(=LPAR())var(...)tt(RPAR())')
)
kindex(-assign-parameter-, completion context)
item(tt(-assign-parameter-))(
The name of a parameter in an assignment, i.e. on the left hand side of
an `tt(=)'
)
kindex(-brace-parameter-, completion context)
item(tt(-brace-parameter-))(
The name of a parameter expansion within braces (`tt(${)var(...)tt(})')
)
kindex(-command-, completion context)
item(tt(-command-))(
A word in command position
)
kindex(-condition-, completion context)
item(tt(-condition-))(
A word inside a condition (`tt([[)var(...)tt(]])')
)
kindex(-default-, completion context)
item(tt(-default-))(
Any word for which no other completion is defined
)
kindex(-equal-, completion context)
item(tt(-equal-))(
A word beginning with an equals sign
)
kindex(-first-, completion context)
item(tt(-first-))(
This is tried before any other completion function.  The function called
may set the tt(_compskip) parameter to one of various values: 
tt(all): no further completion is attempted; a string
containing the substring tt(patterns): no pattern completion functions
will be called; a string containing tt(default): the
function for the `tt(-default-)' context will not be called, but
functions defined for commands will be.
)
kindex(-math-, completion context)
item(tt(-math-))(
Inside mathematical contexts, such as
`tt(LPAR()LPAR())var(...)tt(RPAR()RPAR())'
)
kindex(-parameter-, completion context)
item(tt(-parameter-))(
The name of a parameter expansion (`tt($)var(...)')
)
kindex(-redirect-, completion context)
item(tt(-redirect-))(
The word after a redirection operator.
)
kindex(-subscript-, completion context)
item(tt(-subscript-))(
The contents of a parameter subscript.
)
kindex(-tilde-, completion context)
item(tt(-tilde-))(
After an initial tilde (`tt(~)'), but before the first slash
in the word.
)
kindex(-value-, completion context)
item(tt(-value-))(
On the right hand side of an assignment.
)
enditem()

Default implementations are supplied for each of these
contexts.  In most cases the context tt(-)var(context)tt(-) is
implemented by a corresponding function tt(_)var(context), for example
the context `tt(-tilde-)' and the function `tt(_tilde)').

The contexts tt(-redirect-) and tt(-value-) allow extra context-specific
information.  (Internally, this is handled by the functions for each
context calling the function tt(_dispatch).)  The extra
information is added separated by commas.

For the tt(-redirect-) context, the extra information is in the form
`tt(-redirect-,)var(op)tt(,)var(command)', where var(op) is the
redirection operator and var(command) is the name of the command on
the line.  If there is no command on the line yet, the var(command)
field will be empty.

For the tt(-value-) context, the form is
`tt(-value-,)var(name)tt(,)var(command)', where var(name) is the name of
the parameter on the left hand side of the assignment.
In the case of elements of an associative array, for
example `tt(assoc=LPAR()key <TAB>)', var(name) is expanded to
`var(name)tt(-)var(key)'.  In certain special contexts, such as
completing after `tt(make CFLAGS=)', the var(command) part gives the
name of the command, here tt(make); otherwise it is empty.

It is not necessary to define fully specific completions as the
functions provided will try to generate completions by progressively
replacing the elements with `tt(-default-)'.  For example, when
completing after `tt(foo=<TAB>)', tt(_value) will try the names
`tt(-value-,foo,)' (note the empty var(command) part),
`tt(-value-,foo,-default-)' and`tt(-value-,-default-,-default-)', in
that order, until it finds a function to handle the context.

As an example:

example(compdef '_files -g "*.log"' '-redirect-,2>,-default-')

completes files matching `tt(*.log)' after `tt(2> <TAB>)' for any
command with no more specific handler defined.

Also:

example(compdef _foo -value-,-default-,-default-)

specifies that tt(_foo) provides completions for the values of
parameters for which no special function has been defined.  This is
usually handled by the function tt(_value) itself.

The same lookup rules are used when looking up styles (as described
below); for example

example(zstyle ':completion:*:*:-redirect-,2>,*:*' file-patterns '*.log')

is another way to make completion after `tt(2> <TAB>)' complete files
matching `tt(*.log)'.

subsect(Functions)

The following function is defined by tt(compinit) and may be called
directly.

findex(compdef)
cindex(completion system, adding definitions)
startitem()
redef(SPACES)(0)(tt(ifztexi(NOTRANS(@ @ @ @ @ @ ))ifnztexi(      )))
xitem(tt(compdef) [ tt(-ane) ] var(function name) ... [ tt(-){tt(p)|tt(P)} var(pattern) ... [ tt(-N) var(name) ...]])
xitem(tt(compdef -d) var(name) ...)
xitem(tt(compdef -k) [ tt(-an) ] var(function style key-sequence) [ var(key-sequence) ... ])
item(tt(compdef -K) [ tt(-an) ] var(function name style key-seq) [ var(name style seq) ... ])(
The first form defines the var(function) to call for completion in the
given contexts as described for the tt(#compdef) tag above.

Alternatively, all the arguments may have the form
`var(cmd)tt(=)var(service)'.  Here var(service) should already have been
defined by `var(cmd1)tt(=)var(service)' lines in tt(#compdef) files, as
described above.  The argument for var(cmd) will be completed in the
same way as var(service).

The var(function) argument may alternatively be a string containing
almost any shell code.  If the string contains an equal sign, the above
will take precedence.  The option tt(-e) may be used to specify the first
argument is to be evaluated as shell code even if it contains an equal
sign.  The string will be executed using the tt(eval) builtin command to
generate completions.  This provides a way of avoiding having to define
a new completion function.  For example, to complete files ending in
`tt(.h)' as arguments to the command tt(foo):

example(compdef '_files -g "*.h"' foo)

The option tt(-n) prevents any completions already defined for the
command or context from being overwritten.

The option tt(-d) deletes any completion defined for the command or
contexts listed.

The var(name)s may also contain tt(-p), tt(-P) and tt(-N) options as
described for the tt(#compdef) tag.  The effect on the argument list is
identical, switching between definitions of patterns tried initially,
patterns tried finally, and normal commands and contexts.

The parameter tt($_compskip) may be set by any function defined for a
pattern context.  If it is set to a value containing the substring
`tt(patterns)' none of the pattern-functions will be called; if it is
set to a value containing the substring `tt(all)', no other function
will be called.  Setting tt($_compskip) in this manner is of particular
utility when using the tt(-p) option, as otherwise the dispatcher will
move on to additional functions (likely the default one) after calling
the pattern-context one, which can mangle the display of completion
possibilities if not handled properly.

The form with tt(-k) defines a widget with the same name as the var(function)
that will be called for each of the var(key-sequence)s; this is like the
tt(#compdef -k) tag.  The function should generate the completions needed
and will otherwise behave like the builtin widget whose name is given as
the var(style) argument.  The widgets usable for this are:
tt(complete-word), tt(delete-char-or-list), tt(expand-or-complete),
tt(expand-or-complete-prefix), tt(list-choices), tt(menu-complete),
tt(menu-expand-or-complete), and tt(reverse-menu-complete), as well as
tt(menu-select) if the tt(zsh/complist) module is loaded.  The option tt(-n)
prevents the key being bound if it is already to bound to something other
than tt(undefined-key).

The form with tt(-K) is similar and defines multiple widgets based on the
same var(function), each of which requires the set of three arguments
var(name), var(style) and var(key-seq)uence, where the latter two are as
for tt(-k) and the first must be a unique widget name beginning with an
underscore.

Wherever applicable, the tt(-a) option makes the var(function)
autoloadable, equivalent to tt(autoload -U )var(function).
)
enditem()

The function tt(compdef) can be used to associate existing completion
functions with new commands.  For example,

example(compdef _pids foo)

uses the function tt(_pids) to complete process IDs for the command tt(foo).

Note also the tt(_gnu_generic) function described below, which can be
used to complete options for commands that understand the
`tt(-)tt(-help)' option.

texinode(Completion System Configuration)(Control Functions)(Initialization)(Completion System)
sect(Completion System Configuration)
cindex(completion system, configuration)

This section gives a short overview of how the completion system works,
and then more detail on how users can configure how and when matches are
generated.

subsect(Overview)

When completion is attempted somewhere on the command line the
completion system begins building the context.  The context represents
everything that the shell knows about the meaning of the command line
and the significance of the cursor position.  This takes account of a
number of things including the command word (such as `tt(grep)' or
`tt(zsh)') and options to which the current word may be an argument
(such as the `tt(-o)' option to tt(zsh) which takes a shell option as an
argument).

The context starts out very generic ("we are beginning a completion")
and becomes more specific as more is learned ("the current word is in a
position that is usually a command name" or "the current word might be a
variable name" and so on).  Therefore the context will vary during the
same call to the completion system.

This context information is condensed into a string consisting of multiple
fields separated by colons, referred to simply as `the context' in the
remainder of the documentation.  Note that a user of the completion system
rarely needs to compose a context string, unless for example a new
function is being written to perform completion for a new command.  What a
user may need to do is compose a em(style) pattern, which is matched
against a context when needed to look up context-sensitive options that
configure the completion system.

The next few paragraphs explain how a context is composed within the
completion function suite.  Following that is discussion of how em(styles)
are defined.  Styles determine such things as how the matches are
generated, similarly to shell options but with much more control.  They
are defined with the tt(zstyle) builtin command (\
ifzman(see zmanref(zshmodules))\
ifnzman(noderef(The zsh/zutil Module))).

The context string always consists of a fixed set of fields, separated
by colons and with a leading colon before the first.  Fields which are
not yet known are left empty, but the surrounding colons appear anyway.
The fields are always in the order
tt(:completion:)var(function)tt(:)var(completer)tt(:)var(command)tt(:)var(argument)tt(:)var(tag).  These have the following meaning:

startitemize()
itemiz(\
The literal string tt(completion), saying that this style is used by
the completion system.  This distinguishes the context from those used
by, for example, zle widgets and ZFTP functions.
)
itemiz(\
The var(function), if completion is called from a named widget rather
than through the normal completion system.  Typically this is blank, but
it is set by special widgets such as tt(predict-on) and the various
functions in the tt(Widget) directory of the distribution to the name of
that function, often in an abbreviated form.
)
itemiz(\
The var(completer) currently active, the name of the function without the
leading underscore and with other underscores converted to hyphens.  A
`completer' is in overall control of how completion is to be performed;
`tt(complete)' is the simplest, but other completers exist to perform
related tasks such as correction, or to modify the behaviour of a later
completer.  See
ifzman(the section `Control Functions' below)\
ifnzman(noderef(Control Functions)) 
for more information.  
)
itemiz(\
The var(command) or a special tt(-)var(context)tt(-), just at it appears
following the tt(#compdef) tag or the tt(compdef) function.  Completion
functions for commands that have sub-commands usually modify this field
to contain the name of the command followed by a minus sign and the
sub-command.  For example, the completion function for the tt(cvs)
command sets this field to tt(cvs-add) when completing arguments to
the tt(add) subcommand.
)
itemiz(\
The var(argument); this indicates which command line or option argument
we are completing.  For command arguments this generally takes the form
tt(argument-)var(n), where var(n) is the number of the argument,
and for arguments to options the form tt(option-)var(opt)tt(-)var(n)
where var(n) is the number of the argument to option var(opt).  However,
this is only the case if the command line is parsed with standard
UNIX-style options and arguments, so many completions do not set this.
)
itemiz(\
The var(tag).  As described previously, tags are used to discriminate between
the types of matches a completion function can generate in a certain context.
Any completion function may use any tag name it likes, but a list of the
more common ones is given below.
)
enditemize()

The context is gradually put together as the functions are executed, starting
with the main entry point, which adds tt(:completion:) and the var(function)
element if necessary.  The completer then adds the var(completer) element.
The contextual completion adds the var(command) and var(argument) options.
Finally, the var(tag) is added when the types of completion are known.
For example, the context name

example(tt(:completion::complete:dvips:option-o-1:files))

says that normal completion was attempted as the first argument to the
option tt(-o) of the command tt(dvips):

example(tt(dvips -o ...))

and the completion function will generate filenames.

Usually completion will be tried for all possible tags in an order given
by the completion function.  However, this can be altered by using the
tt(tag-order) style.  Completion is then restricted to the list of given
tags in the given order.

The tt(_complete_help) bindable command shows all the contexts and tags
available for completion at a particular point.  This provides an easy
way of finding information for tt(tag-order) and other styles.  It is
described in
ifzman(the section `Bindable Commands' below)\
ifnzman(noderef(Bindable Commands)).

When looking up styles the completion system uses full context names,
including the tag.  Looking up the value of a style therefore consists of
two things: the context, which is matched to the most specific (best
fitting) pattern, and the name of the style itself, which must be
matched exactly.  The following examples demonstrate that patterns
may be loosely defined for styles that apply broadly, or as tightly
defined as desired for styles that apply in narrower circumstances.

For example, many completion functions can generate matches in a
simple and a verbose form and use the tt(verbose) style to decide
which form should be used.  To make all such functions use the verbose form,
put

example(zstyle ':completion:*' verbose yes)

in a startup file (probably tt(.zshrc)).
This gives the tt(verbose) style the value tt(yes) in every
context inside the completion system, unless that context has a more
specific definition.  It is best to avoid giving the pattern as `tt(*)'
in case the style has some meaning outside the completion system.

Many such general purpose styles can be configured simply by using the
tt(compinstall) function.

A more specific example of the use of the tt(verbose) style is by the
completion for the tt(kill) builtin.  If the style is set, the builtin
lists full job texts and process command lines; otherwise it shows the
bare job numbers and PIDs.  To turn the style off for this use only:

example(zstyle ':completion:*:*:kill:*:*' verbose no)

For even more control, the style can use one of the tags `tt(jobs)' or
`tt(processes)'.  To turn off verbose display only for jobs:

example(zstyle ':completion:*:*:kill:*:jobs' verbose no)

The tt(-e) option to tt(zstyle) even allows completion function code to
appear as the argument to a style; this requires some understanding of
the internals of completion functions (see
ifzman(see zmanref(zshcompwid))\
ifnzman(noderef(Completion Widgets)))\
).  For example,

example(tt(zstyle -e ':completion:*' hosts 'reply=($myhosts)'))

This forces the value of the tt(hosts) style to be read from the
variable tt(myhosts) each time a host name is needed; this is useful
if the value of tt(myhosts) can change dynamically.
For another useful example, see the example in the description of the
tt(file-list) style below.  This form can be
slow and should be avoided for commonly examined styles such
as tt(menu) and tt(list-rows-first).

Note that the order in which styles are em(defined) does not matter; the
style mechanism uses the most specific possible match for a particular
style to determine the set of values.  Strings are
preferred over patterns (for example, `tt(:completion::complete:::foo)' is
more specific than `tt(:completion::complete:::*')), and longer patterns are
preferred over the pattern `tt(*)'. See 
ifzman(zmanref(zmodules))ifnzman(noderef(The zsh/zutil Module))
for details.

Context patterns that use something other than a wildcard (tt(*)) to match the
middle parts of the context DASH()- the var(completer), var(command), and
var(argument) in
tt(:completion:)var(function)tt(:)var(completer)tt(:)var(command)tt(:)var(argument)tt(:)var(tag)
DASH()- should include all six colons (tt(:)) explicitly. Without this,
a pattern such as tt(:completion:*:foo:*) could match tt(foo) against a
component other than the intended one (for example, against var(completer) when
a match against var(command) was intended).

Style names like those of tags are arbitrary and depend on the completion
function.  However, the following two sections list some of the most
common tags and styles.

subsect(Standard Tags)
cindex(completion system, tags)

Some of the following are only used when looking up particular styles
and do not refer to a type of match.

startitem()
kindex(accounts, completion tag)
item(tt(accounts))(
used to look up the tt(users-hosts) style
)
kindex(all-expansions, completion tag)
item(tt(all-expansions))(
used by the tt(_expand) completer when adding the single string containing
all possible expansions
)
kindex(all-files, completion tag)
item(tt(all-files))(
for the names of all files (as distinct from a particular subset, see the
tt(globbed-files) tag).
)
kindex(arguments, completion tag)
item(tt(arguments))(
for arguments to a command
)
kindex(arrays, completion tag)
item(tt(arrays))(
for names of array parameters
)
kindex(association-keys, completion tag)
item(tt(association-keys))(
for keys of associative arrays; used when completing inside a
subscript to a parameter of this type
)
kindex(bookmarks, completion tag)
item(tt(bookmarks))(
when completing bookmarks (e.g. for URLs and the tt(zftp) function suite)
)
kindex(builtins, completion tag)
item(tt(builtins))(
for names of builtin commands
)
kindex(characters, completion tag)
item(tt(characters))(
for single characters in arguments of commands such as tt(stty).   Also used
when completing character classes after an opening bracket
)
kindex(colormapids, completion tag)
item(tt(colormapids))(
for X colormap ids
)
kindex(colors, completion tag)
item(tt(colors))(
for color names
)
kindex(commands, completion tag)
item(tt(commands))(
for names of external commands.  Also used by complex commands such as
tt(cvs) when completing names subcommands.
)
kindex(contexts, completion tag)
item(tt(contexts))(
for contexts in arguments to the tt(zstyle) builtin command
)
kindex(corrections, completion tag)
item(tt(corrections))(
used by the tt(_approximate) and tt(_correct) completers for possible
corrections
)
kindex(cursors, completion tag)
item(tt(cursors))(
for cursor names used by X programs
)
kindex(default, completion tag)
item(tt(default))(
used in some contexts to provide a way of supplying a default when more
specific tags are also valid.  Note that this tag is
used when only the var(function) field of the context name is set
)
kindex(descriptions, completion tag)
item(tt(descriptions))(
used when looking up the value of the tt(format) style to generate
descriptions for types of matches
)
kindex(devices, completion tag)
item(tt(devices))(
for names of device special files
)
kindex(directories, completion tag)
item(tt(directories))(
for names of directories DASH()- tt(local-directories) is used instead
when completing arguments of tt(cd) and related builtin commands when
the tt(cdpath) array is set
)
kindex(directory-stack, completion tag)
item(tt(directory-stack))(
for entries in the directory stack
)
kindex(displays, completion tag)
item(tt(displays))(
for X display names
)
kindex(domains, completion tag)
item(tt(domains))(
for network domains
)
kindex(email-*, completion tag)
item(tt(email-)var(plugin))(
for email addresses from the `tt(_email-)var(plugin)' backend of tt(_email_addresses)
)
kindex(expansions, completion tag)
item(tt(expansions))(
used by the tt(_expand) completer for individual words (as opposed to
the complete set of expansions) resulting from the expansion of a word
on the command line
)
kindex(extensions, completion tag)
item(tt(extensions))(
for X server extensions
)
kindex(file-descriptors, completion tag)
item(tt(file-descriptors))(
for numbers of open file descriptors
)
kindex(files, completion tag)
item(tt(files))(
the generic file-matching tag used by functions completing filenames
)
kindex(fonts, completion tag)
item(tt(fonts))(
for X font names
)
kindex(fstypes, completion tag)
item(tt(fstypes))(
for file system types (e.g. for the tt(mount) command)
)
kindex(functions, completion tag)
item(tt(functions))(
names of functions DASH()- normally shell functions, although certain
commands may understand other kinds of function
)
kindex(globbed-files, completion tag)
item(tt(globbed-files))(
for filenames when the name has been generated by pattern matching
)
kindex(groups, completion tag)
item(tt(groups))(
for names of user groups
)
kindex(history-words, completion tag)
item(tt(history-words))(
for words from the history
)
kindex(hosts, completion tag)
item(tt(hosts))(
for hostnames
)
kindex(indexes, completion tag)
item(tt(indexes))(
for array indexes
)
kindex(interfaces, completion tag)
item(tt(interfaces))(
for network interfaces
)
kindex(jobs, completion tag)
item(tt(jobs))(
for jobs (as listed by the `tt(jobs)' builtin)
)
kindex(keymaps, completion tag)
item(tt(keymaps))(
for names of zsh keymaps
)
kindex(keysyms, completion tag)
item(tt(keysyms))(
for names of X keysyms
)
kindex(libraries, completion tag)
item(tt(libraries))(
for names of system libraries
)
kindex(limits, completion tag)
item(tt(limits))(
for system limits
)
kindex(local-directories, completion tag)
item(tt(local-directories))(
for names of directories that are subdirectories of the current working
directory when completing arguments of tt(cd) and related builtin
commands (compare tt(path-directories)) DASH()- when the tt(cdpath)
array is unset, tt(directories) is used instead
)
kindex(mailboxes, completion tag)
item(tt(mailboxes))(
for e-mail folders
)
kindex(manuals, completion tag)
item(tt(manuals))(
for names of manual pages
)
kindex(maps, completion tag)
item(tt(maps))(
for map names (e.g. NIS maps)
)
kindex(messages, completion tag)
item(tt(messages))(
used to look up the tt(format) style for messages
)
kindex(modifiers, completion tag)
item(tt(modifiers))(
for names of X modifiers
)
kindex(modules, completion tag)
item(tt(modules))(
for modules (e.g. tt(zsh) modules)
)
kindex(my-accounts, completion tag)
item(tt(my-accounts))(
used to look up the tt(users-hosts) style
)
kindex(named-directories, completion tag)
item(tt(named-directories))(
for named directories (you wouldn't have guessed that, would you?)
)
kindex(names, completion tag)
item(tt(names))(
for all kinds of names
)
kindex(newsgroups, completion tag)
item(tt(newsgroups))(
for USENET groups
)
kindex(nicknames, completion tag)
item(tt(nicknames))(
for nicknames of NIS maps
)
kindex(options, completion tag)
item(tt(options))(
for command options
)
kindex(original, completion tag)
item(tt(original))(
used by the tt(_approximate), tt(_correct) and tt(_expand) completers when
offering the original string as a match
)
kindex(other-accounts, completion tag)
item(tt(other-accounts))(
used to look up the tt(users-hosts) style
)
kindex(packages, completion tag)
item(tt(packages))(
for packages (e.g. tt(rpm) or installed tt(Debian) packages)
)
kindex(parameters, completion tag)
item(tt(parameters))(
for names of parameters
)
kindex(path-directories, completion tag)
item(tt(path-directories))(
for names of directories found by searching the tt(cdpath) array when
completing arguments of tt(cd) and related builtin commands (compare
tt(local-directories))
)
kindex(paths, completion tag)
item(tt(paths))(
used to look up the values of the tt(expand), tt(ambiguous) and
tt(special-dirs) styles
)
kindex(pods, completion tag)
item(tt(pods))(
for perl pods (documentation files)
)
kindex(ports, completion tag)
item(tt(ports))(
for communication ports
)
kindex(prefixes, completion tag)
item(tt(prefixes))(
for prefixes (like those of a URL)
)
kindex(printers, completion tag)
item(tt(printers))(
for print queue names
)
kindex(processes, completion tag)
item(tt(processes))(
for process identifiers
)
kindex(processes-names, completion tag)
item(tt(processes-names))(
used to look up the tt(command) style when generating the names of
processes for tt(killall)
)
kindex(sequences, completion tag)
item(tt(sequences))(
for sequences (e.g. tt(mh) sequences)
)
kindex(sessions, completion tag)
item(tt(sessions))(
for sessions in the tt(zftp) function suite
)
kindex(signals, completion tag)
item(tt(signals))(
for signal names
)
kindex(strings, completion tag)
item(tt(strings))(
for strings (e.g. the replacement strings for the tt(cd) builtin
command)
)
kindex(styles, completion tag)
item(tt(styles))(
for styles used by the zstyle builtin command
)
kindex(suffixes, completion tag)
item(tt(suffixes))(
for filename extensions
)
kindex(tags, completion tag)
item(tt(tags))(
for tags (e.g. tt(rpm) tags)
)
kindex(targets, completion tag)
item(tt(targets))(
for makefile targets
)
kindex(time-zones, completion tag)
item(tt(time-zones))(
for time zones (e.g. when setting the tt(TZ) parameter)
)
kindex(types, completion tag)
item(tt(types))(
for types of whatever (e.g. address types for the tt(xhost) command)
)
kindex(urls, completion tag)
item(tt(urls))(
used to look up the tt(urls) and tt(local) styles when completing URLs
)
kindex(users, completion tag)
item(tt(users))(
for usernames
)
kindex(values, completion tag)
item(tt(values))(
for one of a set of values in certain lists
)
kindex(variant, completion tag)
item(tt(variant))(
used by tt(_pick_variant) to look up the command to run when determining
what program is installed for a particular command name.
)
kindex(visuals, completion tag)
item(tt(visuals))(
for X visuals
)
kindex(warnings, completion tag)
item(tt(warnings))(
used to look up the tt(format) style for warnings
)
kindex(widgets, completion tag)
item(tt(widgets))(
for zsh widget names
)
kindex(windows, completion tag)
item(tt(windows))(
for IDs of X windows
)
kindex(zsh-options, completion tag)
item(tt(zsh-options))(
for shell options
)
enditem()

subsect(Standard Styles)
cindex(completion system, styles)

Note that the values of several of these styles represent boolean
values.  Any of the strings `tt(true)', `tt(on)',
`tt(yes)', and `tt(1)' can be used for the value `true' and
any of the strings `tt(false)', `tt(off)', `tt(no)', and `tt(0)' for
the value `false'.  The behavior for any other value is undefined 
except where explicitly mentioned.  The default value may
be either `true' or `false' if the style is not set.

Some of these styles are tested first for every possible tag
corresponding to a type of match, and if no style was found, for the
tt(default) tag.  The most notable styles of this type are tt(menu), 
tt(list-colors) and styles controlling completion listing such as 
tt(list-packed) and tt(last-prompt).  When tested for the tt(default)
tag, only the var(function) field of the context will be set so that
a style using the tt(default) tag will normally be defined along the lines of:

example(zstyle ':completion:*:default' menu ...)

startitem()
kindex(accept-exact, completion style)
item(tt(accept-exact))(
This is tested for the tt(default) tag in addition to the tags valid for
the current context.  If it is set to `true' and any of the trial
matches is the same as the string on the command line, this match will
immediately be accepted (even if it would otherwise be considered
ambiguous).

When completing pathnames (where the tag used is `tt(paths)')
this style accepts any number of patterns as the value in addition to
the boolean values.  Pathnames matching one of these
patterns will be accepted immediately even if the command line contains
some more partially typed pathname components and these match no file
under the directory accepted.

This style is also used by the tt(_expand) completer to decide if
words beginning with a tilde or parameter expansion should be
expanded.  For example, if there are parameters
tt(foo) and tt(foobar), the string `tt($foo)' will only be expanded if 
tt(accept-exact) is set to `true'; otherwise the completion system will
be allowed to complete tt($foo) to tt($foobar). If the style is set to
`tt(continue)', tt(_expand) will add the expansion as a match and the completion
system will also be allowed to continue.
)
kindex(accept-exact-dirs, completion style)
item(tt(accept-exact-dirs))(
This is used by filename completion.  Unlike tt(accept-exact) it is
a boolean.  By default, filename completion examines all components
of a path to see if there are completions of that component, even if
the component matches an existing directory.  For example, when
completion after tt(/usr/bin/), the function examines possible
completions to tt(/usr).

When this style is `true', any prefix of a path that matches an existing
directory is accepted without any attempt to complete it further.
Hence, in the given example, the path tt(/usr/bin/) is accepted
immediately and completion tried in that directory.

This style is also useful when completing after directories that
magically appear when referenced, such as ZFS tt(.zfs) directories
or NetApp tt(.snapshot) directories.  When the style is set the
shell does not check for the existence of the directory within the
parent directory.

If you wish to inhibit this behaviour entirely, set the tt(path-completion)
style (see below) to `false'.
)
kindex(add-space, completion style)
item(tt(add-space))(
This style is used by the tt(_expand) completer.  If it is `true' (the
default), a space will be inserted after all words resulting from the 
expansion, or a slash in the case of directory names.  If the value
is `tt(file)', the completer will only add a space
to names of existing files.  Either a boolean `true' or the value
`tt(file)' may be combined with `tt(subst)', in which case the completer
will not add a space to words generated from the expansion of a
substitution of the form `tt($LPAR())var(...)tt(RPAR())' or `tt(${)var(...)tt(})'.

The tt(_prefix) completer uses this style as a simple boolean value
to decide if a space should be inserted before the suffix.
)
kindex(ambiguous, completion style)
item(tt(ambiguous))(
This applies when completing non-final components of filename paths, in
other words those with a trailing slash.  If it is set, the cursor is
left after the first ambiguous component, even if menu completion is in
use.  The style is always tested with the tt(paths) tag.
)
kindex(assign-list, completion style)
item(tt(assign-list))(
When completing after an equals sign that is being treated as an
assignment, the completion system normally completes only one filename.
In some cases the value  may be a list of filenames separated by colons,
as with tt(PATH) and similar parameters.  This style can be set to a
list of patterns matching the names of such parameters.

The default is to complete lists when the word on the line already
contains a colon.
)
kindex(auto-description, completion style)
item(tt(auto-description))(
If set, this style's value will be used as the description for options that
are not described by the completion functions, but that have exactly
one argument.  The sequence `tt(%d)' in the value will be replaced by
the description for this argument.  Depending on personal preferences,
it may be useful to set this style to something like `tt(specify: %d)'. 
Note that this may not work for some commands.
)
kindex(avoid-completer, completion style)
item(tt(avoid-completer))(
This is used by the tt(_all_matches) completer to decide if the string 
consisting of all matches should be added to the list currently being
generated.  Its value is a list of names of completers.  If any of
these is the name of the completer that generated the matches in this
completion, the string will not be added.

The default value for this style is `tt(_expand _old_list _correct
_approximate)', i.e. it contains the completers for which a string
with all matches will almost never be wanted.
)
kindex(cache-path, completion style)
item(tt(cache-path))(
This style defines the path where any cache files containing dumped
completion data are stored.  It defaults to `tt($ZDOTDIR/.zcompcache)', or
`tt($HOME/.zcompcache)' if tt($ZDOTDIR) is not defined.  The completion
cache will not be used unless the tt(use-cache) style is set.
)
kindex(cache-policy, completion style)
item(tt(cache-policy))(
This style defines the function that will be used to determine whether
a cache needs rebuilding.  See the section on the tt(_cache_invalid)
function below.
)
kindex(call-command, completion style)
item(tt(call-command))(
This style is used in the function for commands such as tt(make) and
tt(ant) where calling the command directly to generate matches suffers
problems such as being slow or, as in the case of tt(make) can
potentially cause actions in the makefile to be executed. If it is set
to `true' the command is called to generate matches. The default value
of this style is `false'.
)
kindex(command, completion style)
item(tt(command))(
In many places, completion functions need to call external commands to
generate the list of completions.  This style can be used to override the
command that is called in some such cases.  The elements of the value are
joined with spaces to form a command line to execute.  The value can also
start with a hyphen, in which case the usual command will be added to the
end; this is most useful for putting `tt(builtin)' or `tt(command)' in
front to make sure the appropriate version of a command is called, for
example to avoid calling a shell function with the same name as an external
command.

As an example, the completion function for process IDs uses this
style with the tt(processes) tag to generate the IDs to complete and
the list of processes to display (if the tt(verbose) style is `true').
The list produced by the command should look like the output of the
tt(ps) command.  The first line is not displayed, but is searched for
the string `tt(PID)' (or `tt(pid)') to find the position of the
process IDs in the following lines.  If the line does not contain
`tt(PID)', the first numbers in each of the other lines are taken as the 
process IDs to complete.

Note that the completion function generally has to call the specified
command for each attempt to generate the completion list.  Hence
care should be taken to specify only commands that take a short
time to run, and in particular to avoid any that may never terminate.
)
kindex(command-path, completion style)
item(tt(command-path))(
This is a list of directories to search for commands to complete.  The
default for this style is the value of the special parameter tt(path).
)
kindex(commands, completion style)
item(tt(commands))(
This is used by the function completing sub-commands for the system
initialisation scripts (residing in tt(/etc/init.d) or somewhere not
too far away from that).  Its values give the default commands to
complete for those commands for which the completion function isn't
able to find them out automatically.  The default for this style are
the two strings `tt(start)' and `tt(stop)'.
)
kindex(complete, completion style)
item(tt(complete))(
This is used by the tt(_expand_alias) function when invoked as a
bindable command.  If set to `true' and the word on the command
line is not the name of an alias, matching alias names will be
completed.
)
kindex(complete-options, completion style)
item(tt(complete-options))(
This is used by the completer for tt(cd), tt(chdir) and tt(pushd).
For these commands a tt(-) is used to introduce a directory stack entry
and completion of these is far more common than completing options.
Hence unless the value of this style is `true' options will not be
completed, even after an initial tt(-).  If it is `true', options will
be completed after an initial tt(-) unless there is a preceding
tt(-)tt(-) on the command line.
)
kindex(completer, completion style)
item(tt(completer))(
The strings given as the value of this style provide the names of the
completer functions to use. The available completer functions are
described in
ifzman(the section `Control Functions' below)\
ifnzman(noderef(Control Functions))\
.

Each string may be either the name of a completer function or a string
of the form `var(function)tt(:)var(name)'.  In the first case the
var(completer) field of the context will contain the name of the
completer without the leading underscore and with all other
underscores replaced by hyphens.  In the second case the
var(function) is the name of the completer to call, but the context
will contain the user-defined var(name) in the var(completer) field of
the context.  If the var(name) starts with a hyphen, the string for the
context will be build from the name of the completer function as in
the first case with the var(name) appended to it.  For example: 

example(zstyle ':completion:*' completer _complete _complete:-foo)

Here, completion will call the tt(_complete) completer twice, once
using `tt(complete)' and once using `tt(complete-foo)' in the
var(completer) field of the context.  Normally, using the same
completer more than once only makes sense when used with the
`var(functions)tt(:)var(name)' form, because otherwise the context
name will be the same in all calls to the completer; possible
exceptions to this rule are the tt(_ignored) and tt(_prefix)
completers.

The default value for this style is `tt(_complete _ignored)':
only completion will be done, first using the tt(ignored-patterns) style
and the tt($fignore) array and then without ignoring matches.
)
kindex(condition, completion style)
item(tt(condition))(
This style is used by the tt(_list) completer function to decide if
insertion of matches should be delayed unconditionally. The default is 
`true'.
)
kindex(delimiters, completion style)
item(tt(delimiters))(
This style is used when adding a delimiter for use with history
modifiers or glob qualifiers that have delimited arguments.  It is
an array of preferred delimiters to add.  Non-special characters are
preferred as the completion system may otherwise become confused.
The default list is tt(:), tt(+), tt(/), tt(-), tt(%).  The list
may be empty to force a delimiter to be typed.
)
kindex(disabled, completion style)
item(tt(disabled))(
If this is set to `true', the tt(_expand_alias) completer and bindable 
command will try to expand disabled aliases, too.  The default is
`false'.
)
kindex(domains, completion style)
item(tt(domains))(
A list of names of network domains for completion.
If this is not set, domain names will be taken from
the file tt(/etc/resolv.conf).
)
kindex(environ, completion style)
item(tt(environ))(
The environ style is used when completing for `tt(sudo)'.  It is set to an
array of `var(VAR)tt(=)var(value)' assignments to be exported into the
local environment before the completion for the target command is invoked.
example(zstyle ':completion:*:sudo::' environ \ 
  PATH="/sbin:/usr/sbin:$PATH" HOME="/root")
)
kindex(expand, completion style)
item(tt(expand))(
This style is used when completing strings consisting of multiple
parts, such as path names.

If one of its values is the string `tt(prefix)', the partially typed
word from the line will be expanded as far as possible even if trailing
parts cannot be completed.

If one of its values is the string `tt(suffix)', matching names for
components after the first ambiguous one will also be added.  This means
that the resulting string is the longest unambiguous string possible.
However, menu completion can be used to cycle through all matches.
)
kindex(extra-verbose, completion style)
item(tt(extra-verbose))(
If set, the completion listing is more verbose at the cost of
a probable decrease in completion speed.  Completion performance
will suffer if this style is set to `true'.
)
kindex(fake, completion style)
item(tt(fake))(
This style may be set for any completion context.  It
specifies additional strings that will always be completed in that
context.  The form of each string is `var(value)tt(:)var(description)'; 
the colon and description may be omitted, but any literal colons in
var(value) must be quoted with a backslash.  Any var(description)
provided is shown alongside the value in completion listings.

It is important to use a sufficiently restrictive context when specifying
fake strings.  Note that the styles tt(fake-files) and tt(fake-parameters)
provide additional features when completing files or parameters.
)
kindex(fake-always, completion style)
item(tt(fake-always))(
This works identically to the tt(fake) style except that
the tt(ignored-patterns) style is not applied to it.  This makes it
possible to override a set of matches completely by setting the
ignored patterns to `tt(*)'.

The following shows a way of supplementing any tag with arbitrary data, but
having it behave for display purposes like a separate tag.  In this example
we use the features of the tt(tag-order) style to divide the
tt(named-directories) tag into two when performing completion with
the standard completer tt(complete) for arguments of tt(cd).  The tag
tt(named-directories-normal) behaves as normal, but the tag
tt(named-directories-mine) contains a fixed set of directories.
This has the effect of adding the match group `tt(extra directories)' with
the given completions.

example(zstyle ':completion::complete:cd:*' tag-order \ 
  'named-directories:-mine:extra\ directories
  named-directories:-normal:named\ directories *'
zstyle ':completion::complete:cd:*:named-directories-mine' \ 
  fake-always mydir1 mydir2
zstyle ':completion::complete:cd:*:named-directories-mine' \ 
  ignored-patterns '*')
)
kindex(fake-files, completion style)
item(tt(fake-files))(
This style is used when completing files and looked up 
without a tag.  Its values are of the form
`var(dir)tt(:)var(names...)'.  This will add the var(names) (strings
separated by spaces) as
possible matches when completing in the directory var(dir), even if no 
such files really exist.  The dir may be a pattern; pattern characters
or colons in var(dir) should be quoted with a backslash to be treated
literally.

This can be useful on systems that support special file systems whose
top-level pathnames can not be listed or generated with glob patterns
(but see tt(accept-exact-dirs) for a more general way of dealing
with this problem).  It can also be used for directories for which one
does not have read permission.

The pattern form can be used to add a certain `magic' entry
to all directories on a particular file system.
)
kindex(fake-parameters, completion style)
item(tt(fake-parameters))(
This is used by the completion function for parameter names.
Its values are names of parameters that might not yet be
set but should be completed nonetheless.  Each name may also be 
followed by a colon and a string specifying the type of the parameter
(like `tt(scalar)', `tt(array)' or `tt(integer)').  If the type is
given, the name will only be completed if parameters of that type are
required in the particular context.  Names for which no type is
specified will always be completed.
)
kindex(file-list, completion style)
item(tt(file-list))(
This style controls whether files completed using the standard builtin
mechanism are to be listed with a long list similar to tt(ls -l).
Note that this feature uses the shell module
tt(zsh/stat) for file information; this loads the builtin tt(stat)
which will replace any external tt(stat) executable.  To avoid
this the following code can be included in an initialization file:

example(zmodload -i zsh/stat
disable stat)

The style may either be set to a `true' value (or `tt(all)'), or
one of the values `tt(insert)' or `tt(list)', indicating that files
are to be listed in long format in all circumstances, or when
attempting to insert a file name, or when listing file names
without attempting to insert one.

More generally, the value may be an array of any of the above values,
optionally followed by tt(=)var(num).  If var(num) is present it
gives the maximum number of matches for which long listing style
will be used.  For example,

example(zstyle ':completion:*' file-list list=20 insert=10)

specifies that long format will be used when listing up to 20 files
or inserting a file with up to 10 matches (assuming a listing
is to be shown at all, for example on an ambiguous completion), else short
format will be used.

example(zstyle -e ':completion:*' file-list \ 
       '(( ${+NUMERIC} )) && reply=(true)')

specifies that long format will be used any time a numeric argument is
supplied, else short format.
)
kindex(file-patterns, completion style)
item(tt(file-patterns))(
This is used by the standard function for completing filenames,
tt(_files).  If the style is unset up to three tags are offered,
`tt(globbed-files)',`tt(directories)' and `tt(all-files)', depending on
the types of files  expected by the caller of tt(_files).  The first two
(`tt(globbed-files)' and `tt(directories)') are normally offered
together to make it easier to complete files in sub-directories.

The tt(file-patterns) style provides alternatives to the default tags,
which are not used.  Its value consists of elements of the form
`var(pattern)tt(:)var(tag)'; each string may contain any number of
such specifications separated by spaces.

The var(pattern) is a pattern that is to be used to generate filenames.
Any occurrence of the sequence `tt(%p)' is replaced by any
pattern+LPAR()s+RPAR()
passed by the function calling tt(_files).  Colons in the pattern must
be preceded by a backslash to make them distinguishable from the colon
before the var(tag).  If more than one pattern is needed, the patterns
can be given inside braces, separated by commas.

The var(tag)s of all strings in the value will be offered by tt(_files)
and used when looking up other styles.  Any var(tag)s in the same
word will be offered at the same time and before later words.
If no `tt(:)var(tag)' is given the `tt(files)' tag will be used.

The var(tag) may also be followed by an optional second colon and a
description, which will be used for the `tt(%d)' in the value of
the tt(format) style (if that is set) instead of the default
description supplied by the completion function.  The inclusion
of a description also gives precedence to associated options such as
for completion grouping so it can be used where files should be
separated.

For example, to make the tt(rm) command first complete only names of
object files and then the names of all files if there is no matching
object file:

example(zstyle ':completion:*:*:rm:*:*' file-patterns \ 
    '*.o:object-files' '%p:all-files')

To alter the default behaviour of file completion DASH()- offer files
matching a pattern and directories on the first attempt, then all files
DASH()- to offer only matching files on the first attempt, then directories,
and finally all files:

example(zstyle ':completion:*' file-patterns \ 
    '%p:globbed-files' '*(-/):directories' '*:all-files')

This works even where there is no special pattern: tt(_files) matches
all files using the pattern `tt(*)' at the first step and stops when it
sees this pattern.  Note also it will never try a pattern more than once
for a single completion attempt.

To separate directories into a separate group from the files but still
complete them at the first attempt, a description needs to be given.
Note that directories need to be explicitly excluded from the
globbed-files because `tt(*)' will match directories. For grouping, it
is also necessary to set the tt(group-name) style.

example(zstyle ':completion:*' file-patterns \ 
    '%p+LPAR()^-/RPAR():globbed-files *(-/):directories:location')

During the execution of completion functions, the tt(EXTENDED_GLOB)
option is in effect, so the characters `tt(#)', `tt(~)' and `tt(^)' have
special meanings in the patterns.
)
kindex(file-sort, completion style)
item(tt(file-sort))(
The standard filename completion function uses this style without a tag
to determine in which order the names should be listed; menu completion
will cycle through them in the same order.  The possible
values are: `tt(size)' to sort by the size of the file;
`tt(links)' to sort by the number of links to the file;
`tt(modification)' (or `tt(time)' or `tt(date)') to sort by the last
modification time; `tt(access)' to sort by the last access time; and
`tt(inode)' (or `tt(change)') to sort by the last inode change
time.  If the style is set to any other value, or is unset, files will be
sorted alphabetically by name.  If the value contains the string
`tt(reverse)', sorting is done in the opposite order.  If the value
contains the string `tt(follow)', timestamps are associated with the
targets of symbolic links; the default is to use the timestamps
of the links themselves.
)
kindex(file-split-chars, completion style)
item(tt(file-split-chars))(
A set of characters that will cause em(all) file completions for
the given context to be split at the point where any of the characters
occurs.  A typical use is to set the style to tt(:); then everything
up to and including the last tt(:) in the string so far is ignored when
completing files.  As this is quite heavy-handed, it is usually
preferable to update completion functions for contexts where this
behaviour is useful.
)
kindex(filter, completion style)
item(tt(filter))(
The tt(ldap) plugin of email address completion (see tt(_email_addresses)) uses
this style to specify
the attributes to match against when filtering entries.  So for example, if
the style is set to `tt(sn)', matching is done against surnames.  Standard
LDAP filtering is used so normal completion matching is bypassed.  If this
style is not set, the LDAP plugin is skipped.  You may also need to set the
tt(command) style to specify how to connect to your LDAP server.
)
kindex(force-list, completion style)
item(tt(force-list))(
This forces a list of completions to be shown at any point where listing is
done, even in cases where the list would usually be suppressed.
For example, normally the list is only shown if
there are at least two different matches.  By setting this style to
`tt(always)', the list will always be shown, even if there is only a
single match that will immediately be accepted.  The style may also
be set to a number.  In this case the list will be shown if there are
at least that many matches, even if they would all insert the same
string.

This style is tested for the default tag as well as for each tag valid
for the current completion.  Hence the listing can be forced only for
certain types of match.
)
kindex(format, completion style)
item(tt(format))(
If this is set for the tt(descriptions) tag, its value is used as a
string to display above matches in completion lists.  The sequence
`tt(%d)' in this string will be replaced with a short description of
what these matches are.  This string may also contain the output
attribute sequences understood by tt(compadd -X)
(see
ifzman(zmanref(zshcompwid))\
ifnzman(noderef(Completion Widgets))\
).

The style is tested with each tag valid for the current completion
before it is tested for the tt(descriptions) tag.  Hence different format 
strings can be defined for different types of match.

Note also that some completer functions define additional
`tt(%)'-sequences.  These are described for the completer functions that 
make use of them.

Some completion functions display messages that may be customised by
setting this style for the tt(messages) tag.  Here, the `tt(%d)' is
replaced with a message given by the completion function.

Finally, the format string is looked up with the tt(warnings) tag, 
for use when no matches could be generated at all.  In this case the
`tt(%d)' is replaced with the descriptions for the matches that were
expected separated by spaces.  The sequence `tt(%D)' is replaced with
the same descriptions separated by newlines.

It is possible to use printf-style field width specifiers with `tt(%d)'
and similar escape sequences.  This is handled by the tt(zformat)
builtin command from the tt(zsh/zutil) module, see
ifzman(zmanref(zshmodules))\
ifnzman(noderef(The zsh/zutil Module))\
.
)
kindex(gain-privileges, completion style)
item(tt(gain-privileges))(
If set to tt(true), this style enables the use of commands like tt(sudo)
or tt(doas) to gain extra privileges when retrieving information for
completion. This is only done when a command such as tt(sudo) appears on
the command-line. To force the use of, e.g. tt(sudo) or to override any
prefix that might be added due to tt(gain-privileges), the tt(command)
style can be used with a value that begins with a hyphen.
)
kindex(glob, completion style)
item(tt(glob))(
This is used by the tt(_expand) completer.  If
it is set to `true' (the default), globbing will be attempted on the
words resulting from a previous substitution (see the tt(substitute)
style) or else the original string from the line.
)
kindex(global, completion style)
item(tt(global))(
If this is set to `true' (the default), the tt(_expand_alias)
completer and bindable command will try to expand global aliases.
)
kindex(group-name, completion style)
item(tt(group-name))(
The completion system can group different types of matches, which appear
in separate lists.  This style can be used to give the names of groups
for particular tags.  For example, in command position the completion
system generates names of builtin and external commands, names of
aliases, shell functions and parameters and reserved words as possible
completions.  To have the external commands and shell functions listed
separately:

example(zstyle ':completion:*:*:-command-:*:commands' \ 
       group-name commands
zstyle ':completion:*:*:-command-:*:functions' \ 
       group-name functions)

As a consequence, any match with the same tag will be displayed in the
same group.

If the name given is the empty string the name of the tag for
the matches will be used as the name of the group.  So, to have all
different types of matches displayed separately, one can just set:

example(zstyle ':completion:*' group-name '')

All matches for which no group name is defined will be put in a group
named tt(-default-).

To display the group name in the output, see the tt(format) style (q.v.)
under the tt(descriptions) tag.
)
kindex(group-order, completion style)
item(tt(group-order))(
This style is additional to the tt(group-name) style to specify the
order for display of the groups defined by that style (compare tt(tag-order),
which determines which completions appear at all).  The groups named
are shown in the given order; any other groups
are shown in the order defined by the completion function.

For example, to have names of builtin commands, shell functions and
external commands appear in that order when completing in command
position:

example(zstyle ':completion:*:*:-command-:*:*' group-order \ 
       builtins functions commands)
)
kindex(groups, completion style)
item(tt(groups))(
A list of names of UNIX groups.  If this is not set,
group names are taken from the YP database or the file `tt(/etc/group)'.
)
kindex(hidden, completion style)
item(tt(hidden))(
If this is set to `true', matches for the given context
will not be listed, although
any description for the matches set with the tt(format) style will be
shown.  If it is set to `tt(all)', not even the description will be
displayed.

Note that the matches will still be completed; they are just not shown 
in the list.  To avoid having matches considered as possible
completions at all, the tt(tag-order) style can be modified as described
below.
)
kindex(hosts, completion style)
item(tt(hosts))(
A list of names of hosts that should be completed.  If this is not set,
hostnames are taken from the file `tt(/etc/hosts)'.
)
kindex(hosts-ports, completion style)
item(tt(hosts-ports))(
This style is used by commands that need or accept hostnames and
network ports.  The strings in the value should be of the form
`var(host)tt(:)var(port)'.  Valid ports are determined by the presence
of hostnames; multiple ports for the same host may appear.
)
kindex(ignore-line, completion style)
item(tt(ignore-line))(
This is tested for each tag valid for the current completion.  If
it is set to `true', none of the words that are already on the line
will be considered as possible completions.  If it is set to
`tt(current)', the word the cursor is on will not be considered as a
possible completion.  The value `tt(current-shown)' is similar but only
applies if the list of completions is currently shown on the screen.
Finally, if the style is set to `tt(other)', all words on the line except
for the current one will be excluded from the possible completions.

The values `tt(current)' and `tt(current-shown)' are a bit like the
opposite of the tt(accept-exact) style:  only strings with
missing characters will be completed.

Note that you almost certainly don't want to set this to `true' or
`tt(other)' for a general
context such as `tt(:completion:*)'.  This is because it would disallow
completion of, for example, options multiple times even if the command
in question accepts the option more than once.
)
kindex(ignore-parents, completion style)
item(tt(ignore-parents))(
The style is tested without a tag by the function completing pathnames
in order to determine whether to ignore
the names of directories already mentioned in the current word, or the
name of the current working directory.  The value must include one or both
of the following strings:

startitem()
item(tt(parent))(
The name of any directory whose path is already contained in the word on
the line is ignored.  For example, when completing after tt(foo/../), the
directory tt(foo) will not be considered a valid completion.
)
item(tt(pwd))(
The name of the current working directory will not be completed; hence,
for example, completion after tt(../) will not use the name of the current
directory.
)
enditem()

In addition, the value may include one or both of:

startitem()
item(tt(..))(
Ignore the specified directories only when the word on the line contains
the substring `tt(../)'.
)
item(tt(directory))(
Ignore the specified directories only when names of directories are
completed, not when completing names of files.
)
enditem()

Excluded values act in a similar fashion to values of the
tt(ignored-patterns) style, so they can be restored to consideration by
the tt(_ignored) completer.
)
kindex(ignored-patterns, completion style)
item(tt(ignored-patterns))(
A list of patterns; any trial completion matching one of the patterns
will be excluded from consideration.  The
tt(_ignored) completer can appear in the list of completers to
restore the ignored matches.  This is a more configurable
version of the shell parameter tt($fignore).

Note that the
tt(EXTENDED_GLOB) option is set during the execution of completion
functions, so the characters `tt(#)', `tt(~)' and `tt(^)' have special
meanings in the patterns.
)
kindex(insert, completion style)
item(tt(insert))(
This style is used by the tt(_all_matches) completer to decide whether to
insert the list of all matches unconditionally instead of adding the
list as another match.
)
kindex(insert-ids, completion style)
item(tt(insert-ids))(
When completing process IDs, for example as arguments to the tt(kill) and
tt(wait) builtins the name of a
command may be converted to the appropriate process ID.  A problem
arises when the process name typed is not unique.  By default (or if this
style is set explicitly to `tt(menu)') the name will be converted
immediately to a set of possible IDs, and menu completion will be started
to cycle through them.

If the value of the style is `tt(single)',
the shell will wait until the user has typed enough to make the command
unique before converting the name to an ID; attempts at completion will
be unsuccessful until that point.  If the value is any other
string, menu completion will be started when the string typed by the
user is longer than the common prefix to the corresponding IDs.
)
kindex(insert-sections, completion style)
item(tt(insert-sections))(
This style is used with tags of the form `tt(manuals.)var(X)' when
completing names of manual pages. If set and the var(X) in the tag name matches
the section number of the page being completed, the section number is inserted
along with the page name. For example, given

example(zstyle ':completion:*:manuals.*' insert-sections true)

tt(man ssh_<TAB>) may be completed to tt(man 5 ssh_config).

The value may also be set to one of `tt(prepend)', or `tt(suffix)'.
`tt(prepend)' behaves the same as `true' as in the above example, while
`tt(suffix)' would complete tt(man ssh_<TAB>) as tt(man ssh_config.5).

This is especially useful in conjunction with tt(separate-sections), as
it ensures that the page requested of tt(man) corresponds to the one
displayed in the completion listing when there are multiple pages with the
same name (e.g., tt(printf+LPAR()1+RPAR()) and tt(printf+LPAR()3+RPAR())).

The default for this style is `false'.
)
kindex(insert-tab, completion style)
item(tt(insert-tab))(
If this is set to `true', the completion system will
insert a TAB character (assuming that was used to start completion) instead
of performing completion when there is no non-blank character to the left
of the cursor.  If it is set to `false', completion will be done even there.

The value may also contain the substrings `tt(pending)' or
`tt(pending=)var(val)'.  In this case, the typed character will be
inserted instead of starting completion when there is unprocessed input
pending.  If a var(val) is given, completion will not be done if there
are at least that many characters of unprocessed input.  This is often
useful when pasting characters into a terminal.  Note
however, that it relies on the tt($PENDING) special parameter from the
tt(zsh/zle) module being set properly which is not guaranteed on all
platforms.

The default value of this style is `true' except for completion within
tt(vared) builtin command where it is `false'.
)
kindex(insert-unambiguous, completion style)
item(tt(insert-unambiguous))(
This is used by the tt(_match) and tt(_approximate) completers.
These completers are often used with menu completion since the word typed
may bear little resemblance to the final completion.
However, if this style is `true', the completer will start menu
completion only if it could find no unambiguous initial string at
least as long as the original string typed by the user.

In the case of the tt(_approximate) completer, the completer
field in the context will already have been set to one of
tt(correct-)var(num) or tt(approximate-)var(num), where var(num) is the
number of errors that were accepted.

In the case of the tt(_match) completer, the style may also be set to
the string `tt(pattern)'.  Then the pattern on the line is left
unchanged if it does not match unambiguously.
)
kindex(keep-prefix, completion style)
item(tt(keep-prefix))(
This style is used by the tt(_expand) completer.  If it is `true', the
completer will try to keep a prefix containing a tilde or parameter
expansion.  Hence, for example, the string `tt(~/f*)' would be expanded to
`tt(~/foo)' instead of `tt(/home/user/foo)'.  If the style is set to
`tt(changed)' (the default), the prefix will only be left unchanged if
there were other changes between the expanded words and the original
word from the command line.  Any other value forces the prefix to be
expanded unconditionally.

The behaviour of tt(_expand) when this style is `true' is to cause tt(_expand)
to give up when a single expansion with the restored prefix is the same
as the original; hence any remaining completers may be called.
)
kindex(known-hosts-files)
item(tt(known-hosts-files))(
This style should contain a list of files to search for host names and
(if the tt(use-ip) style is set) IP addresses in a format compatible with
ssh tt(known_hosts) files.  If it is not set, the files
tt(/etc/ssh/ssh_known_hosts) and tt(~/.ssh/known_hosts) are used.
)
kindex(last-prompt, completion style)
item(tt(last-prompt))(
This is a more flexible form of the tt(ALWAYS_LAST_PROMPT) option.
If it is `true', the completion system will try to return the cursor to
the previous command line after displaying a completion list.  It is
tested for all tags valid for the current completion, then the
tt(default) tag.  The cursor will be moved back to the
previous line if this style is `true' for all types of match.  Note
that unlike the tt(ALWAYS_LAST_PROMPT) option this is independent of the
numeric argument.
)
kindex(list, completion style)
item(tt(list))(
This style is used by the tt(_history_complete_word) bindable command.
If it is set to `true' it has no effect.  If it is set to `false'
matches will not be listed.  This overrides the setting of the options
controlling listing behaviour, in particular tt(AUTO_LIST).  The context
always starts with `tt(:completion:history-words)'.
)
kindex(list-colors, completion style)
item(tt(list-colors))(
If the tt(zsh/complist) module is loaded, this style can be used to set
color specifications.  This mechanism replaces the use of the
tt(ZLS_COLORS) and tt(ZLS_COLOURS) parameters described in
ifzman(the section `The zsh/complist Module' in zmanref(zshmodules))\
ifnzman(noderef(The zsh/complist Module))\
, but the syntax is the same.

If this style is set for the tt(default) tag, the strings in the value 
are taken as specifications that are to be used everywhere.  If it is
set for other tags, the specifications are used only for matches of
the type described by the tag.  For this to work best, the tt(group-name)
style must be set to an empty string.  

In addition to setting styles for specific tags, it is also possible to
use group names specified explicitly by the tt(group-name) tag together
with the `tt((group))' syntax allowed by the tt(ZLS_COLORS) and
tt(ZLS_COLOURS) parameters and simply using the tt(default) tag.

It is possible to use any color specifications already set up for the GNU
version of the tt(ls) command:

example(zstyle ':completion:*:default' list-colors \ 
       ${(s.:.)LS_COLORS})

The default colors are the same as for the GNU tt(ls) command and can be
obtained by setting the style to an empty string (i.e. tt('')).
)
kindex(list-dirs-first, completion style)
item(tt(list-dirs-first))(
This is used by file completion and corresponds to a particular
setting of the tt(file-patterns) style.
If set, the default directories to be completed
are listed separately from and before completion for other files.
)
kindex(list-grouped, completion style)
item(tt(list-grouped))(
If this style is `true' (the default), the completion system will try to
make certain completion listings more compact by grouping matches.
For example, options for commands that have the same description (shown
when the tt(verbose) style is set to `true') will appear as a single
entry.  However, menu selection can be used to cycle through all the
matches.
)
kindex(list-packed, completion style)
item(tt(list-packed))(
This is tested for each tag valid in the current context as well as the
tt(default) tag.  If it is set to `true', the corresponding matches
appear in listings as if the tt(LIST_PACKED) option were set.  If it is
set to `false', they are listed normally.
)
kindex(list-prompt, completion style)
item(tt(list-prompt))(
If this style is set for the tt(default) tag,
completion lists that don't fit on the screen can be scrolled (see
ifzman(the description of the tt(zsh/complist) module in zmanref(zshmodules))\
ifnzman(noderef(The zsh/complist Module))\
).  The value, if not the empty string, will be displayed after every
screenful and the shell will prompt for a key press; if the style is
set to the empty string,
a default prompt will be used.

The value may contain the escape sequences:
`tt(%l)' or `tt(%L)', which will be replaced by the number of the last line
displayed and the total number of lines; `tt(%m)' or `tt(%M)', 
the number of the  last match shown and the total number of
matches; and `tt(%p)' and `tt(%P)', `tt(Top)'
when at the beginning of the list, `tt(Bottom)' when at the end and the
position shown as a percentage of the total length otherwise.  In each
case the form with the uppercase letter will be replaced by a string of fixed
width, padded to the  right with spaces, while the lowercase form will
be replaced by a variable width string.  As in other prompt strings, the
escape sequences `tt(%S)', `tt(%s)', `tt(%B)', `tt(%b)', `tt(%U)',
`tt(%u)' for entering and leaving the display modes
standout, bold and underline, and `tt(%F)', `tt(%f)', `tt(%K)', `tt(%k)' for
changing the foreground background colour, are also available, as is the form
`tt(%{)...tt(%})' for enclosing escape sequences which display with zero
(or, with a numeric argument, some other) width.

After deleting this prompt the variable tt(LISTPROMPT) should be unset for
the removal to take effect.
)
kindex(list-rows-first, completion style)
item(tt(list-rows-first))(
This style is tested in the same way as the tt(list-packed) style and
determines whether matches are to be listed in a rows-first fashion as
if the tt(LIST_ROWS_FIRST) option were set.
)
kindex(list-separator, completion style)
item(tt(list-separator))(
The value of this style is used in completion listing to separate the
string to complete from a description when possible (e.g. when
completing options).  It defaults to `tt(-)tt(-)' (two hyphens).
)
kindex(list-suffixes, completion style)
item(tt(list-suffixes))(
This style is used by the function that completes filenames.  If it is
`true', and completion is attempted on a string containing multiple partially
typed pathname components, all ambiguous components will be shown.
Otherwise, completion stops at the first ambiguous component.
)
kindex(local, completion style)
item(tt(local))(
This is for use with functions that complete URLs for which the
corresponding files are available directly from the file system.
Its value should consist of three strings: a
hostname, the path to the default web pages for the server, and the
directory name used by a user placing web pages within their home
area.

For example:

example(zstyle ':completion:*' local toast \ 
    /var/http/public/toast public_html)

Completion after `tt(http://toast/stuff/)' will look for files in the
directory tt(/var/http/public/toast/stuff),  while completion after
`tt(http://toast/~yousir/)' will look for files in the directory
tt(~yousir/public_html).
)
kindex(mail-directory, completion style)
item(tt(mail-directory))(
If set, zsh will assume that mailbox files can be found in
the directory specified.  It defaults to `tt(~/Mail)'.
)
kindex(match-original, completion style)
item(tt(match-original))(
This is used by the tt(_match) completer.  If it is set to
tt(only), tt(_match) will try to generate matches without inserting a
`tt(*)' at the cursor position.  If set to any other non-empty value,
it will first try to generate matches without inserting the `tt(*)'
and if that yields no matches, it will try again with the `tt(*)'
inserted.  If it is unset or set to the empty string, matching will
only be performed with the `tt(*)' inserted.
)
kindex(matcher, completion style)
item(tt(matcher))(
This style is tested separately for each tag valid in the current
context.  Its value is placed before any match specifications given by the
tt(matcher-list) style so can override them via the use of an tt(x:)
specification.  The value should be in the form described in
ifzman(the section `Completion Matching Control' in zmanref(zshcompwid))\
ifnzman(noderef(Completion Matching Control))\
.  For examples of this, see the description of the tt(tag-order) style.

For notes comparing the use of this and the tt(matcher-list) style, see
under the description of the tt(tag-order) style.
)
kindex(matcher-list, completion style)
item(tt(matcher-list))(
This style can be set to a list of match specifications that are to
be applied everywhere. Match specifications are described in
ifzman(the section `Completion Matching Control' in zmanref(zshcompwid))\
ifnzman(noderef(Completion Matching Control))\
.
The completion system will try them one after another for each completer
selected.  For example, to try first simple completion and, if that
generates no matches, case-insensitive completion:

example(zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}')

By default each specification replaces the previous one; however, if a
specification is prefixed with tt(+), it is added to the existing list.
Hence it is possible to create increasingly general specifications
without repetition:

example(zstyle ':completion:*' matcher-list \ 
       '' '+m:{a-z}={A-Z}' '+m:{A-Z}={a-z}')

It is possible to create match specifications valid for particular
completers by using the third field of the context.  This applies only
to completers that override the global matcher-list, which as of this
writing includes only tt(_prefix) and tt(_ignored).  For example, to
use the completers tt(_complete) and tt(_prefix) but allow
case-insensitive completion only with tt(_complete):

example(zstyle ':completion:*' completer _complete _prefix
zstyle ':completion:*:complete:*:*:*' matcher-list \ 
       '' 'm:{a-zA-Z}={A-Za-z}')

User-defined names, as explained for the tt(completer) style, are
available.  This makes it possible to try the same completer more than
once with different match specifications each time.  For example, to try
normal completion without a match specification, then normal completion
with case-insensitive matching, then correction, and finally
partial-word completion:

example(zstyle ':completion:*' completer \ 
    _complete _correct _complete:foo
zstyle ':completion:*:complete:*:*:*' matcher-list \ 
    '' 'm:{a-zA-Z}={A-Za-z}'
zstyle ':completion:*:foo:*:*:*' matcher-list \ 
    'm:{a-zA-Z}={A-Za-z} r:|[-_./]=* r:|=*')

If the style is unset in any context no match specification is applied.
Note also that some completers such as tt(_correct) and tt(_approximate)
do not use the match specifications at all, though these completers will
only ever be called once even if the tt(matcher-list) contains more than
one element.

Where multiple specifications are useful, note that the em(entire)
completion is done for each element of tt(matcher-list), which can
quickly reduce the shell's performance.  As a rough rule of thumb,
one to three strings will give acceptable performance.  On the other
hand, putting multiple space-separated values into the same string does
not have an appreciable impact on performance.

If there is no current matcher or it is empty, and the option
tt(NO_CASE_GLOB) is in effect, the matching for files is performed
case-insensitively in any case.  However, any matcher must
explicitly specify case-insensitive matching if that is required.

For notes comparing the use of this and the tt(matcher) style, see
under the description of the tt(tag-order) style.
)
kindex(max-errors, completion style)
item(tt(max-errors))(
This is used by the tt(_approximate) and tt(_correct) completer functions
to determine the maximum number of errors to allow.  The completer will try
to generate completions by first allowing one error, then two errors, and
so on, until either a match or matches were found or the maximum number of
errors given by this style has been reached.

If the value for this style contains the string `tt(numeric)', the 
completer function will take any numeric argument as the
maximum number of errors allowed. For example, with

example(zstyle ':completion:*:approximate:::' max-errors 2 numeric)

two errors are allowed if no numeric argument is given, but with
a numeric argument of six (as in `tt(ESC-6 TAB)'), up to six
errors are accepted.  Hence with a value of `tt(0 numeric)', no correcting
completion will be attempted unless a numeric argument is given.

If the value contains the string `tt(not-numeric)', the completer
will em(not) try to generate corrected
completions when given a numeric argument, so in this case the number given
should be greater than zero.  For example, `tt(2 not-numeric)' specifies that
correcting completion with two errors will usually be performed, but if a
numeric argument is given, correcting completion will not be
performed.

The default value for this style is `tt(2 numeric)'.
)
kindex(max-matches-width, completion style)
item(tt(max-matches-width))(
This style is used to determine the trade off between the width of the
display used for matches and the width used for their descriptions when
the tt(verbose) style is in effect.  The value gives the number of
display columns to reserve for the matches.  The default is half the
width of the screen.

This has the most impact when several matches have the
same description and so will be grouped together.  Increasing the style
will allow more matches to be grouped together; decreasing it will allow
more of the description to be visible.
)
kindex(menu, completion style)
item(tt(menu))(
If this is `true' in the context of any of the tags defined
for the current completion menu completion will be used.  The value for
a specific tag will take precedence over that for the `tt(default)' tag.

If none of the values found in this way is `true' but at least
one is set to `tt(auto)', the shell behaves as if the tt(AUTO_MENU)
option is set.

If one of the values is explicitly set to `false', menu
completion will be explicitly turned off, overriding the
tt(MENU_COMPLETE) option and other settings.

In the form `tt(yes=)var(num)', where `tt(yes)' may be any of the
`true' values (`tt(yes)', `tt(true)', `tt(on)' and `tt(1)'),
menu completion will be turned on if there are at least var(num) matches.
In the form `tt(yes=long)', menu completion will be turned on
if the list does not fit on the screen.  This does not activate menu
completion if the widget normally only lists completions, but menu
completion can be activated in that case with the value `tt(yes=long-list)'
(Typically, the value `tt(select=long-list)' described later is more
useful as it provides control over scrolling.)

Similarly, with any of the `false' values (as in `tt(no=10)'), menu
completion will em(not) be used if there are var(num) or more matches.  

The value of this widget also controls menu selection, as implemented by
the tt(zsh/complist) module.  The following values may appear either
alongside or instead of the values above.

If the value contains the string `tt(select)', menu selection
will be started unconditionally.

In the form `tt(select=)var(num)', menu selection will only be started if
there are at least var(num) matches.  If the values for more than one
tag provide a number, the smallest number is taken.

Menu selection can be turned off explicitly by defining a value
containing the string`tt(no-select)'.

It is also possible to start menu selection only if the list of
matches does not fit on the screen by using the value
`tt(select=long)'.  To start menu selection even if the current widget
only performs listing, use the value `tt(select=long-list)'.

To turn on menu completion or menu selection when there are a certain
number of matches em(or) the list of matches does not fit on the
screen, both of `tt(yes=)' and `tt(select=)' may be given twice, once
with a number and once with `tt(long)' or `tt(long-list)'.

Finally, it is possible to activate two special modes of menu selection.
The word `tt(interactive)' in the value causes interactive mode
to be entered immediately when menu selection is started; see
ifzman(the description of the tt(zsh/complist) module in zmanref(zshmodules))\
ifnzman(noderef(The zsh/complist Module))
for a description of interactive mode.  Including the string
`tt(search)' does the same for incremental search mode.  To select backward
incremental search, include the string `tt(search-backward)'.
)
kindex(muttrc, completion style)
item(tt(muttrc))(
If set, gives the location of the mutt configuration file.  It defaults
to `tt(~/.muttrc)'.
)
kindex(numbers, completion style)
item(tt(numbers))(
This is used with the tt(jobs) tag.  If it is `true', the shell will
complete job numbers instead of the shortest unambiguous prefix
of the job command text.  If the value is a number, job numbers will
only be used if that many words from the job descriptions are required to
resolve ambiguities.  For example, if the value is `tt(1)', strings will
only be used if all jobs differ in the first word on their command lines.
)
kindex(old-list, completion style)
item(tt(old-list))(
This is used by the tt(_oldlist) completer.  If it is set to `tt(always)',
then standard widgets which perform listing will retain the current list of
matches, however they were generated; this can be turned off explicitly
with the value `tt(never)', giving the behaviour without the tt(_oldlist)
completer.  If the style is unset, or any other value, then the existing
list of completions is displayed if it is not already; otherwise, the
standard completion list is generated; this is the default behaviour of
tt(_oldlist).  However, if there is an old list and this style contains
the name of the completer function that generated the list, then the
old list will be used even if it was generated by a widget which does
not do listing.

For example, suppose you type tt(^Xc) to use the tt(_correct_word)
widget, which generates a list of corrections for the word under the
cursor.  Usually, typing tt(^D) would generate a standard list of
completions for the word on the command line, and show that.  With
tt(_oldlist), it will instead show the list of corrections already
generated.

As another example consider the tt(_match) completer: with the
tt(insert-unambiguous) style set to `true' it inserts only a common prefix
string, if there is any.  However, this may remove parts of the original
pattern, so that further completion could produce more matches than on the
first attempt.  By using the tt(_oldlist) completer and setting this style
to tt(_match), the list of matches generated on the first attempt will be
used again.
)
kindex(old-matches, completion style)
item(tt(old-matches))(
This is used by the tt(_all_matches) completer to decide if an old
list of matches should be used if one exists.  This is selected by one of
the `true' values or by the string `tt(only)'.  If
the value is `tt(only)', tt(_all_matches) will only use an old list
and won't have any effect on the list of matches currently being
generated.

If this style is set it is generally unwise to call the tt(_all_matches)
completer unconditionally.  One possible use is for either this style or
the tt(completer) style to be defined with the tt(-e) option to
tt(zstyle) to make the style conditional.
)
kindex(old-menu, completion style)
item(tt(old-menu))(
This is used by the tt(_oldlist) completer.  It controls how menu
completion behaves when a completion has already been inserted and the
user types a standard completion key such as tt(TAB).  The default
behaviour of tt(_oldlist) is that menu completion always continues
with the existing list of completions.  If this style is set to
`false', however, a new completion is started if the old list was
generated by a different completion command; this is the behaviour without
the tt(_oldlist) completer.

For example, suppose you type tt(^Xc) to generate a list of corrections,
and menu completion is started in one of the usual ways.  Usually, or with
this style set to `false', typing tt(TAB) at this point would start
trying to complete the line as it now appears.  With tt(_oldlist), it
instead continues to cycle through the list of corrections.
)
kindex(original, completion style)
item(tt(original))(
This is used by the tt(_approximate) and tt(_correct)
completers to decide if the original string should be added as
a possible completion.  Normally, this is done only if there are
at least two possible corrections, but if this style is set to `true', it
is always added.  Note that the style will be examined with the
completer field in the context name set to tt(correct-)var(num) or
tt(approximate-)var(num), where var(num) is the number of errors that
were accepted.
)
kindex(packageset, completion style)
item(tt(packageset))(
This style is used when completing arguments of the Debian `tt(dpkg)'
program.  It contains an override for the default package set
for a given context.  For example,

example(zstyle ':completion:*:complete:dpkg:option--status-1:*' \ 
               packageset avail)

causes available packages, rather than only installed packages,
to be completed for `tt(dpkg -)tt(-status)'.
)
kindex(path, completion style)
item(tt(path))(
The function that completes color names uses this style with the 
tt(colors) tag.  The value should be the pathname of a file
containing color names in the format of an X11 tt(rgb.txt) file.  If
the style is not set but this file is found in one of various standard
locations it will be used as the default.
)
kindex(path-completion, completion style)
item(tt(path-completion))(
This is used by filename completion.  By default, filename completion
examines all components of a path to see if there are completions of
that component.  For example, tt(/u/b/z) can be completed to
tt(/usr/bin/zsh).  Explicitly setting this style to `false' inhibits this
behaviour for path components up to the tt(/) before the cursor; this
overrides the setting of tt(accept-exact-dirs).

Even with the style set to `false', it is still possible to complete
multiple paths by setting the option tt(COMPLETE_IN_WORD) and moving the
cursor back to the first component in the path to be completed.  For
example, tt(/u/b/z) can be completed to tt(/usr/bin/zsh) if the cursor is
after the tt(/u).
)
kindex(pine-directory, completion style)
item(tt(pine-directory))(
If set, specifies the directory containing PINE mailbox files.  There
is no default, since recursively searching this directory is inconvenient
for anyone who doesn't use PINE.
)
kindex(ports, completion style)
item(tt(ports))(
A list of Internet service names (network ports) to complete.  If this is
not set, service names are taken from the file `tt(/etc/services)'.
)
kindex(prefix-hidden, completion style)
item(tt(prefix-hidden))(
This is used for certain completions which share a common prefix, for
example command options beginning with dashes.  If it is `true', the
prefix will not be shown in the list of matches.

The default value for this style is `false'.
)
kindex(prefix-needed, completion style)
item(tt(prefix-needed))(
This style is also relevant for matches with a common prefix.  If it is
set to `true' this common prefix must be typed by the user to generate
the matches.

The style is applicable to the tt(options), tt(signals), tt(jobs),
tt(functions), and tt(parameters) completion tags.

For command options, this means that the initial `tt(-)', `tt(+)', or
`tt(-)tt(-)' must be typed explicitly before option names will be
completed.

For signals, an initial `tt(-)' is required before signal names will
be completed.

For jobs, an initial `tt(%)' is required before job names will be
completed.

For function and parameter names, an initial `tt(_)' or `tt(.)' is
required before function or parameter names starting with those
characters will be completed.

The default value for this style is `false' for tt(function) and
tt(parameter) completions, and  `true' otherwise.
)
kindex(preserve-prefix, completion style)
item(tt(preserve-prefix))(
This style is used when completing path names.  Its value should be a
pattern matching an initial prefix of the word to complete that should
be left unchanged under all circumstances.  For example, on some Unices
an initial `tt(//)' (double slash) has a special meaning; setting
this style to the string `tt(//)' will preserve it.  As another example,
setting this style to `tt(?:/)' under Cygwin would allow completion
after `tt(a:/...)' and so on.
)
kindex(range, completion style)
item(tt(range))(
This is used by the tt(_history) completer and the
tt(_history_complete_word) bindable command to decide which words
should be completed.  

If it is a single number, only the last var(N) words from the history
will be completed.

If it is a range of the form `var(max)tt(:)var(slice)',
the last var(slice) words will be completed; then if that
yields no matches, the var(slice) words before those will be tried and 
so on.  This process stops either when at least one match has been
found, or var(max) words have been tried.

The default is to complete all words from the history at once.
)
kindex(recursive-files, completion style)
item(tt(recursive-files))(
If this style is set, its value is an array of patterns to be
tested against `tt($PWD/)': note the trailing slash, which allows
directories in the pattern to be delimited unambiguously by including
slashes on both sides.  If an ordinary file completion fails
and the word on the command line does not yet have a directory part to its
name, the style is retrieved using the same tag as for the completion
just attempted, then the elements tested against tt($PWD/) in turn.
If one matches, then the shell reattempts completion by prepending the word
on the command line with each directory in the expansion of tt(**/*(/))
in turn.  Typically the elements of the style will be set to restrict
the number of directories beneath the current one to a manageable
number, for example `tt(*/.git/*)'.

For example,

example(zstyle ':completion:*' recursive-files '*/zsh/*')

If the current directory is tt(/home/pws/zsh/Src), then
tt(zle_tr<TAB>) can be completed to tt(Zle/zle_tricky.c).
)
kindex(regular, completion style)
item(tt(regular))(
This style is used by the tt(_expand_alias) completer and bindable 
command.  If set to `true' (the default), regular aliases will be
expanded but only in command position.  If it is set to `false',
regular aliases will never be expanded.   If it is set to `tt(always)',
regular aliases will be expanded even if not in command position.
)
kindex(rehash, completion style)
item(tt(rehash))(
If this is set when completing external commands, the internal
list (hash) of commands will be updated for each search by issuing
the tt(rehash) command.  There is a speed penalty for this which
is only likely to be noticeable when directories in the path have
slow file access.
)
kindex(remote-access, completion style)
item(tt(remote-access))(
If set to `false', certain commands will be prevented from making
Internet connections to retrieve remote information.  This includes the
completion for the tt(CVS) command.

It is not always possible to know if connections are in fact to a remote
site, so some may be prevented unnecessarily.
)
kindex(remove-all-dups, completion style)
item(tt(remove-all-dups))(
The tt(_history_complete_word) bindable command and the tt(_history)
completer use this to decide if all duplicate matches should be
removed, rather than just consecutive duplicates.
)
kindex(select-prompt, completion style)
item(tt(select-prompt))(
If this is set for the tt(default) tag, its
value will be displayed during menu selection (see the tt(menu) style
above) when the completion list does not fit on the screen as a
whole.  The same escapes as for the tt(list-prompt) style are
understood, except that the numbers refer to the match or line the mark is
on.  A default prompt is used when the value is the empty string.
)
kindex(select-scroll, completion style)
item(tt(select-scroll))(
This style is tested for the tt(default) tag and determines how a
completion list is scrolled during a menu selection (see the tt(menu)
style above) when the completion list does not fit on the screen as a
whole.  If the value is `tt(0)' (zero), the list is scrolled by
half-screenfuls; if it is a positive integer, the list is scrolled by the
given number of lines; if it is a negative number, the list is scrolled by a
screenful minus the absolute value of the given number of lines.
The default is to scroll by single lines.
)
kindex(separate-sections, completion style)
item(tt(separate-sections))(
This style is used with the tt(manuals) tag when completing names of
manual pages.  If it is `true', entries for different sections are
added separately using tag names of the form `tt(manuals.)var(X)',
where var(X) is the section number.  When the tt(group-name) style is
also in effect, pages from different sections will appear separately.
This style is also used similarly with the tt(words) style when
completing words for the dict command. It allows words from different
dictionary databases to be added separately. See also tt(insert-sections).

The default for this style is `false'.
)
kindex(show-ambiguity, completion style)
item(tt(show-ambiguity))(
If the tt(zsh/complist) module is loaded, this style can be used to
highlight the first ambiguous character in completion lists. The
value is either a color indication such as those supported by the
tt(list-colors) style or, with a value of `true', a default of
underlining is selected. The highlighting is only applied if the
completion display strings correspond to the actual matches.
)
kindex(show-completer, completion style)
item(tt(show-completer))(
Tested whenever a new completer is tried.  If it is `true', the completion
system outputs a progress message in the listing area showing what
completer is being tried.  The message will be overwritten by any output
when completions are found and is removed after completion is finished.
)
kindex(single-ignored, completion style)
item(tt(single-ignored))(
This is used by the tt(_ignored) completer when there is only one match.
If its value is `tt(show)', the single match will be
displayed but not inserted.  If the value is `tt(menu)', then the single
match and the original string are both added as matches and menu completion
is started, making it easy to select either of them.
)
kindex(sort, completion style)
item(tt(sort))(
This allows the standard ordering of matches to be overridden.

If its value is `tt(true)' or `tt(false)', sorting is enabled or disabled.
Additionally the values associated with the `tt(-o)' option to tt(compadd) can
also be listed: tt(match), tt(nosort), tt(numeric), tt(reverse).  If it is not
set for the context, the standard behaviour of the calling widget is used.

The style is tested first against the full context including the tag, and
if that fails to produce a value against the context without the tag.

In many cases where a calling widget explicitly selects a particular ordering
in lieu of the default, a value of `tt(true)' is not honoured.  An example of
where this is not the case is for command history where the default of sorting
matches chronologically may be overridden by setting the style to `true'.

In the tt(_expand) completer, if it is set to
`true', the expansions generated will always be sorted.  If it is set
to `tt(menu)', then the expansions are only sorted when they are offered 
as single strings but not in the string containing all possible
expansions.
)
kindex(special-dirs, completion style)
item(tt(special-dirs))(
Normally, the completion code will not produce the directory names
`tt(.)' and `tt(..)' as possible completions.  If this style is set to
`true', it will add both `tt(.)' and `tt(..)' as possible completions;
if it is set to `tt(..)', only `tt(..)' will be added.

The following example sets tt(special-dirs) to `tt(..)' when the
current prefix is empty, is a single `tt(.)', or consists only of a path
beginning with `tt(../)'.  Otherwise the value is `false'.

example(zstyle -e ':completion:*' special-dirs \ 
   '[[ $PREFIX = LPAR()../RPAR()#LPAR()|.|..RPAR() ]] && reply=LPAR()..RPAR()')
)
kindex(squeeze-slashes, completion style)
item(tt(squeeze-slashes))(
If set to `true', sequences of slashes in filename paths (for example in
`tt(foo//bar)') will be treated as a single slash.  This is the usual
behaviour of UNIX paths.  However, by default the file completion
function behaves as if there were a `tt(*)' between the slashes.
)
kindex(stop, completion style)
item(tt(stop))(
If set to `true', the tt(_history_complete_word) bindable
command will stop once when reaching the beginning or end of the
history.  Invoking tt(_history_complete_word) will then wrap around to 
the opposite end of the history.  If this style is set to `false' (the 
default), tt(_history_complete_word) will loop immediately as in a
menu completion.
)
kindex(strip-comments, completion style)
item(tt(strip-comments))(
If set to `true', this style causes non-essential comment text to be
removed from completion matches.  Currently it is only used when
completing e-mail addresses where it removes any display name from the
addresses, cutting them down to plain var(user@host) form.
)
kindex(subst-globs-only, completion style)
item(tt(subst-globs-only))(
This is used by the tt(_expand) completer.  If it is set to `true',
the expansion will only be used if it resulted from globbing; hence,
if expansions resulted from the use of the tt(substitute) style
described below, but these were not further changed by globbing, the
expansions will be rejected.

The default for this style is `false'.
)
kindex(substitute, completion style)
item(tt(substitute))(
This boolean style controls whether the tt(_expand) completer will
first try to expand all substitutions in the string (such as
`tt($LPAR())var(...)tt(RPAR())' and `tt(${)var(...)tt(})').

The default is `true'.
)
kindex(suffix, completion style)
item(tt(suffix))(
This is used by the tt(_expand) completer if the word starts with a
tilde or contains a parameter expansion.  If it is set to `true', the
word will only be expanded if it doesn't have a suffix, i.e. if it is
something like `tt(~foo)' or `tt($foo)' rather than `tt(~foo/)' or
`tt($foo/bar)', unless that suffix itself contains characters eligible
for expansion.  The default for this style is `true'.
)
kindex(tag-order, completion style)
item(tt(tag-order))(
This provides a mechanism for sorting how the tags available in a
particular context will be used.

The values for the style are sets of space-separated lists of tags.
The tags in each value will be tried at the same time; if no match is
found, the next value is used.  (See the tt(file-patterns) style for
an exception to this behavior.)

For example:

example(zstyle ':completion:*:complete:-command-:*:*' tag-order \ 
    'commands functions')

specifies that completion in command position first offers
external commands and shell functions.  Remaining tags will be tried if
no completions are found.

In addition to tag names, each string in the value may take one of the
following forms:

startitem()
item(tt(-))(
If any value consists of only a hyphen,
then em(only) the tags specified in the other values are
generated.  Normally all tags not explicitly selected are tried last
if the specified tags fail to generate any matches.  This means 
that a single value consisting only of a single hyphen
turns off completion.
)
item(tt(!) var(tags)...)(
A string starting with an exclamation mark
specifies names of tags that are em(not) to be used.  The effect is
the same as if all other possible tags for the context had been
listed.
)
item(var(tag)tt(:)var(label) ...)(
Here, var(tag) is one of the standard tags and var(label) is an
arbitrary name.  Matches are generated as normal but the name var(label)
is used in contexts instead of var(tag).  This is not useful in words
starting with tt(!).

If the var(label) starts with a hyphen, the var(tag) is prepended to the
var(label) to form the name used for lookup.  This can be
used to make the completion system try a certain tag more than once,
supplying different style settings for each attempt; see below for an
example.
)
item(var(tag)tt(:)var(label)tt(:)var(description))(
As before, but tt(description) will replace the `tt(%d)' in
the value of the tt(format) style instead of the default description
supplied by the completion function.  Spaces in the description must
be quoted with a backslash.  A `tt(%d)' appearing
in var(description) is replaced with the description given by the
completion function.
)
enditem()

In any of the forms above the tag may be a pattern or several
patterns in the form `tt({)var(pat1)tt(,)var(pat2...)tt(})'.  In this
case all matching tags will be used except 
for any given explicitly in the same string.

One use of these features is to try
one tag more than once, setting other styles differently on
each attempt, but still to use all the other tags without having to
repeat them all.  For example, to make completion of function names in
command position ignore all the completion functions starting with an
underscore the first time completion is tried:

example(zstyle ':completion:*:*:-command-:*:*' tag-order \ 
    'functions:-non-comp *' functions
zstyle ':completion:*:functions-non-comp' \ 
    ignored-patterns '_*')

On the first attempt, all tags will be offered but the tt(functions) tag
will be replaced by tt(functions-non-comp).  The tt(ignored-patterns) style 
is set for this tag to exclude functions starting with an underscore.
If there are no matches, the second value of the
tt(tag-order) style is used which completes functions using the default
tag, this time presumably including all function names.

The matches for one tag can be split into different groups.  For example:

example(zstyle ':completion:*' tag-order \ 
    'options:-long:long\ options
     options:-short:short\ options
     options:-single-letter:single\ letter\ options'
zstyle ':completion:*:options-long' \ 
     ignored-patterns '[-+](|-|[^-]*)'
zstyle ':completion:*:options-short' \ 
     ignored-patterns '--*' '[-+]?'
zstyle ':completion:*:options-single-letter' \ 
     ignored-patterns '???*')

With the tt(group-names) style set, options beginning with
`tt(-)tt(-)', options beginning with a single `tt(-)' or `tt(+)' but
containing multiple characters, and single-letter options will be
displayed in separate groups with different descriptions.

Another use of patterns is to
try multiple match specifications one after another.  The
tt(matcher-list) style offers something similar, but it is tested very
early in the completion system and hence can't be set for single
commands nor for more specific contexts.  Here is how to
try normal completion without any match specification and, if that
generates no matches, try again with case-insensitive matching, restricting
the effect to arguments of the command tt(foo):

example(zstyle ':completion:*:*:foo:*:*' tag-order '*' '*:-case'
zstyle ':completion:*-case' matcher 'm:{a-z}={A-Z}')

First, all the tags offered when completing after tt(foo) are tried using
the normal tag name.  If that generates no matches, the second value of
tt(tag-order) is used, which tries all tags again except that this time
each has tt(-case) appended to its name for lookup of styles.  Hence this
time the value for the tt(matcher) style from the second call to tt(zstyle)
in the example is used to make completion case-insensitive.

It is possible to use the tt(-e) option of the tt(zstyle) builtin
command to specify conditions for the use of particular tags.  For
example:

example(zstyle -e '*:-command-:*' tag-order '
    if [[ -n $PREFIX$SUFFIX ]]; then
      reply=( )
    else
      reply=( - )
    fi')

Completion in command position will be attempted only if the string
typed so far is not empty.  This is tested using the tt(PREFIX)
special parameter; see
ifzman(zshcompwid)\
ifnzman(noderef(Completion Widgets))
for a description of parameters which are special inside completion widgets.
Setting tt(reply) to an empty array provides the default
behaviour of trying all tags at once; setting it to an
array containing only a hyphen disables the use of all tags and hence of
all completions.

If no tt(tag-order) style has been defined for a context, the strings
`tt((|*-)argument-* (|*-)option-* values)' and `tt(options)' plus all
tags offered by the completion function will be used to provide a
sensible default behavior that causes arguments (whether normal command
arguments or arguments of options) to be completed before option names for
most commands.
)
kindex(urls, completion style)
item(tt(urls))(
This is used together with the tt(urls) tag by
functions completing URLs.

If the value consists of more than one string, or if the only string
does not name a file or directory, the strings are used as the URLs to
complete.

If the value contains only one string which is the name of a normal 
file the URLs are taken from that file (where the URLs may be
separated by white space or newlines).

Finally, if the only string in the value names a directory, the
directory hierarchy rooted at this directory gives the completions.  The
top level directory should be the file access method, such as
`tt(http)', `tt(ftp)', `tt(bookmark)' and so on.  In many cases the next
level of directories will be a filename.  The directory hierarchy can
descend as deep as necessary.

For example, 

example(zstyle ':completion:*' urls ~/.urls
mkdir -p ~/.urls/ftp/ftp.zsh.org/pub
)

allows completion of all the components of the URL
tt(ftp://ftp.zsh.org/pub) after suitable commands such as
`tt(netscape)' or `tt(lynx)'.  Note, however, that access methods and
files are completed separately, so if the tt(hosts) style is set hosts
can be completed without reference to the tt(urls) style.

See the description in the function tt(_urls) itself
for more information (e.g. `tt(more $^fpath/_urls+LPAR()N+RPAR())').
)
kindex(use-cache, completion style)
item(tt(use-cache))(
If this is set, the completion caching layer is activated for any completions
which use it (via the tt(_store_cache), tt(_retrieve_cache), and
tt(_cache_invalid) functions).  The directory containing the cache
files can be changed with the tt(cache-path) style.
)
kindex(use-compctl, completion style)
item(tt(use-compctl))(
If this style is set to a string em(not) equal to tt(false), tt(0),
tt(no), and tt(off), the completion system may use any completion
specifications defined with the tt(compctl) builtin command.  If the
style is unset, this is done only if the tt(zsh/compctl) module
is loaded.  The string may also contain the substring `tt(first)' to
use completions defined with `tt(compctl -T)', and the substring
`tt(default)' to use the completion defined with `tt(compctl -D)'.

Note that this is only intended to smooth the transition from
tt(compctl) to the new completion system and may disappear in the
future.

Note also that the definitions from tt(compctl) will only be used if
there is no specific completion function for the command in question.  For
example, if there is a function tt(_foo) to complete arguments to the
command tt(foo), tt(compctl) will never be invoked for tt(foo).
However, the tt(compctl) version will be tried if tt(foo) only uses
default completion.
)
kindex(use-ip, completion style)
item(tt(use-ip))(
By default, the function tt(_hosts) that completes host names strips
IP addresses from entries read from host databases such as NIS and
ssh files.  If this style is `true', the corresponding IP addresses
can be completed as well.  This style is not use in any context
where the tt(hosts) style is set; note also it must be set before
the cache of host names is generated (typically the first completion
attempt).
)
kindex(users, completion style)
item(tt(users))(
This may be set to a list of usernames to be completed.
If it is not set all usernames will be completed.
Note that if it is set only that list of users will be completed;
this is because on some systems querying all users can take
a prohibitive amount of time.
)
kindex(users-hosts, completion style)
item(tt(users-hosts))(
The values of this style should be of the form
`var(user)tt(@)var(host)' or `var(user)tt(:)var(host)'. It is used for
commands that need pairs of
user- and hostnames.  These commands will complete usernames from this
style (only), and will restrict subsequent hostname completion to hosts
paired with that user in one of the values of the style.

It is possible to group values for sets of commands which allow a remote
login, such as tt(rlogin) and tt(ssh), by using the tt(my-accounts) tag.
Similarly, values for sets of commands which usually refer to the
accounts of other people, such as tt(talk) and tt(finger), can be
grouped by using the tt(other-accounts) tag.  More ambivalent commands
may use the tt(accounts) tag.
)
kindex(users-hosts-ports, completion style)
item(tt(users-hosts-ports))(
Like tt(users-hosts) but used for commands like tt(telnet) and
containing strings of the form `var(user)tt(@)var(host)tt(:)var(port)'.
)
kindex(verbose, completion style)
item(tt(verbose))(
If set, as it is by default, the completion listing is more verbose.
In particular many commands show descriptions for options if this
style is `true'.
)
kindex(word, completion style)
item(tt(word))(
This is used by the tt(_list) completer, which prevents the insertion of
completions until a second completion attempt when the line has not
changed.  The normal way of finding out if the line has changed is to
compare its entire contents between the two occasions.  If this style is
`true', the comparison is instead performed only on the current word.
Hence if completion is performed on another word with the same contents,
completion will not be delayed.
)
enditem()

texinode(Control Functions)(Bindable Commands)(Completion System Configuration)(Completion System)
sect(Control Functions)
cindex(completion system, choosing completers)

The initialization script tt(compinit) redefines all the widgets
which perform completion to call the supplied widget function
tt(_main_complete).  This function acts as a wrapper calling the
so-called `completer' functions that generate matches.  If
tt(_main_complete) is called with arguments, these are taken as the
names of completer functions to be called in the order given.  If no
arguments are given, the set of functions to try is taken from the
tt(completer) style.  For example, to use normal completion and
correction if that doesn't generate any matches:

example(zstyle ':completion:*' completer _complete _correct)

after calling tt(compinit). The default value for this style is
`tt(_complete _ignored)', i.e. normally only ordinary completion is tried,
first with the effect of the tt(ignored-patterns) style and then without
it.  The tt(_main_complete) function uses the return status of the completer
functions to decide if other completers should be called.  If the return
status is zero, no other completers are tried and the tt(_main_complete)
function returns.

If the first argument to tt(_main_complete) is a single hyphen, the
arguments will not be taken as names of completers.  Instead, the
second argument gives a name to use in the var(completer) field of the 
context and the other arguments give a command name and arguments to
call to generate the matches.

The following completer functions are contained in the distribution,
although users may write their own.  Note that in contexts the leading
underscore is stripped, for example basic completion is performed in the
context `tt(:completion::complete:)var(...)'.

cindex(completion system, completers)
startitem()
findex(_all_matches)
item(tt(_all_matches))(
This completer can be used to add a string consisting of all other
matches.  As it influences later completers it must appear as the first
completer in the list.  The list of all matches is affected by the
tt(avoid-completer) and tt(old-matches) styles described above.

It may be useful to use the tt(_generic) function described below
to bind tt(_all_matches) to its own keystroke, for example:

example(zle -C all-matches complete-word _generic
bindkey '^Xa' all-matches
zstyle ':completion:all-matches:*' old-matches only
zstyle ':completion:all-matches::::' completer _all_matches)

Note that this does not generate completions by itself:  first use
any of the standard ways of generating a list of completions,
then use tt(^Xa) to show all matches.  It is possible instead to
add a standard completer to the list and request that the
list of all matches should be directly inserted:

example(zstyle ':completion:all-matches::::' completer \ 
       _all_matches _complete
zstyle ':completion:all-matches:*' insert true)

In this case the tt(old-matches) style should not be set.
)
findex(_approximate)
item(tt(_approximate))(
This is similar to the basic tt(_complete) completer but allows the
completions to undergo corrections.  The maximum number of errors can be
specified by the tt(max-errors) style; see the description of
approximate matching in
ifzman(\
zmanref(zshexpn)
)\
ifnzman(\
noderef(Filename Generation)
)\
for how errors are counted.  Normally this completer will only be tried
after the normal tt(_complete) completer:

example(zstyle ':completion:*' completer _complete _approximate)

This will give correcting completion if and only if
normal completion yields no possible completions.  When
corrected completions are found, the completer will normally start
menu completion allowing you to cycle through these strings.

This completer uses the tags tt(corrections) and tt(original) when
generating the possible corrections and the original string.  The
tt(format) style for the former may contain the additional sequences
`tt(%e)' and `tt(%o)' which will be replaced by the number of errors
accepted to generate the corrections and the original string,
respectively.

The completer progressively increases the number of errors allowed up to
the limit by the tt(max-errors) style, hence if a completion is found
with one error, no completions with two errors will be shown, and so on.
It modifies the completer name in the context to indicate the number of
errors being tried: on the first try the completer field contains
`tt(approximate-1)', on the second try `tt(approximate-2)', and so on.

When tt(_approximate) is called from another function, the number of
errors to accept may be passed with the tt(-a) option.  The argument
is in the same format as the tt(max-errors) style, all in one string.

Note that this completer (and the tt(_correct) completer mentioned
below) can be quite expensive to call, especially when a large number
of errors are allowed.  One way to avoid this is to set up the
tt(completer) style using the tt(-e) option to zstyle so that some
completers are only used when completion is attempted a second time on 
the same string, e.g.:

example(zstyle -e ':completion:*' completer '
  if [[ $_last_try != "$HISTNO$BUFFER$CURSOR" ]]; then
    _last_try="$HISTNO$BUFFER$CURSOR"
    reply=(_complete _match _prefix)
  else
    reply=(_ignored _correct _approximate)
  fi')

This uses the tt(HISTNO) parameter and the tt(BUFFER) and tt(CURSOR)
special parameters that are available inside zle and completion
widgets to find out if the command line hasn't changed since the last
time completion was tried.  Only then are the tt(_ignored),
tt(_correct) and tt(_approximate) completers called.
)
findex(_canonical_paths)
item(tt(_canonical_paths) [ tt(-A) var(var) ] [ tt(-N) ] [ tt(-MJV12nfX) ] var(tag) var(descr) [ var(paths) ... ])(
This completion function completes all paths given to it, and also tries to
offer completions which point to the same file as one of the paths given
(relative path when an absolute path is given, and vice versa; when tt(..)'s
are present in the word to be completed; and some paths got from symlinks).

tt(-A), if specified, takes the paths from the array variable specified. Paths can
also be specified on the command line as shown above.  tt(-N), if specified,
prevents canonicalizing the paths given before using them for completion, in
case they are already so. The options tt(-M), tt(-J), tt(-V), tt(-1), tt(-2),
tt(-n), tt(-F), tt(-X) are passed to tt(compadd).

See tt(_description) for a description of var(tag) and var(descr).
)
findex(_cmdambivalent)
item(tt(_cmdambivalent))(
Completes the remaining positional arguments as an external command.
The external command and its arguments are completed as separate arguments
(in a manner appropriate for completing tt(/usr/bin/env))
if there are two or more remaining positional arguments on the command line,
and as a quoted command string (in the manner of tt(system+LPAR()...+RPAR())) otherwise.
See also tt(_cmdstring) and tt(_precommand).

This function takes no arguments.
)
findex(_cmdstring)
item(tt(_cmdstring))(
Completes an external command as a single argument, as for
tt(system+LPAR()...+RPAR()).
)
findex(_complete)
item(tt(_complete))(
This completer generates all possible completions in a context-sensitive
manner, i.e. using the settings defined with the tt(compdef) function
explained above and the current settings of all special parameters.
This gives the normal completion behaviour.

To complete arguments of commands, tt(_complete) uses the utility function
tt(_normal), which is in turn responsible for finding the particular
function; it is described below.  Various contexts of the form
tt(-)var(context)tt(-) are handled specifically. These are all
mentioned above as possible arguments to the tt(#compdef) tag.

Before trying to find a function for a specific context, tt(_complete) 
checks if the parameter `tt(compcontext)' is set. Setting
`tt(compcontext)' allows the usual completion dispatching to be
overridden which is useful in places such as a function that uses
tt(vared) for input. If it is set to an array, the elements are taken
to be the possible matches which will be completed using the tag
`tt(values)' and the description `tt(value)'. If it is set to an
associative array, the keys are used as the possible completions and
the values (if non-empty) are used as descriptions for the matches.  If
`tt(compcontext)' is set to a string containing colons, it should be of
the form `var(tag)tt(:)var(descr)tt(:)var(action)'.  In this case the
var(tag) and var(descr) give the tag and description to use and the
var(action) indicates what should be completed in one of the forms
accepted by the tt(_arguments) utility function described below.

Finally, if `tt(compcontext)' is set to a string without colons, the
value is taken as the name of the context to use and the function
defined for that context will be called.  For this purpose, there is a
special context named tt(-command-line-) that completes whole command
lines (commands and their arguments).  This is not used by the completion
system itself but is nonetheless handled when explicitly called.
)
findex(_correct)
item(tt(_correct))(
Generate corrections, but not completions, for the current word; this is
similar to tt(_approximate) but will not allow any number of extra
characters at the cursor as that completer does.  The effect is
similar to spell-checking.  It is based on tt(_approximate), but the
completer field in the context name is tt(correct).

For example, with:

example(zstyle ':completion:::::' completer \ 
       _complete _correct _approximate
zstyle ':completion:*:correct:::' max-errors 2 not-numeric
zstyle ':completion:*:approximate:::' max-errors 3 numeric)

correction will accept up to two errors.  If a numeric argument is
given, correction will not be performed, but correcting completion
will be, and will accept as many errors as given by the numeric
argument.  Without a numeric argument, first correction and then
correcting completion will be tried, with the first one accepting two
errors and the second one accepting three errors.

When tt(_correct) is called as a function, the number of errors to accept
may be given following the tt(-a) option.  The argument is in the same
form a values to the tt(accept) style, all in one string.

This completer function is intended to be used without the
tt(_approximate) completer or, as in the example, just before
it.  Using it after the tt(_approximate) completer is useless since
tt(_approximate) will at least generate the corrected strings
generated by the tt(_correct) completer DASH()- and probably more.
)
findex(_expand)
item(tt(_expand))(
This completer function does not really perform completion, but instead
checks if the word on the command line is eligible for expansion and,
if it is, gives detailed control over how this expansion is done.  For
this to happen, the completion system needs to be invoked with
tt(complete-word), not tt(expand-or-complete) (the default binding for
tt(TAB)), as otherwise the string will be expanded by the shell's
internal mechanism before the completion system is started.
Note also this completer should be called before the tt(_complete) 
completer function.

The tags used when generating expansions are tt(all-expansions) for the
string containing all possible expansions, tt(expansions) when adding
the possible expansions as single matches and tt(original) when adding
the original string from the line.  The order in which these strings are
generated, if at all, can be controlled by the tt(group-order) and
tt(tag-order) styles, as usual.

The format string for tt(all-expansions) and for tt(expansions) may
contain the sequence `tt(%o)' which will be replaced by the original
string from the line.

The kind of expansion to be tried is controlled by the tt(substitute),
tt(glob) and tt(subst-globs-only) styles.

It is also possible to call tt(_expand) as a function, in which case the
different modes may be selected with options: tt(-s) for
tt(substitute), tt(-g) for tt(glob) and tt(-o) for tt(subst-globs-only).
)
findex(_expand_alias)
item(tt(_expand_alias))(
If the word the cursor is on is an alias, it is expanded and no other
completers are called.  The types of aliases which are to be expanded can
be controlled with the styles tt(regular), tt(global) and tt(disabled).

This function is also a bindable command, see
ifzman(the section `Bindable Commands' below)\
ifnzman(noderef(Bindable Commands)).
)
findex(_extensions)
item(tt(_extensions))(
If the cursor follows the string `tt(*.)', filename extensions are
completed. The extensions are taken from files in current directory or a
directory specified at the beginning of the current word. For exact matches,
completion continues to allow other completers such as tt(_expand) to
expand the pattern. The standard tt(add-space) and tt(prefix-hidden)
styles are observed.
)
findex(_external_pwds)
item(tt(_external_pwds))(
Completes current directories of other zsh processes belonging to the
current user.

This is intended to be used via tt(_generic), bound to a custom key
combination. Note that pattern matching is enabled so matching is
performed similar to how it works with the tt(_match) completer.
)
findex(_history)
item(tt(_history))(
Complete words from the shell's command  history.  This completer 
can be controlled by the tt(remove-all-dups), and tt(sort) styles as for the
tt(_history_complete_word) bindable command, see
ifzman(the section `Bindable Commands' below)\
ifnzman(noderef(Bindable Commands))
and
ifzman(the section `Completion System Configuration' above)\
ifnzman(noderef(Completion System Configuration)).
)
findex(_ignored)
item(tt(_ignored))(
The tt(ignored-patterns) style can be set to a list of patterns which are
compared against possible completions; matching ones are removed.
With this completer those matches can be reinstated, as
if no tt(ignored-patterns) style were set.  The completer actually
generates its own list of matches; which completers are invoked
is determined in the same way as for the tt(_prefix) completer.
The tt(single-ignored) style is also available as described above.
)
findex(_list)
item(tt(_list))(
This completer allows the insertion of matches to be delayed until
completion is attempted a second time without the word on the line
being changed.  On the first attempt, only the list of matches will be
shown.  It is affected by the styles tt(condition) and tt(word), see
ifzman(the section `Completion System Configuration' above)\
ifnzman(noderef(Completion System Configuration)).
)
findex(_match)
item(tt(_match))(
This completer is intended to be used after the tt(_complete)
completer.  It behaves similarly but the string on the command line may
be a pattern to match against trial completions.  This gives the effect
of the tt(GLOB_COMPLETE) option.

Normally completion will be performed by taking the pattern from the line,
inserting a `tt(*)' at the cursor position and comparing the resulting
pattern with the possible completions generated.  This can be modified
with the tt(match-original) style described above.

The generated matches will be offered in a menu completion unless the
tt(insert-unambiguous) style is set to `true'; see the description above
for other options for this style.

Note that matcher specifications defined globally or used by the
completion functions (the styles tt(matcher-list) and tt(matcher)) will
not be used.
)
findex(_menu)
item(tt(_menu))(
This completer was written as simple example function to show how menu
completion can be enabled in shell code. However, it has the notable
effect of disabling menu selection which can be useful with
tt(_generic) based widgets. It should be used as the first completer in
the list.  Note that this is independent of the setting of the
tt(MENU_COMPLETE) option and does not work with the other menu
completion widgets such as tt(reverse-menu-complete), or
tt(accept-and-menu-complete).
)
findex(_oldlist)
item(tt(_oldlist))(
This completer controls how the standard completion widgets behave
when there is an existing list of completions which may have been
generated by a special completion (i.e. a separately-bound completion
command).  It allows the ordinary completion keys to continue to use the
list of completions thus generated, instead of producing a new list of
ordinary contextual completions.
It should appear in the list of completers before any of
the widgets which generate matches.  It uses two styles: tt(old-list) and
tt(old-menu), see
ifzman(the section `Completion System Configuration' above)\
ifnzman(noderef(Completion System Configuration)).
)
findex(_precommand)
item(tt(_precommand))(
Complete an external command in word-separated arguments, as for
tt(exec) and tt(/usr/bin/env).
)
findex(_prefix)
item(tt(_prefix))(
This completer can be used to try completion with the suffix (everything
after the cursor) ignored.  In other words, the suffix will not be
considered to be part of the word to complete.  The effect is similar
to the tt(expand-or-complete-prefix) command.

The tt(completer) style is used to decide which other completers are to
be called to generate matches.  If this style is unset, the list of
completers set for the current context is used DASH()- except, of course, the
tt(_prefix) completer itself.  Furthermore, if this completer appears
more than once in the list of completers only those completers not
already tried by the last invocation of tt(_prefix) will be called.

For example, consider this global tt(completer) style:

example(zstyle ':completion:*' completer \ 
    _complete _prefix _correct _prefix:foo)

Here, the tt(_prefix) completer tries normal completion but ignoring the
suffix.  If that doesn't generate any matches, and neither does
the call to the tt(_correct) completer after it, tt(_prefix) will 
be called a second time and, now only trying correction with the
suffix ignored.  On the second invocation the completer part of the
context appears as `tt(foo)'.

To use tt(_prefix) as the last resort and try only normal completion
when it is invoked:

example(zstyle ':completion:*' completer _complete ... _prefix
zstyle ':completion::prefix:*' completer _complete)

The tt(add-space) style is also respected.  If it is set to `true' then
tt(_prefix) will insert a space between the matches generated (if any) 
and the suffix.

Note that this completer is only useful if the
tt(COMPLETE_IN_WORD) option is set; otherwise, the cursor will
be moved to the end of the current word before the completion code is
called and hence there will be no suffix.
)
findex(_user_expand)
item(tt(_user_expand))(
This completer behaves similarly to the tt(_expand) completer but
instead performs expansions defined by users.  The styles tt(add-space) and
tt(sort) styles specific to the tt(_expand) completer are usable with
tt(_user_expand) in addition to other styles handled more generally by
the completion system.  The tag tt(all-expansions) is also available.

The expansion depends on the array style tt(user-expand) being defined
for the current context; remember that the context for completers is less
specific than that for contextual completion as the full context has not
yet been determined.  Elements of the array may have one of the following
forms:

startsitem()
sitem(tt($)var(hash))(
var(hash) is the name of an associative array.  Note this is not a full
parameter expression, merely a tt($), suitably quoted to prevent immediate
expansion, followed by the name of an associative array.  If the trial
expansion word matches a key in var(hash), the resulting expansion is the
corresponding value.
)
sitem(var(_func))(
var(_func) is the name of a shell function whose name must begin with
tt(_) but is not otherwise special to the completion system.  The function
is called with the trial word as an argument.  If the word is to be
expanded, the function should set the array tt(reply) to a list of
expansions.  Optionally, it can set tt(REPLY) to a word that will
be used as a description for the set of expansions.
The return status of the function is irrelevant.
)
endsitem()
)
enditem()

texinode(Bindable Commands)(Completion Functions)(Control Functions)(Completion System)
sect(Bindable Commands)
cindex(completion system, bindable commands)

In addition to the context-dependent completions provided, which are
expected to work in an intuitively obvious way, there are a few widgets
implementing special behaviour which can be bound separately to keys.  The
following is a list of these and their default bindings.

startitem()
findex(_bash_completions)
item(tt(_bash_completions))(
This function is used by two widgets, tt(_bash_complete-word) and
tt(_bash_list-choices).  It exists to provide compatibility with
completion bindings in bash.  The last character of the binding determines
what is completed: `tt(!)', command names; `tt($)', environment variables;
`tt(@)', host names; `tt(/)', file names; `tt(~)' user names.  In bash, the
binding preceded by `tt(\e)' gives completion, and preceded by `tt(^X)'
lists options.  As some of these bindings clash with standard zsh
bindings, only `tt(\e~)' and `tt(^X~)' are bound by default.  To add the
rest, the following should be added to tt(.zshrc) after tt(compinit) has
been run:

example(for key in '!' '$' '@' '/' '~'; do
  bindkey "\e$key" _bash_complete-word
  bindkey "^X$key" _bash_list-choices
done)

This includes the bindings for `tt(~)' in case they were already bound to
something else; the completion code does not override user bindings.
)
findex(_correct_filename (^XC))
item(tt(_correct_filename) (tt(^XC)))(
Correct the filename path at the cursor position.  Allows up to six errors
in the name.  Can also be called with an argument to correct
a filename path, independently of zle; the correction is printed on
standard output.
)
findex(_correct_word) (^Xc)
item(tt(_correct_word) (tt(^Xc)))(
Performs correction of the current argument using the usual contextual
completions as possible choices. This stores the string
`tt(correct-word)' in the var(function) field of the context name and
then calls the tt(_correct) completer.
)
findex(_expand_alias (^Xa))
item(tt(_expand_alias) (tt(^Xa)))(
This function can be used as a completer and as a bindable command.
It expands the word the cursor is on if it is an alias.  The types of
alias expanded can be controlled with the styles tt(regular), tt(global)
and tt(disabled).

When used as a bindable command there is one additional feature that
can be selected by setting the tt(complete) style to `true'.  In this
case, if the word is not the name of an alias, tt(_expand_alias) tries
to complete the word to a full alias name without expanding it.  It
leaves the cursor directly after the completed word so that invoking
tt(_expand_alias) once more will expand the now-complete alias name.
)
findex(_expand_word (^Xe))
item(tt(_expand_word) (tt(^Xe)))(
Performs expansion on the current word:  equivalent to the standard
tt(expand-word) command, but using the tt(_expand) completer.  Before
calling it, the var(function) field of the context is set to
`tt(expand-word)'.
)
findex(_generic)
item(tt(_generic))(
This function is not defined as a widget and not bound by
default.  However, it can be used to define a widget and will then
store the name of the widget in the var(function) field of the context 
and call the completion system.  This allows custom completion widgets
with their own set of style settings to be defined easily.  For example, 
to define a widget that performs normal completion and starts
menu selection:

example(zle -C foo complete-word _generic
bindkey '...' foo
zstyle ':completion:foo:*' menu yes select=1)

Note in particular that the tt(completer) style may be set for the context
in order to change the set of functions used to generate possible matches.
If tt(_generic) is called with arguments, those are passed through to
tt(_main_complete) as the list of completers in place of those defined by
the tt(completer) style.
)
findex(_history_complete_word (\e/))
item(tt(_history_complete_word) (tt(\e/)))(
Complete words from the shell's command history. This uses the
tt(list), tt(remove-all-dups), tt(sort), and tt(stop) styles.
)
findex(_most_recent_file (^Xm))
item(tt(_most_recent_file) (tt(^Xm)))(
Complete the name of the most recently modified file matching the pattern
on the command line (which may be blank).  If given a numeric argument
var(N), complete the var(N)th most recently modified file.  Note the
completion, if any, is always unique.
)
findex(_next_tags (^Xn))
item(tt(_next_tags) (tt(^Xn)))(
This command alters the set of matches used to that for the next tag, or
set of tags, either as given by the tt(tag-order) style or as set by
default; these matches would otherwise not be available.
Successive invocations of the command cycle through all possible sets of
tags.
)
findex(_read_comp (^X^R))
item(tt(_read_comp) (tt(^X^R)))(
Prompt the user for a string, and use that to perform completion on the
current word.  There are two possibilities for the string.  First, it can
be a set of words beginning `tt(_)', for example `tt(_files -/)', in which
case the function with any arguments will be called to generate the
completions.  Unambiguous parts of the function name will be completed
automatically (normal completion is not available at this point) until a
space is typed.

Second, any other string will be passed as a set of arguments to
tt(compadd) and should hence be an expression specifying what should
be completed.

A very restricted set of editing commands is available when reading the
string:  `tt(DEL)' and `tt(^H)' delete the last character; `tt(^U)' deletes
the line, and `tt(^C)' and `tt(^G)' abort the function, while `tt(RET)'
accepts the completion.  Note the string is used verbatim as a command
line, so arguments must be quoted in accordance with standard shell rules.

Once a string has been read, the next call to tt(_read_comp) will use the
existing string instead of reading a new one.  To force a new string to be
read, call tt(_read_comp) with a numeric argument.
)
findex(_complete_debug (^X?))
item(tt(_complete_debug) (tt(^X?)))(
This widget performs ordinary completion, but captures in a temporary file
a trace of the shell commands executed by the completion system.  Each
completion attempt gets its own file.  A command to view each of these
files is pushed onto the editor buffer stack.
)
findex(_complete_help (^Xh))
item(tt(_complete_help) (tt(^Xh)))(
This widget displays information about the context names, 
the tags, and the completion functions used 
when completing at the current cursor position. If given a numeric
argument other than tt(1) (as in `tt(ESC-2 ^Xh)'), then the styles
used and the contexts for which they are used will be shown, too.

Note that the information about styles may be incomplete; it depends on the
information available from the completion functions called, which in turn
is determined by the user's own styles and other settings.
)
findex(_complete_help_generic)
item(tt(_complete_help_generic))(
Unlike other commands listed here, this must be created as a normal ZLE
widget rather than a completion widget (i.e. with tt(zle -N)).  It
is used for generating help with a widget bound to the tt(_generic)
widget that is described above.

If this widget is created using the name of the function, as it is by
default, then when executed it will read a key sequence.  This is expected
to be bound to a call to a completion function that uses the tt(_generic)
widget.  That widget will be executed, and information provided in
the same format that the tt(_complete_help) widget displays for
contextual completion.

If the widget's name contains tt(debug), for example if it is created
as `tt(zle -N _complete_debug_generic _complete_help_generic)', it
will read and execute the keystring for a generic widget as before,
but then generate debugging information as done by tt(_complete_debug)
for contextual completion.

If the widget's name contains tt(noread), it will not read a keystring
but instead arrange that the next use of a generic widget run in
the same shell will have the effect as described above.

The widget works by setting the shell parameter
tt(ZSH_TRACE_GENERIC_WIDGET) which is read by tt(_generic).  Unsetting
the parameter cancels any pending effect of the tt(noread) form.

For example, after executing the following:

example(zle -N _complete_debug_generic _complete_help_generic
bindkey '^x:' _complete_debug_generic)

typing `tt(C-x :)' followed by the key sequence for a generic widget
will cause trace output for that widget to be saved to a file.
)
findex(_complete_tag (^Xt))
item(tt(_complete_tag) (tt(^Xt)))(
This widget completes symbol tags created by the tt(etags) or tt(ctags)
programmes (note there is no connection with the completion system's tags)
stored in a file tt(TAGS), in the format used by tt(etags), or tt(tags), in the
format created by tt(ctags).  It will look back up the path hierarchy for
the first occurrence of either file; if both exist, the file tt(TAGS) is
preferred.  You can specify the full path to a tt(TAGS) or tt(tags) file by
setting the parameter tt($TAGSFILE) or tt($tagsfile) respectively.
The corresponding completion tags used are tt(etags) and tt(vtags), after
emacs and vi respectively.
)
enditem()

texinode(Completion Functions)(Completion System Variables)(Bindable Commands)(Completion System)
sect(Utility Functions)
cindex(completion system, utility functions)

Descriptions follow for utility functions that may be
useful when writing completion functions.  If functions are installed in
subdirectories, most of these reside in the
tt(Base) subdirectory.  Like the example 
functions for commands in the distribution, the utility functions
generating matches all follow the convention of returning status zero if they
generated completions and non-zero if no matching completions could be 
added.

startitem()
findex(_absolute_command_paths)
item(tt(_absolute_command_paths))(
This function completes external commands as absolute paths (unlike
tt(_command_names -e) which completes their basenames).  It takes no
arguments.
)
findex(_all_labels)
item(tt(_all_labels) [ tt(-x) ] [ tt(-12VJ) ] var(tag) var(name) var(descr) [ var(command) var(arg) ... ])(
This is a convenient interface to the tt(_next_label) function below,
implementing the loop shown in the tt(_next_label) example.  The
var(command) and its arguments are called to generate the matches.  The
options stored in the parameter var(name) will automatically be inserted
into the var(arg)s passed to the var(command).  Normally, they are put
directly after the var(command), but if one of the var(arg)s is a single
hyphen, they are inserted directly before that.  If the hyphen is the last
argument, it will be removed from the argument list before the
var(command) is called.  This allows tt(_all_labels) to be used in almost all
cases where the matches can be generated by a single call to the
tt(compadd) builtin command or by a call to one of the utility functions.

For example:

example(local expl
...
if _requested foo; then
  ...
  _all_labels foo expl '...' compadd ... - $matches
fi)

Will complete the strings from the tt(matches) parameter, using
tt(compadd) with additional options which will take precedence over
those generated by tt(_all_labels).
)
findex(_alternative)
item(tt(_alternative) [ tt(-O) var(name) ] [ tt(-C) var(name) ] var(spec) ...)(
This function is useful in simple cases where multiple tags are available.
Essentially it implements a loop like the one described for the tt(_tags)
function below.

The tags to use and the action to perform if a tag is requested are
described using the var(spec)s which are of the form:
`var(tag)tt(:)var(descr)tt(:)var(action)'.  The var(tag)s are offered using
tt(_tags) and if the tag is requested, the var(action) is executed with the
given description var(descr).  The var(action)s are those accepted
by the tt(_arguments) function (described below), with the following
exceptions:
startitemize()
itemiz(\
The `tt(->)var(state)' and `tt(=)var(...)' forms are not supported.
)
itemiz(\
The `tt(LPAR()LPAR()a\:bar b\:baz)tt(RPAR()RPAR())' form does not need
the colon to be escaped, since the var(spec)s have no colon-separated fields
after the var(action).
)
enditemize()

For example, the var(action) may be a simple function call:

example(_alternative \ 
    'users:user:_users' \ 
    'hosts:host:_hosts')

offers usernames and hostnames as possible matches,
generated by the tt(_users) and tt(_hosts) functions respectively.

Like tt(_arguments), this function uses tt(_all_labels) to execute 
the actions, which will loop over all sets of tags.  Special handling is
only required if there is an additional valid tag, for example inside a
function called from tt(_alternative).

The option `tt(-O) var(name)' is used in the same way as by the
tt(_arguments) function.  In other words, the elements of the var(name)
array will be passed to tt(compadd) when executing an action.

Like tt(_tags) this function supports the tt(-C) option to give a
different name for the argument context field.
)
findex(_arguments)
redef(SPACES)(0)(tt(ifztexi(NOTRANS(@ @ @ @ @ @ @ @ @ @ @ ))ifnztexi(           )))
xitem(tt(_arguments )[ tt(-nswWCRS) ] [ tt(-A) var(pat) ] [ tt(-O) var(name) ] [ tt(-M) var(matchspec) ])
xitem(SPACES()[ tt(:) ] var(spec) ...)
xitem(tt(_arguments )[ var(opt) ... ] tt(-)tt(-) [ tt(-l) ] [ tt(-i) var(pats) ] [ tt(-s) var(pair) ])
item(SPACES()[ var(helpspec) ...])(
This function can be used to give a complete specification for completion
for a command whose arguments follow standard UNIX option and argument
conventions.

em(Options Overview)

Options to tt(_arguments) itself must be in separate words, i.e. tt(-s -w),
not tt(-sw).  The options are followed by var(spec)s that describe options and
arguments of the analyzed command.  To avoid ambiguity, all
options to tt(_arguments) itself may be separated from the var(spec) forms
by a single colon.

The `tt(-)tt(-)'
form is used to intuit var(spec) forms from the help output of the command
being analyzed, and is described in detail below.  The var(opts) for the
`tt(-)tt(-)' form are otherwise the same options as the first form.  Note
that `tt(-s)' following `tt(-)tt(-)' has a distinct meaning from `tt(-s)'
preceding `tt(-)tt(-)', and both may appear.

The option switches tt(-s), tt(-S), tt(-A), tt(-w), and tt(-W) affect how
tt(_arguments) parses the analyzed command line's options.  These switches are
useful for commands with standard argument parsing.

The options of tt(_arguments) have the following meanings:

startitem()
item(tt(-n))(
With this option, tt(_arguments) sets the parameter tt(NORMARG)
to the position of the first normal argument in the tt($words) array,
i.e. the position after the end of the options.  If that argument
has not been reached, tt(NORMARG) is set to tt(-1).  The caller
should declare `tt(integer NORMARG)' if the tt(-n) option is passed;
otherwise the parameter is not used.
)
item(tt(-s))(
Enable em(option stacking) for single-letter options, whereby multiple
single-letter options may be combined into a single word.  For example,
the two options `tt(-x)' and `tt(-y)' may be combined into
a single word `tt(-xy)'.  By default, every word corresponds to a single
option name (`tt(-xy)' is a single option named `tt(xy)').

Options beginning with a single hyphen or plus sign are eligible for stacking;
words beginning with two hyphens are not.

Note that tt(-s) after tt(-)tt(-) has a different meaning, which is documented
in the segment entitled `Deriving var(spec) forms from the help output'.
)
item(tt(-w))(
In combination with tt(-s), allow option stacking
even if one or more of the options take
arguments.  For example, if tt(-x) takes an argument, with no
tt(-s), `tt(-xy)' is considered as a single (unhandled) option; with
tt(-s), tt(-xy) is an option with the argument `tt(y)'; with both tt(-s)
and tt(-w), tt(-xy) is the option tt(-x) and the option tt(-y) with
arguments to tt(-x) (and to tt(-y), if it takes arguments) still to come
in subsequent words.
)
item(tt(-W))(
This option takes tt(-w) a stage further:  it is possible to
complete single-letter options even after an argument that occurs in the
same word.  However, it depends on the action performed whether options
will really be completed at this point.  For more control, use a
utility function like tt(_guard) as part of the action.
)
item(tt(-C))(
Modify the tt(curcontext) parameter for an action of the form `tt(->)var(state)'.
This is discussed in detail below.
)
item(tt(-R))(
Return status 300 instead of zero when a tt($state) is to
be handled, in the `tt(->)var(string)' syntax.
)
item(tt(-S))(
Do not complete options after a `tt(-)tt(-)' appearing on the line,
and ignore the `tt(-)tt(-)'.  For example, with tt(-S), in the line

example(foobar -x -- -y)

the `tt(-x)' is considered an option, the `tt(-y)' is considered an
argument, and the `tt(-)tt(-)' is considered to be neither.
)
item(tt(-A) var(pat))(
Do not complete options after the first non-option
argument on the line.  var(pat) is a pattern matching
all strings which are not to be taken as arguments.  For example, to make
tt(_arguments) stop completing options after the first normal argument, but
ignoring all strings starting with a hyphen even if they are not described
by one of the var(optspec)s, the form is `tt(-A "-*")'.
)
item(tt(-O) var(name))(
Pass the elements of the array var(name) as arguments to functions called to
execute var(action)s.
This is discussed in detail below.
)
item(tt(-M) var(matchspec))(
Use the match specification var(matchspec) for completing option names and values.
The default var(matchspec) allows partial word completion after `tt(_)' and
`tt(-)', such as completing `tt(-f-b)' to `tt(-foo-bar)'.  The default
var(matchspec) is:
example(tt(r:|[_-]=* r:|=*))
)
item(tt(-0))(
When populating values of the `tt(opt_args)' associative array, don't
backslash-escape colons and backslashes and use NUL rather than colon for
joining multiple values. This option is described in more detail below, under
the heading em(var(spec)s: actions).
)
enditem()

em(var(spec)s: overview)

Each of the following forms is a var(spec) describing individual sets of
options or arguments on the command line being analyzed.

startitem()
xitem(var(n)tt(:)var(message)tt(:)var(action))
item(var(n)tt(::)var(message)tt(:)var(action))(
This describes the var(n)'th normal argument.  The var(message) will be 
printed above the matches generated and the var(action) indicates what can
be completed in this position (see below).  If there are two colons
before the var(message) the argument is optional.  If the
var(message) contains only white space, nothing will be printed above
the matches unless the action adds an explanation string itself.
)
xitem(tt(:)var(message)tt(:)var(action))
item(tt(::)var(message)tt(:)var(action))(
Similar, but describes the em(next) argument, whatever number that
happens to be.  If all arguments are specified in this form in the
correct order the numbers are unnecessary.
)
xitem(tt(*:)var(message)tt(:)var(action))
xitem(tt(*::)var(message)tt(:)var(action))
item(tt(*:::)var(message)tt(:)var(action))(
This describes how arguments (usually non-option arguments, those not
beginning with tt(-) or tt(+)) are to be completed when neither
of the first two forms was provided.  Any number of arguments can
be completed in this fashion.

With two colons before the var(message), the tt(words) special array and
the tt(CURRENT) special parameter are modified to refer only to the
normal arguments when the var(action) is executed or evaluated.  With
three colons before the var(message) they are modified to refer only to
the normal arguments covered by this description.
)
xitem(var(optspec))
item(var(optspec)tt(:)var(...))(
This describes an option.  The colon indicates handling for one or more
arguments to the option; if it is not present, the option is assumed to
take no arguments.

The following forms are available for the initial var(optspec), whether
or not the option has arguments.

startitem()
item(tt(*)var(optspec))(
Here var(optspec) is one of the remaining forms below.  This indicates
the following var(optspec) may be repeated.  Otherwise if the
corresponding option is already present on the command line to the left
of the cursor it will not be offered again.
)
xitem(tt(-)var(optname))
item(tt(+)var(optname))(
In the simplest form the var(optspec) is just the option name beginning
with a minus or a plus sign, such as `tt(-foo)'.  The first argument for
the option (if any) must follow as a em(separate) word directly after the
option.

Either of `tt(-+)var(optname)' and `tt(+-)var(optname)' can be used to
specify that tt(-)var(optname) and tt(+)var(optname) are both valid.

In all the remaining forms, the leading `tt(-)' may be replaced by or
paired with `tt(+)' in this way.
)
item(tt(-)var(optname)tt(-))(
The first argument of the option must come directly after the option name
em(in the same word).  For example, `tt(-foo-:)var(...)' specifies that
the completed option and argument will look like `tt(-foo)var(arg)'.
)
item(tt(-)var(optname)tt(+))(
The first argument may appear immediately after var(optname) in the same
word, or may appear as a separate word after the option.  For example,
`tt(-foo+:)var(...)' specifies that the completed option and argument
will look like either `tt(-foo)var(arg)' or `tt(-foo) var(arg)'.
)
item(tt(-)var(optname)tt(=))(
The argument may appear as the next word, or in same word as the option
name provided that it is separated from it by an equals sign, for
example `tt(-foo=)var(arg)' or `tt(-foo) var(arg)'.
)
item(tt(-)var(optname)tt(=-))(
The argument to the option must appear after an equals sign in the same
word, and may not be given in the next argument.
)
item(var(optspec)tt([)var(explanation)tt(]))(
An explanation string may be appended to any of the preceding forms of
var(optspec) by enclosing it in brackets, as in `tt(-q[query operation])'.

The tt(verbose) style is used to decide whether the explanation strings
are displayed with the option in a completion listing.

If no bracketed explanation string is given but the tt(auto-description)
style is set and only one argument is described for this var(optspec), the
value of the style is displayed, with any appearance of the sequence
`tt(%d)' in it replaced by the var(message) of the first var(optarg)
that follows the var(optspec); see below.
)
enditem()

It is possible for options with a literal `tt(PLUS())' or `tt(=)' to
appear, but that character must be quoted, for example `tt(-\+)'.

Each var(optarg) following an var(optspec) must take one of the
following forms:

startitem()
xitem(tt(:)var(message)tt(:)var(action))
item(tt(::)var(message)tt(:)var(action))(
An argument to the option; var(message) and var(action) are treated as
for ordinary arguments.  In the first form, the argument is mandatory,
and in the second form it is optional.

This group may be repeated for options which take multiple arguments.
In other words,
tt(:)var(message1)tt(:)var(action1)tt(:)var(message2)tt(:)var(action2)
specifies that the option takes two arguments.
)
xitem(tt(:*)var(pattern)tt(:)var(message)tt(:)var(action))
xitem(tt(:*)var(pattern)tt(::)var(message)tt(:)var(action))
item(tt(:*)var(pattern)tt(:::)var(message)tt(:)var(action))(
This describes multiple arguments.  Only the last var(optarg) for
an option taking multiple arguments may be
given in this form.  If the var(pattern) is empty (i.e. tt(:*:)), all
the remaining words on the line are to be completed as described by the
var(action); otherwise, all the words up to and including a word matching
the var(pattern) are to be completed using the var(action).

Multiple colons are treated as for the `tt(*:)var(...)' forms for
ordinary arguments:  when the var(message) is preceded by two colons,
the tt(words) special array and the tt(CURRENT) special parameter are
modified during the execution or evaluation of the var(action) to refer
only to the words after the option.  When preceded by three colons, they
are modified to refer only to the words covered by this description.
)
enditem()
)
enditem()

Any literal colon in an var(optname), var(message), or var(action)
must be preceded by a backslash, `tt(\:)'.

Each of the forms above may be preceded by a list in parentheses
of option names and argument numbers.  If the given option is on
the command line, the options and arguments indicated in parentheses
will not be offered.  For example, 
`tt((-two -three 1)-one:)var(...)' completes the option `tt(-one)'; if this
appears on the command line, the options tt(-two) and tt(-three) and the
first ordinary argument will not be completed after it.
`tt((-foo):)var(...)' specifies an ordinary argument completion;
tt(-foo) will not be completed if that argument is already present.

Other items may appear in the list of excluded options to indicate
various other items that should not be applied when the current
specification is matched: a single star (tt(*)) for the rest arguments
(i.e. a specification of the form `tt(*:)var(...)'); a colon (tt(:))
for all normal (non-option-) arguments; and a hyphen (tt(-)) for all
options.  For example, if `tt((*))' appears before an option and the
option appears on the command line, the list of remaining arguments
(those shown in the above table beginning with `tt(*:)') will not be
completed.

To aid in reuse of specifications, it is possible to precede any of the
forms above with `tt(!)'; then the form will no longer be completed,
although if the option or argument appears on the command line they will
be skipped as normal.  The main use for this is when the arguments are
given by an array, and tt(_arguments) is called repeatedly for more
specific contexts: on the first call `tt(_arguments $global_options)' is
used, and on subsequent calls `tt(_arguments !$^global_options)'.

em(var(spec)s: actions)
COMMENT(If you change this section title, change the references to it in running text.)

In each of the forms above the var(action) determines how
completions should be generated.  Except for the `tt(->)var(string)'
form below, the var(action) will be executed by calling the
tt(_all_labels) function to process all tag labels.  No special handling
of tags is needed unless a function call introduces a new one.

The functions called to execute var(action)s will be called with the
elements of the array named by the `tt(-O) var(name)' option as arguments.
This can be used, for example, to pass the same set of options for the
tt(compadd) builtin to all var(action)s.

The forms for var(action) are as follows.

startitem()
def(SP)(0)(ifztexi(NOTRANS(@ ))ifnztexi( ))\
item(tt(SP())(single unquoted space))(
This is useful where an argument is required but it is not possible or
desirable to generate matches for it.  The
var(message) will be displayed but no completions listed.  Note
that even in this case the colon at the end of the var(message) is
needed; it may only be omitted when neither a var(message)
nor an var(action) is given.
)
item(tt(LPAR())var(item1) var(item2) var(...)tt(RPAR()))(
One of a list of possible matches, for example:

example(tt(:foo:LPAR()foo bar baz)tt(RPAR()))
)
item(tt(((var(item1)\:var(desc1) var(...)))))(
Similar to the above, but with descriptions for each possible match.
Note the backslash before the colon.  For example,

example(tt(:foo:LPAR()LPAR()a\:bar b\:baz)tt(RPAR()RPAR()))

The matches will be listed together with their descriptions if the
tt(description) style is set with the tt(values) tag in the context.
)
item(tt(->)var(string))(
vindex(context, use of)
vindex(line, use of)
vindex(opt_args, use of)
In this form, tt(_arguments) processes the arguments and options and then
returns control to the calling function with parameters set to indicate the
state of processing; the calling function then makes its own arrangements
for generating completions.  For example, functions that implement a state
machine can use this type of action.

Where tt(_arguments) encounters var(action) in the `tt(->)var(string)'
format, it will strip all leading and trailing whitespace from var(string)
and set the array tt(state) to the set of all var(string)s for which an
action is to be performed.  The elements of the array tt(state_descr) are
assigned the corresponding var(message) field from each var(optarg)
containing such an var(action).

By default and in common with all other well behaved completion
functions, _arguments returns status zero if it was able to add matches and
non-zero otherwise. However, if the tt(-R) option is given,
tt(_arguments) will instead return a status of 300 to indicate that
tt($state) is to be handled.

In addition to tt($state) and tt($state_descr), tt(_arguments) also
sets the global
parameters `tt(context)', `tt(line)' and `tt(opt_args)' as described
below, and does not reset any changes made to the special parameters
such as tt(PREFIX) and tt(words).  This gives the calling function the
choice of resetting these parameters or propagating changes in them.

A function calling tt(_arguments) with at least
one action containing a `tt(->)var(string)' must therefore declare
appropriate local parameters:

example(local context state state_descr line
typeset -A opt_args)

to prevent tt(_arguments) from altering the global environment.
)
item(tt({)var(eval-string)tt(}))(
vindex(expl, use of)
A string in braces is evaluated as shell code to generate matches.  If the
var(eval-string) itself does not begin with an opening parenthesis or
brace it is split into separate words before execution.
)
item(tt(= )var(action))(
If the var(action) starts with `tt(= )' (an equals sign followed by a
space), tt(_arguments) will insert the contents of the var(argument)
field of the current context as the new first element in the tt(words) 
special array and increment the value of the tt(CURRENT) special
parameter.  This has the effect of inserting a dummy word onto the
completion command line while not changing the point at which completion is
taking place.

This is most useful with one of the specifiers that restrict the words on
the command line on which the var(action) is to operate (the two- and
three-colon forms above).  One particular use is when an var(action) itself
causes tt(_arguments) on a restricted range; it is necessary to use this
trick to insert an appropriate command name into the range for the second
call to tt(_arguments) to be able to parse the line.
)
xitem(var(tt(SP())word...))
item(var(word...))(
This covers all forms other than those above.  If the var(action)
starts with a space, the remaining list of words will be invoked unchanged.

Otherwise it will be invoked with some extra strings placed after the
first word; these are to be passed down as options to the tt(compadd)
builtin.  They ensure that the state specified by tt(_arguments), in
particular the descriptions of options and arguments, is correctly passed
to the completion command.  These additional arguments
are taken from the array parameter `tt(expl)'; this will be set up
before executing the var(action) and hence may be referred to inside it,
typically in an expansion of the form `tt($expl[@])' which preserves empty
elements of the array.
)
enditem()

During the performance of the action the array `tt(line)' will be set to
the normal arguments from the command line, i.e. the words from the
command line after the command name excluding all options and their
arguments.  Options are stored in the associative array
`tt(opt_args)' with option names as keys and their arguments as
the values.  By default, all colons and backslashes in the value are escaped
with backslashes, and if an option has multiple arguments (for example, when
using an var(optspec) of the form `tt(*)var(optspec)'), they are joined with
(unescaped) colons.  However, if the tt(-0) option was passed, no backslash
escaping is performed, and multiple values are joined with NUL bytes.  For
example, after `tt(zsh -o foo:foo -o bar:bar -o <TAB>)', the contents of
`tt(opt_args)' would be

example(typeset -A opt_args=( [-o]='foo\:foo:bar\:bar:' ))

by default, and

example(typeset -A opt_args=( [-o]=$'foo:foo\x00bar:bar\x00' ))

if tt(_arguments) had been called with the tt(-0) option.

The parameter `tt(context)' is set when returning to the calling function
to perform an action of the form `tt(->)var(string)'.  It is set to an
array of elements corresponding to the elements of tt($state).  Each
element is a suitable name for the argument field of the context: either a
string of the form `tt(option)var(-opt)tt(-)var(n)' for the var(n)'th
argument of the option var(-opt), or a string of the form
`tt(argument-)var(n)' for the var(n)'th argument.  For `rest' arguments,
that is those in the list at the end not handled by position, var(n) is the
string `tt(rest)'.  For example, when completing the argument of the tt(-o)
option, the name is `tt(option-o-1)', while for the second normal
(non-option-) argument it is `tt(argument-2)'.

Furthermore, during the evaluation of the var(action) the context name in
the tt(curcontext) parameter is altered to append the same string that is
stored in the tt(context) parameter.

The option tt(-C) tells tt(_arguments) to modify the tt(curcontext)
parameter for an action of the form `tt(->)var(state)'.  This is the
standard parameter used to keep track of the current context.  Here it
(and not the tt(context) array) should be made local to the calling
function to avoid passing back the modified value and should be
initialised to the current value at the start of the function:

example(local curcontext="$curcontext")

This is useful where it is not possible for multiple states to be valid
together.

em(Grouping Options)

Options can be grouped to simplify exclusion lists. A group is
introduced with `tt(PLUS())' followed by a name for the group in the
subsequent word. Whole groups can then be referenced in an exclusion
list or a group name can be used to disambiguate between two forms of
the same option. For example:

example(_arguments \ 
    '(group2--x)-a' \ 
  PLUS() group1 \ 
    -m \ 
    '(group2)-n' \ 
  PLUS() group2 \ 
    -x -y)

If the name of a group is specified in the form
`tt(LPAR())var(name)tt(RPAR())' then only one value from that group
will ever be completed; more formally, all specifications are mutually
exclusive to all other specifications in that group. This is useful for
defining options that are aliases for each other. For example:

example(_arguments \ 
    -a -b \ 
  PLUS() '(operation)' \ 
    {-c,--compress}'[compress]' \ 
    {-d,--decompress}'[decompress]' \ 
    {-l,--list}'[list]')

If an option in a group appears on the command line, it is stored in the
associative array `tt(opt_args)' with 'var(group)tt(-)var(option)'
as a key.  In the example above, a key `tt(operation--c)' is used if the option
`tt(-c)' is present on the command line.

em(Specifying Multiple Sets of Arguments)

It is possible to specify multiple sets of options and arguments with
the sets separated by single hyphens. This differs from groups in that
sets are considered to be mutually exclusive of each other.

Specifications before the first set and from any group are common to
all sets. For example:

example(_arguments \ 
    -a \ 
  - set1 \ 
    -c \ 
  - set2 \ 
    -d \ 
    ':arg:(x2 y2)')

This defines two sets.  When the command line contains the option
`tt(-c)', the `tt(-d)' option and the argument will not be considered
possible completions.  When it contains `tt(-d)' or an argument, the
option `tt(-c)' will not be considered.  However, after `tt(-a)'
both sets will still be considered valid.

As for groups, the name of a set may appear in exclusion lists, either
alone or preceding a normal option or argument specification.

The completion code has to parse the command line separately for each
set. This can be slow so sets should only be used when necessary.
A useful alternative is often an option specification with rest-arguments
(as in `tt(-foo:*:...)'); here the option tt(-foo) swallows up all
remaining arguments as described by the var(optarg) definitions.

em(Deriving var(spec) forms from the help output)

The option `tt(-)tt(-)' allows tt(_arguments) to work out the names of long
options that support the `tt(-)tt(-help)' option which is standard in many
GNU commands.  The command word is called with the argument
`tt(-)tt(-help)' and the output examined for option names.  Clearly, it can
be dangerous to pass this to commands which may not support this option as
the behaviour of the command is unspecified.

In addition to options, `tt(_arguments -)tt(-)' will try to deduce the
types of arguments available for options when the form
`tt(-)tt(-)var(opt)tt(=)var(val)' is valid.  It is also possible to provide
hints by examining the help text of the command and adding var(helpspec) of
the form `var(pattern)tt(:)var(message)tt(:)var(action)'; note that other
tt(_arguments) var(spec) forms are not used.  The var(pattern) is matched
against the help text for an option, and if it matches the var(message) and
var(action) are used as for other argument specifiers.  The special case
of `tt(*:)' means both var(message) and var(action) are empty, which has
the effect of causing options having no description in the help output to
be ordered in listings ahead of options that have a description.

For example:

example(_arguments -- '*\*:toggle:(yes no)' \ 
              '*=FILE*:file:_files' \ 
              '*=DIR*:directory:_files -/' \ 
              '*=PATH*:directory:_files -/')

Here, `tt(yes)' and `tt(no)' will be completed as the argument of
options whose description ends in a star; file names will be completed for
options that contain the substring `tt(=FILE)' in the description; and
directories will be completed for options whose description contains
`tt(=DIR)' or `tt(=PATH)'.  The last three are in fact the default and so
need not be given explicitly, although it is possible to override the use
of these patterns.  A typical help text which uses this feature is:

example(  -C, --directory=DIR          change to directory DIR)

so that the above specifications will cause directories to be completed
after `tt(-)tt(-directory)', though not after `tt(-C)'.

Note also that tt(_arguments) tries to find out automatically if the
argument for an option is optional.  This can be specified explicitly by
doubling the colon before the var(message).

If the var(pattern) ends in `tt((-))', this will be removed from the
pattern and the var(action) will be used only directly after the
`tt(=)', not in the next word.  This is the behaviour of a normal
specification defined with the form `tt(=-)'.

By default, the command (with the option `tt(--help)') is run after
resetting all the locale categories (except for tt(LC_CTYPE)) to `tt(C)'.
If the localized help output is known to work, the option `tt(-l)' can
be specified after the `tt(_arguments -)tt(-)' so that the command is
run in the current locale.

The `tt(_arguments -)tt(-)' can be followed by the option `tt(-i)
var(patterns)' to give patterns for options which are not to be
completed.  The patterns can be given as the name of an array parameter
or as a literal list in parentheses.  For example,

example(_arguments -- -i \ 
    "LPAR()--(en|dis)able-FEATURE*RPAR()")

will cause completion to ignore the options
`tt(-)tt(-enable-FEATURE)' and `tt(-)tt(-disable-FEATURE)' (this example is
useful with GNU tt(configure)).

The `tt(_arguments -)tt(-)' form can also be followed by the option `tt(-s)
var(pair)' to describe option aliases.  The var(pair) consists of a list
of alternating patterns and corresponding replacements, enclosed in parens
and quoted so that it forms a single argument word in the tt(_arguments)
call.

For example, some tt(configure)-script help output describes options only
as `tt(-)tt(-enable-foo)', but the script also accepts the negated form
`tt(-)tt(-disable-foo)'.  To allow completion of the second form:

example(_arguments -- -s "LPAR()(#s)--enable- --disable-RPAR()")

em(Miscellaneous notes)

Finally, note that tt(_arguments) generally expects to be the primary
function handling any completion for which it is used.  It may have side
effects which change the treatment of any matches added by other functions
called after it.  To combine tt(_arguments) with other functions, those
functions should be called either before tt(_arguments), as an var(action)
within a var(spec), or in handlers for `tt(->)var(state)' actions.

Here is a more general example of the use of tt(_arguments):

example(_arguments '-l+:left border:' \ 
           '-format:paper size:(letter A4)' \ 
           '*-copy:output file:_files::resolution:(300 600)' \ 
           ':postscript file:_files -g \*.\(ps\|eps\)' \ 
           '*:page number:')

This describes three options: `tt(-l)', `tt(-format)', and
`tt(-copy)'.  The first takes one argument described as `var(left
border)' for which no completion will be offered because of the empty
action.  Its argument may come directly after the `tt(-l)' or it may be 
given as the next word on the line.

The `tt(-format)' option takes one
argument in the next word, described as `var(paper size)' for which
only the strings `tt(letter)' and `tt(A4)' will be completed.

The `tt(-copy)' option may appear more than once on the command line and
takes two arguments.  The first is mandatory and will be completed as a
filename.  The second is optional (because of the second colon before
the description `var(resolution)') and will be completed from the strings
`tt(300)' and `tt(600)'.

The last two descriptions say what should be completed as
arguments.  The first describes the first argument as a
`var(postscript file)' and makes files ending in `tt(ps)' or `tt(eps)' 
be completed.  The last description gives all other arguments the
description `var(page number)' but does not offer completions.
)
findex(_cache_invalid)
item(tt(_cache_invalid) var(cache_identifier))(
This function returns status zero if the completions cache corresponding to
the given cache identifier needs rebuilding.  It determines this by
looking up the tt(cache-policy) style for the current context.
This should provide a function name which is run with the full path to the
relevant cache file as the only argument.

Example:

example(_example_caching_policy () {
    # rebuild if cache is more than a week old
    local -a oldp
    oldp=( "$1"(Nm+7) )
    (( $#oldp ))
})
)
findex(_call_function)
item(tt(_call_function) var(return) var(name) [ var(arg) ... ])(
If a function var(name) exists, it is called with the arguments
var(arg)s.  The var(return) argument gives the name of a parameter in which
the return status from the function var(name) should be stored; if var(return)
is empty or a single hyphen it is ignored.

The return status of tt(_call_function) itself is zero if the function
var(name) exists and was called and non-zero otherwise.
)
findex(_call_program)
item(tt(_call_program) [ tt(-l) ] [ tt(-p) ] var(tag) var(string) ...)(
This function provides a mechanism for the user to override the use of an
external command.  It looks up the tt(command) style with the supplied
var(tag).  If the style is set, its value is used as the command to
execute.  The var(string)s from the call to tt(_call_program), or from the
style if set, are concatenated with spaces between them and the resulting
string is evaluated.  The return status is the return status of the command
called.

By default, the command is run in an environment where all the locale
categories (except for tt(LC_CTYPE)) are reset to `tt(C)' by calling the
utility function tt(_comp_locale) (see below). If the option `tt(-l)' is
given, the command is run with the current locale.

If the option `tt(-p)' is supplied it indicates that the command
output is influenced by the permissions it is run with. If the
tt(gain-privileges) style is set to true, tt(_call_program) will make
use of commands such as tt(sudo), if present on the command-line, to
match the permissions to whatever the final command is likely to run
under. When looking up the tt(gain-privileges) and tt(command) styles,
the command component of the zstyle context will end with a slash
(`tt(/)') followed by the command that would be used to gain privileges.
)
findex(_combination)
item(tt(_combination) [ tt(-s) var(pattern) ] var(tag) var(style) var(spec) ... var(field) var(opts) ...)(
This function is used to complete combinations of values,  for example
pairs of hostnames and usernames.  The var(style) argument gives the style
which defines the pairs; it is looked up in a context with the var(tag)
specified.

The style name consists of field names separated by hyphens, for example
`tt(users-hosts-ports)'.  For each field for a value is already known, a
var(spec) of the form `var(field)tt(=)var(pattern)' is given.  For example,
if the command line so far specifies a user `tt(pws)', the argument
`tt(users=pws)' should appear.

The next argument with no equals sign is taken as the name of the field
for which completions should be generated (presumably not one of the
var(field)s for which the value is known).

The matches generated will be taken from the value of the style.  These
should contain the possible values for the combinations in the appropriate
order (users, hosts, ports in the example above).
The values for the different fields are separated by colons.  This
can be altered with the option tt(-s) to tt(_combination) which specifies a
pattern.  Typically this is a character class, as for example
`tt(-s "[:@]")' in the case of the tt(users-hosts) style.    Each
`var(field)tt(=)var(pattern)' specification restricts the
completions which apply to elements of the style with appropriately
matching fields.

If no style with the given name is defined for the given tag,
or if none of the strings in style's value match, but a
function name of the required field preceded by an
underscore is defined, that function will be called to generate the
matches.  For example, if there is no `tt(users-hosts-ports)' or no
matching hostname when a host is required, the function `tt(_hosts)' will
automatically be called.

If the same name is used for more than one field, in both the
`var(field)tt(=)var(pattern)' and the argument that gives the name of the
field to be completed, the number of the field (starting with one) may
be given after the fieldname, separated from it by a colon.

All arguments after the required field name are passed to
tt(compadd) when generating matches from the style value, or to 
the functions for the fields if they are called.
)
findex(_command_names)
item(tt(_command_names) [ tt(-e) | tt(-) ])(
This function completes words that are valid at command position: names of
aliases, builtins, hashed commands, functions, and so on.  With the tt(-e)
flag, only hashed commands are completed.  The tt(-) flag is ignored.
)
findex(_comp_locale)
item(tt(_comp_locale))(
This function resets all the locale categories other than tt(LC_CTYPE) to
`tt(C)' so that the output from external commands can be easily analyzed by
the completion system. tt(LC_CTYPE) retains the current value (taking
tt(LC_ALL) and tt(LANG) into account), ensuring that non-ASCII characters
in file names are still handled properly.

This function should normally be run only in a subshell, because the new
locale is exported to the environment. Typical usage would be
`tt($LPAR()_comp_locale; )var(command) ...tt(RPAR())'.
)
findex(_completers)
item(tt(_completers) [ tt(-p) ])(
This function completes names of completers.

startitem()
item(tt(-p))(
Include the leading underscore (`tt(_)') in the matches.
)
enditem()
)
findex(_default)
item(tt(_default))(
This function corresponds to the tt(-default-) special context which is
applied where no completion is defined.  It is useful to call it under
certain error conditions such as completion after an unrecognised
subcommand.  This applies the concept of graceful degradation to the
completion system, allowing it to fallback on basic completion of
commonly useful things like filenames.
)
findex(_describe)
redef(SPACES)(0)(tt(ifztexi(NOTRANS(@ @ @ @ @ @ @ @ @ @ ))ifnztexi(          )))
xitem(tt(_describe )[tt(-12JVx)] [ tt(-oO) | tt(-t) var(tag) ] var(descr) var(name1) [ var(name2) ] [ var(opt) ... ])
item(SPACES()[ tt(-)tt(-) var(name1) [ var(name2) ] [ var(opt) ... ] ... ])(
This function associates completions with descriptions.
Multiple groups separated by tt(-)tt(-) can be supplied, potentially with
different completion options var(opt)s.

The var(descr) is taken as a string to display above the matches if the
tt(format) style for the tt(descriptions) tag is set.  This is followed by
one or two names of arrays followed by options to pass to tt(compadd).  The
array var(name1) contains the possible completions with their descriptions in
the form `var(completion)tt(:)var(description)'.  Any literal colons in
var(completion) must be quoted with a backslash.  If a var(name2) is
given, it should have the same number of elements as var(name1); in this
case the corresponding elements are added as possible completions instead
of the var(completion) strings from var(name1).  The completion list
will retain the descriptions from var(name1).  Finally, a set of
completion options can appear.

If the option `tt(-o)' appears before the first argument, the matches added
will be treated as names of command options (N.B. not shell options),
typically following a `tt(-)', `tt(-)tt(-)' or `tt(+)' on the command
line.  In this case tt(_describe) uses the tt(prefix-hidden),
tt(prefix-needed) and tt(verbose) styles to find out if the strings should
be added as completions and if the descriptions should be shown.  Without
the `tt(-o)' option, only the tt(verbose) style is used to decide how
descriptions are shown.  If `tt(-O)' is used instead of `tt(-o)', command
options are completed as above but tt(_describe) will not handle the
tt(prefix-needed) style.

With the tt(-t) option a var(tag) can be specified.  The default is
`tt(values)' or, if the tt(-o) option is given, `tt(options)'.

The options tt(-1), tt(-2), tt(-J), tt(-V), tt(-x) are passed to
tt(_next_label).

If selected by the tt(list-grouped) style, strings with the same
description will appear together in the list.

tt(_describe) uses the tt(_all_labels) function to generate the matches, so
it does not need to appear inside a loop over tag labels.
)
findex(_description)
item(tt(_description) [ tt(-x) ] [ tt(-12VJ) ] var(tag) var(name) var(descr) [ var(spec) ... ])(
This function is not to be confused with the previous one; it is used as
a helper function for creating options to tt(compadd).  It is buried
inside many of the higher level completion functions and so often does
not need to be called directly.

The styles listed below are tested in the current context using the
given var(tag).  The resulting options for tt(compadd) are put into the
array named var(name) (this is traditionally `tt(expl)', but this
convention is not enforced).  The description for the corresponding set
of matches is passed to the function in var(descr).

The styles tested are: tt(format), tt(hidden), tt(matcher),
tt(ignore-line), tt(ignored-patterns), tt(group-name) and tt(sort).
The tt(format) style is first tested for the given var(tag) and then for
the tt(descriptions) tag if no value was found, while the remainder are
only tested for the tag given as the first argument.  The function also
calls tt(_setup) which tests some more styles.

The string returned by the tt(format) style (if any) will be modified so
that the sequence `tt(%d)' is replaced by the var(descr) given as the third
argument without any leading or trailing white space.  If, after
removing the white space, the var(descr) is the empty string, the format
style will not be used and the options put into the var(name) array will
not contain an explanation string to be displayed above the matches.

If tt(_description) is called with more than three arguments,
the additional var(spec)s should be of the form `var(char)tt(:)var(str)'.
These supply escape sequence replacements for the tt(format) style:
every appearance of `tt(%)var(char)' will be replaced by var(string).
If no additional var(spec)s are given but the description in var(descr)
conforms to a common form then further escape sequences are set for
elements of that description.  These elements correspond to a default
value (`tt(%o)'), the units (`tt(%m)') range of acceptable values
(`tt(%r)') and the remaining initial part of the description (`tt(%h)').
The form the description takes consists of specifying the units and
range in parentheses and the default value in square brackets, for
example:

example(_description times expl 'timeout (seconds) (0-60) [20]')

It is possible to use tt(zformat) conditional expressions when styling
these elements. So, for example, to add `tt(default:)' as a tag but only
when there is a default value to show, the tt(format) style might
include `tt(%(o.default: %o.))'.

If the tt(-x) option is given, the description will be passed to
tt(compadd) using the tt(-x) option instead of the default tt(-X).  This
means that the description will be displayed even if there are no
corresponding matches.

The options placed in the array var(name) take account of the
tt(group-name) style, so matches are placed in a separate group where
necessary.  The group normally has its elements sorted (by passing the
option tt(-J) to tt(compadd)), but if an option starting with `tt(-V)',
`tt(-J)', `tt(-1)', or `tt(-2)' is passed to tt(_description), that
option will be included in the array.  Hence it is possible for the
completion group to be unsorted by giving the option `tt(-V)',
`tt(-1V)', or `tt(-2V)'.

In most cases, the function will be used like this:

example(local expl
_description files expl file
compadd "$expl[@]" - "$files[@]")

Note the use of the parameter tt(expl), the hyphen, and the list of
matches.  Almost all calls to tt(compadd) within the completion system use
a similar format; this ensures that user-specified styles are correctly
passed down to the builtins which implement the internals of completion.
)
findex(_dir_list)
item(tt(_dir_list) [ tt(-s) var(sep) ] [ tt(-S) ])(
Complete a list of directory names separated by colons
(the same format as tt($PATH)).

startitem()
item(tt(-s) var(sep))(
Use var(sep) as separator between items.
var(sep) defaults to a colon (`tt(:)').
)
item(tt(-S))(
Add var(sep) instead of slash (`tt(/)') as an autoremoveable suffix.
)
enditem()
)
findex(_dispatch)
item(tt(_dispatch) var(context string) ...)(
This sets the current context to var(context) and looks for completion
functions to handle this context by hunting through the list of command
names or special contexts (as described above for tt(compdef))
given as var(string)s.  The first completion function to be defined
for one of the contexts in the list is used to generate matches.
Typically, the last var(string) is tt(-default-) to cause the function
for default completion to be used as a fallback.

The function sets the parameter
tt($service) to the var(string) being tried, and sets
the var(context/command) field (the fourth) of the tt($curcontext)
parameter to the var(context) given as the first argument.
)
findex(_email_addresses)
item(tt(_email_addresses) [ tt(-c) ] [ tt(-n) var(plugin) ])(
Complete email addresses.  Addresses are provided by plugins.

startitem()
item(tt(-c))(
Complete bare tt(localhost@domain.tld) addresses, without a name part or
a comment.
Without this option, RFC822 `var(Firstname Lastname) tt(<)var(address)tt(>)'
strings are completed.
)
item(tt(-n) var(plugin))(
Complete aliases from var(plugin).  
)
COMMENT(Intentionally leaving tt(-s) undocumented: new code should use
tt(_sequence) instead.)\
enditem()

The following plugins are available by default:
tt(_email-ldap) (see the tt(filter) style),
tt(_email-local) (completes var(user)tt(@)var(hostname) Unix addresses),
tt(_email-mail) (completes aliases from tt(~/.mailrc)),
tt(_email-mush),
tt(_email-mutt),
and
tt(_email-pine).

Addresses from the tt(_email-)var(foo) plugin are added under the
tag `tt(email-)var(foo)'.

em(Writing plugins)

Plugins are written as separate functions with names starting with `tt(_email-)'.
They are invoked with the tt(-c) option and tt(compadd) options.
They should either do their own completion or
set the tt($reply) array to a list of `var(alias)tt(:)var(address)' elements and return tt(300).
New plugins will be picked up and run automatically.
)
findex(_files)
item(tt(_files))(
The function tt(_files) is a wrapper around tt(_path_files). It supports
all of the same functionality, with some enhancements DASH()- notably, it
respects the tt(list-dirs-first) style, and it allows users to override
the behaviour of the tt(-g) and tt(-/) options with the tt(file-patterns)
style. tt(_files) should therefore be preferred over tt(_path_files) in
most cases.

This function accepts the full set of options allowed by
tt(_path_files), described below.
)
findex(_gnu_generic)
item(tt(_gnu_generic))(
This function is a simple wrapper around the tt(_arguments) function
described above.  It can be used to determine automatically the long
options understood by commands that produce a list when passed the
option `tt(-)tt(-help)'.  It is intended to be used as a top-level
completion function in its own right.  For example, to enable option
completion for the commands tt(foo) and tt(bar), use

example(compdef _gnu_generic foo bar)

after the call to tt(compinit).

The completion system as supplied is conservative in its use of this
function, since it is important to be sure the command understands the
option `tt(-)tt(-help)'.
)
findex(_guard)
item(tt(_guard) [ var(options) ] var(pattern descr))(
This function displays var(descr) if var(pattern) matches the string to
be completed.  It is intended to be used in the var(action) for the
specifications passed to tt(_arguments) and similar functions.

The return status is zero if the message was displayed and the word to
complete is not empty, and non-zero otherwise.

The var(pattern) may be preceded by any of the options understood by
tt(compadd) that are passed down from tt(_description), namely tt(-M),
tt(-J), tt(-V), tt(-1), tt(-2), tt(-n), tt(-F) and tt(-X).  All of these
options will be ignored.  This fits in conveniently with the
argument-passing conventions of actions for tt(_arguments).

As an example, consider a command taking the options tt(-n) and
tt(-none), where tt(-n) must be followed by a numeric value in the
same word.  By using:

example(_arguments '-n-: :_guard "[0-9]#" "numeric value"' '-none')

tt(_arguments) can be made to both display the message `tt(numeric
value)' and complete options after `tt(-n<TAB>)'.  If the `tt(-n)' is
already followed by one or more digits (the pattern passed to
tt(_guard)) only the message will be displayed; if the `tt(-n)' is
followed by another character, only options are completed.
)
findex(_message)
xitem(tt(_message) [ tt(-r12) ] [ tt(-VJ) var(group) ] var(descr))
item(tt(_message -e) [ var(tag) ] var(descr))(
The var(descr) is used in the same way as the third
argument to the tt(_description) function, except that the resulting
string will always be shown whether or not matches were
generated.  This is useful for displaying a help message in places where
no completions can be generated.

The tt(format) style is examined with the tt(messages) tag to find a
message; the usual tag, tt(descriptions), is used only if the style is
not set with the former.

If the tt(-r) option is given, no style is used; the var(descr) is
taken literally as the string to display.  This is most useful
when the var(descr) comes from a pre-processed argument list
which already contains an expanded description.  Note that this
option does not disable the `tt(%)'-sequence parsing done by
tt(compadd).

The tt(-12VJ) options and the var(group) are passed to tt(compadd) and
hence determine the group the message string is added to.

The second tt(-e) form gives a description for completions with the tag
var(tag) to be shown even if there are no matches for that tag.  This form
is called by tt(_arguments) in the event that there is no action for an
option specification.  The tag can be omitted and if so the tag is taken
from the parameter tt($curtag); this is maintained by the completion
system and so is usually correct.  Note that if there are no matches at
the time this function is called, tt(compstate[insert]) is cleared, so
additional matches generated later are not inserted on the command line.
)
findex(_multi_parts)
item(tt(_multi_parts) [ tt(-i) ] var(sep) var(array))(
The argument var(sep) is a separator character.
The var(array) may be either the
name of an array parameter or a literal array in the form
`tt(LPAR()foo bar)tt(RPAR())', a parenthesised list of words separated
by whitespace.  The possible completions are the
strings from the array.  However, each chunk delimited by var(sep) will be
completed separately.  For example, the tt(_tar) function uses
`tt(_multi_parts) tt(/) var(patharray)' to complete partial file paths
from the given array of complete file paths.

The tt(-i) option causes tt(_multi_parts) to insert a unique match even
if that requires multiple separators to be inserted.  This is not usually
the expected behaviour with filenames, but certain other types of
completion, for example those with a fixed set of possibilities, may be
more suited to this form.

Like other utility functions, this function accepts the `tt(-V)',
`tt(-J)', `tt(-1)', `tt(-2)', `tt(-n)', `tt(-f)', `tt(-X)', `tt(-M)',
`tt(-P)', `tt(-S)', `tt(-r)', `tt(-R)', and `tt(-q)' options and passes
them to the tt(compadd) builtin.
)
findex(_next_label)
item(tt(_next_label) [ tt(-x) ] [ tt(-12VJ) ] var(tag) var(name) var(descr) [ var(option) ... ])(
This function is used to implement the loop over different tag
labels for a particular tag as described above for the tt(tag-order)
style.  On each call it checks to see if there are any more tag labels; if
there is it returns status zero, otherwise non-zero.
As this function requires a current tag to be set, it must always follow
a call to tt(_tags) or tt(_requested).

The tt(-x12VJ) options and the first three arguments are passed to the
tt(_description) function.  Where appropriate the var(tag) will be
replaced by a tag label in this call.  Any description given in
the tt(tag-order) style is preferred to the var(descr) passed to
tt(_next_label).

The var(option)s given after the var(descr)
are set in the parameter given by var(name), and hence are to be passed
to tt(compadd) or whatever function is called to add the matches.

Here is a typical use of this function for the tag tt(foo).  The call to
tt(_requested) determines if tag tt(foo) is required at all; the loop
over tt(_next_label) handles any labels defined for the tag in the
tt(tag-order) style.

example(local expl ret=1
...
if _requested foo; then
  ...
  while _next_label foo expl '...'; do
    compadd "$expl[@]" ... && ret=0
  done
  ...
fi
return ret)
)
findex(_normal)
item(tt(_normal) [ tt(-P) | tt(-p) var(precommand) ])(
This is the standard function called to handle completion outside
any special tt(-)var(context)tt(-).  It is called both to complete the command
word and also the arguments for a command.  In the second case,
tt(_normal) looks for a special completion for that command, and if
there is none it uses the completion for the tt(-default-) context.

A second use is to reexamine the command line specified by the tt($words)
array and the tt($CURRENT) parameter after those have been modified.
For example, the function tt(_precommand), which
completes after precommand specifiers such as tt(nohup), removes the
first word from the tt(words) array, decrements the tt(CURRENT) parameter,
then calls `tt(_normal -p $service)'.  The effect is that
`tt(nohup) var(cmd ...)' is treated in the same way as `var(cmd ...)'.

startitem()
item(tt(-P))(
Reset the list of precommands. This option should be used if completing
a command line which allows internal commands (e.g. builtins and
functions) regardless of prior precommands (e.g. `tt(zsh -c)').
)
item(tt(-p) var(precommand))(
Append var(precommand) to the list of precommands. This option should be
used in nearly all cases in which tt(-P) is not applicable.
)
enditem()

If the command name matches one of the patterns given by one of the
options tt(-p) or tt(-P) to tt(compdef), the corresponding completion
function is called and then the parameter tt(_compskip) is
checked.  If it is set completion is terminated at that point even if
no matches have been found.  This is the same effect as in the
tt(-first-) context.
)
findex(_numbers)
item(tt(_numbers) [ var(option) ... ] [ var(description) ] [ var(suffix) ... ])(
This can be used where a number is followed by a suffix to indicate the units.
The unit suffixes are completed and can also be included in the description
used when completion is invoked for the preceding number.

In addition to common tt(compadd) options, tt(_numbers) accepts the following
options:

startitem()
item(tt(-t) var(tag))(
Specify a tag to use instead of the default of tt(numbers).
)
item(tt(-u) var(units))(
Indicate the default units for the number, e.g. tt(bytes).
)
item(tt(-l) var(min))(
Specify the lowest possible value for the number.
)
item(tt(-m) var(max))(
Specify the highest possible value for the number.
)
item(tt(-d) var(default))(
Specify the default value.
)
item(tt(-N))(
Allow negative numbers.  This is implied if the range includes a negative.
)
item(tt(-f))(
Allow decimal numbers.
)
enditem()

Where a particular suffix represents the default units for a number, it
should be prefixed with a colon.  Additionally, suffixes can be followed
by a colon and a description.  So for example, the following allows the
age of something to be specified, either in seconds or with an optional
suffix with a longer unit of time:

example(_numbers -u seconds age :s:seconds m:minutes h:hours d:days)

It is typically helpful for units to be presented in order of magnitude
when completed.  To facilitate this, the order in which they are given
is preserved.

When the tt(format) style is looked up with the tt(descriptions) tag or
the tag specified with tt(-t), the list of suffixes is available as a
`tt(%x)' escape sequence. This is in addition to the usual sequences
documented under the tt(format) style. The form this list takes can also
be configured. To this end, the tt(format) style is first looked up with
the tag tt(unit-suffixes). The retrieved format is applied to each
suffix in turn and the results are then concatenated to form the
completed list. For the tt(unit-suffixes) format, `tt(%x)' expands to
the individual suffix and `tt(%X)' to its description. tt(%d)' indicates
a default suffix and can be used in a condition. The index and reverse
index are set in `tt(%i)' and `tt(%r)' respectively and are useful for
text included only with the first and last suffixes in the list. So for
example, the following joins the suffixes together as a comma-separated
list:

example(zstyle ':completion:*:unit-suffixes' format '%x%(r::,)')
)

findex(_options)
item(tt(_options))(
This can be used to complete the names of shell options.  It provides a
matcher specification that ignores a leading `tt(no)', ignores
underscores and allows upper-case letters to
match their lower-case counterparts (for example, `tt(glob)',
`tt(noglob)', `tt(NO_GLOB)' are all completed).  Any arguments
are propagated to the tt(compadd) builtin.
)
findex(_options_set)
findex(_options_unset)
item(tt(_options_set) and tt(_options_unset))(
These functions complete only set or unset options, with the same
matching specification used in the tt(_options) function.

Note that you need to uncomment a few lines in the tt(_main_complete)
function for these functions to work properly.  The lines in question
are used to store the option settings in effect before the completion
widget locally sets the options it needs.  Hence these functions are not
generally used by the completion system.
)
findex(_parameters)
item(tt(_parameters))(
This is used to complete the names of shell parameters.

The option `tt(-g) var(pattern)' limits the completion to parameters
whose type matches the var(pattern).  The type of a parameter is that
shown by `tt(print ${(t))var(param)tt(})', hence judicious use of
`tt(*)' in var(pattern) is probably necessary.

All other arguments are passed to the tt(compadd) builtin.
)
findex(_path_files)
item(tt(_path_files))(
This function is used throughout the completion system
to complete filenames.  It allows completion of partial paths.  For
example, the string `tt(/u/i/s/sig)' may be completed to
`tt(/usr/include/sys/signal.h)'.

The options accepted by both tt(_path_files) and tt(_files) are:

startitem()
item(tt(-f))(
Complete all filenames.  This is the default.
)
item(tt(-/))(
Specifies that only directories should be completed.
)
item(tt(-g) var(pattern))(
Specifies that only files matching the var(pattern) should be completed.
)
item(tt(-W) var(paths))(
Specifies path prefixes that are to be prepended to the string from the
command line to generate the filenames but that should not be inserted
as completions nor shown in completion listings.  Here, var(paths) may be
the name of an array parameter, a literal list of paths enclosed in
parentheses or an absolute pathname.
)
item(tt(-F) var(ignored-files))(
This behaves as for the corresponding option to the tt(compadd) builtin.
It gives direct control over which
filenames should be ignored.  If the option is not present, the
tt(ignored-patterns) style is used.
)
enditem()

Both tt(_path_files) and tt(_files) also accept the following options
which are passed to tt(compadd): `tt(-J)', `tt(-V)',
`tt(-1)', `tt(-2)', `tt(-n)', `tt(-X)', `tt(-M)', `tt(-P)', `tt(-S)',
`tt(-q)', `tt(-r)', and `tt(-R)'.

Finally, the tt(_path_files) function  uses the styles tt(expand),
tt(ambiguous), tt(special-dirs), tt(list-suffixes) and tt(file-sort)
described above.
)
findex(_pick_variant)
redef(SPACES)(0)(tt(ifztexi(NOTRANS(@ @ @ @ @ @ @ @ @ @ @ @ @ @ ))ifnztexi(              )))
xitem(tt(_pick_variant )[ tt(-b) var(builtin-label) ] [ tt(-c) var(command) ] [ tt(-r) var(name) ])
item(SPACES()var(label)tt(=)var(pattern) ... var(label) [ var(arg) ... ])(
This function is used to resolve situations where a single command name
requires more than one type of handling, either because it
has more than one variant or because there is a name clash between two
different commands.

The command to run is taken from the first element of the array
tt(words) unless this is overridden by the option tt(-c).  This command
is run and its output is compared with a series of patterns.  Arguments
to be passed to the command can be specified at the end after all the
other arguments.  The patterns to try in order are given by the arguments
var(label)tt(=)var(pattern); if the output of `var(command) var(arg)
...' contains var(pattern), then var(label) is selected as the label
for the command variant.  If none of the patterns match, the final
command label is selected and status 1 is returned.

If the `tt(-b) var(builtin-label)' is given, the command is tested to
see if it is provided as a shell builtin, possibly autoloaded; if so,
the label var(builtin-label) is selected as the label for the variant.

If the `tt(-r) var(name)' is given, the var(label) picked is stored in
the parameter named var(name).

The results are also cached in the tt(_cmd_variant) associative array
indexed by the name of the command run.
)
findex(_regex_arguments)
item(tt(_regex_arguments) var(name) var(spec) ...)(
This function generates a completion function var(name) which matches
the specifications var(spec)s, a set of regular expressions as
described below.  After running tt(_regex_arguments), the function
var(name) should be called as a normal completion function.
The pattern to be matched is given by the contents of
the tt(words) array up to the current cursor position joined together
with null characters; no quotation is applied.

The arguments are grouped as sets of alternatives separated by `tt(|)',
which are tried one after the other until one matches.  Each alternative
consists of a one or more specifications which are tried left to right,
with each pattern matched being stripped in turn from the command line
being tested, until all of the group succeeds or until one fails; in the
latter case, the next alternative is tried.  This structure can be
repeated to arbitrary depth by using parentheses; matching proceeds from
inside to outside.

COMMENT(I think I've got this wrong, but I can't think what else it
could mean.  Actually, it still doesn't mean very much.)\
A special procedure is applied if no test succeeds but the remaining
command line string contains no null character (implying the remaining
word is the one for which completions are to be generated).  The
completion target is restricted to the remaining word and any
var(action)s for the corresponding patterns are executed.  In this case,
nothing is stripped from the command line string.  The order of
evaluation of the var(action)s can be determined by the tt(tag-order)
style; the various formats supported by tt(_alternative) can be used
in var(action).  The var(descr) is used for setting up the array
parameter tt(expl).

Specification arguments take one of following forms, in which
metacharacters such as `tt(LPAR())', `tt(RPAR())', `tt(#)' and `tt(|)'
should be quoted.

startitem()
item(tt(/)var(pattern)tt(/) [tt(%)var(lookahead)tt(%)] [tt(-)var(guard)] [tt(:)var(tag)tt(:)var(descr)tt(:)var(action)])(
This is a single primitive component.
The function tests whether the combined pattern
`tt((#b)LPAR()(#B))var(pattern)tt(RPAR())var(lookahead)tt(*)' matches
the command line string.  If so, `var(guard)' is evaluated and
its return status is examined to determine if the test has succeeded.
The var(pattern) string `tt([])' is guaranteed never to match.
The var(lookahead) is not stripped from the command line before the next
pattern is examined.

The argument starting with tt(:) is used in the same manner as an argument to
tt(_alternative).

A component is used as follows: var(pattern) is tested to
see if the component already exists on the command line.  If
it does, any following specifications are examined to find something to
complete.  If a component is reached but no such pattern exists yet on the
command line, the string containing the var(action) is used to generate
matches to insert at that point.
)
item(tt(/)var(pattern)tt(/+) [tt(%)var(lookahead)tt(%)] [tt(-)var(guard)] [tt(:)var(tag)tt(:)var(descr)tt(:)var(action)])(
This is similar to `tt(/)var(pattern)tt(/) ...' but the left part of the
command line string (i.e. the part already matched by previous patterns)
is also considered part of the completion target.
)
item(tt(/)var(pattern)tt(/-) [tt(%)var(lookahead)tt(%)] [tt(-)var(guard)] [tt(:)var(tag)tt(:)var(descr)tt(:)var(action)])(
This is similar to `tt(/)var(pattern)tt(/) ...' but the var(action)s of the
current and previously matched patterns are ignored even if the
following `var(pattern)' matches the empty string.
)
item(tt(LPAR()) var(spec) tt(RPAR()))(
Parentheses may be used to groups var(spec)s; note each parenthesis
is a single argument to tt(_regex_arguments).
)
item(var(spec) tt(#))(
This allows any number of repetitions of var(spec).
)
item(var(spec) var(spec))(
The two var(spec)s are to be matched one after the other as described
above.
)
item(var(spec) tt(|) var(spec))(
Either of the two var(spec)s can be matched.
)
enditem()

The function tt(_regex_words) can be used as a helper function to
generate matches for a set of alternative words possibly with
their own arguments as a command line argument.

Examples:

example(_regex_arguments _tst /$'[^\0]#\0'/ \ 
    /$'[^\0]#\0'/ :'compadd aaa')

This generates a function tt(_tst) that completes tt(aaa) as its only
argument.  The var(tag) and var(description) for the action have been
omitted for brevity (this works but is not recommended in normal use).
The first component matches the command word, which is arbitrary; the
second matches  any argument.  As the argument is also arbitrary, any
following component would not depend on tt(aaa) being present.

example(_regex_arguments _tst /$'[^\0]#\0'/ \ 
    /$'aaa\0'/ :'compadd aaa')

This is a more typical use; it is similar, but any following patterns
would only match if tt(aaa) was present as the first argument.

example(_regex_arguments _tst /$'[^\0]#\0'/ \( \ 
    /$'aaa\0'/ :'compadd aaa' \ 
    /$'bbb\0'/ :'compadd bbb' \) \#)

In this example, an indefinite number of command arguments may be
completed.  Odd arguments are completed as tt(aaa) and even arguments
as tt(bbb).  Completion fails unless the set of tt(aaa) and tt(bbb)
arguments before the current one is matched correctly.

example(_regex_arguments _tst /$'[^\0]#\0'/ \ 
    \( /$'aaa\0'/ :'compadd aaa' \| \ 
    /$'bbb\0'/ :'compadd bbb' \) \#)

This is similar, but either tt(aaa) or tt(bbb) may be completed for
any argument.  In this case tt(_regex_words) could be used to generate
a suitable expression for the arguments.

)
findex(_regex_words [ tt(-t) var(term) ])
item(tt(_regex_words) var(tag) var(description) var(spec) ...)(
This function can be used to generate arguments for the
tt(_regex_arguments) command which may be inserted at any point where
a set of rules is expected.  The var(tag) and var(description) give a
standard tag and description pertaining to the current context.  Each
var(spec) contains two or three arguments separated by a colon: note
that there is no leading colon in this case.

Each var(spec) gives one of a set of words that may be completed at
this point, together with arguments.  It is thus roughly equivalent to
the tt(_arguments) function when used in normal (non-regex) completion.

The part of the var(spec) before the first colon is the word to be
completed.  This may contain a tt(*); the entire word, before and after
the tt(*) is completed, but only the text before the tt(*) is required
for the context to be matched, so that further arguments may be
completed after the abbreviated form.

The second part of var(spec) is a description for the word being
completed.

The optional third part of the var(spec) describes how words following
the one being completed are themselves to be completed.  It will be
evaluated in order to avoid problems with quoting.  This means that
typically it contains a reference to an array containing previously
generated regex arguments.

The option tt(-t) var(term) specifies a terminator for the word
instead of the usual space.  This is handled as an auto-removable suffix
in the manner of the option tt(-s) var(sep) to tt(_values).

The result of the processing by tt(_regex_words) is placed in the array
tt(reply), which should be made local to the calling function.
If the set of words and arguments may be matched repeatedly, a tt(#)
should be appended to the generated array at that point.

For example:

example(local -a reply
_regex_words mydb-commands 'mydb commands' \ 
  'add:add an entry to mydb:$mydb_add_cmds' \ 
  'show:show entries in mydb'
_regex_arguments _mydb "$reply[@]"
_mydb "$@")

This shows a completion function for a command tt(mydb) which takes
two command arguments, tt(add) and tt(show).  tt(show) takes no arguments,
while the arguments for tt(add) have already been prepared in an
array tt(mydb_add_cmds), quite possibly by a previous call to
tt(_regex_words).
)
findex(_requested)
item(tt(_requested) [ tt(-x) ] [ tt(-12VJ) ] var(tag) [ var(name) var(descr) [ var(command) [ var(arg) ... ] ])(
This function is called to decide whether a tag already registered by a
call to tt(_tags) (see below) has been requested by the user and hence
completion should be performed for it.  It returns status zero if the
tag is requested and non-zero otherwise.  The function is typically used
as part of a loop over different tags as follows:

example(_tags foo bar baz
while _tags; do
  if _requested foo; then
    ... # perform completion for foo
  fi
  ... # test the tags bar and baz in the same way
  ... # exit loop if matches were generated
done)

Note that the test for whether matches were generated is not performed
until the end of the tt(_tags) loop.  This is so that the user can set
the tt(tag-order) style to specify a set of tags to be completed at the
same time.

If var(name) and var(descr) are given, tt(_requested) calls the
tt(_description) function with these arguments together with the options
passed to tt(_requested).

If var(command) is given, the tt(_all_labels) function will be called
immediately with the same arguments.  In simple cases this makes it
possible to perform the test for the tag and the matching in one go.
For example:

example(local expl ret=1
_tags foo bar baz
while _tags; do
  _requested foo expl 'description' \ 
      compadd foobar foobaz && ret=0
  ...
  (( ret )) || break
done)

If the var(command) is not tt(compadd), it must nevertheless be prepared
to handle the same options.
)
findex(_retrieve_cache)
item(tt(_retrieve_cache) var(cache_identifier))(
This function retrieves completion information from the file given by
var(cache_identifier), stored in a directory specified by the
tt(cache-path) style which defaults to tt(~/.zcompcache).  The return status
is zero if retrieval was successful.  It will only attempt retrieval
if the tt(use-cache) style is set, so you can call this function
without worrying about whether the user wanted to use the caching
layer.

See tt(_store_cache) below for more details.
)
findex(_sep_parts)
item(tt(_sep_parts))(
This function is passed alternating arrays and separators as arguments.
The arrays specify completions for parts of strings to be separated by the
separators.  The arrays may be the names of array parameters or
a quoted list of words in parentheses.  For example, with the array
`tt(hosts=(ftp news))' the call `tt(_sep_parts '(foo bar)' @ hosts)' will
complete the string  `tt(f)' to `tt(foo)' and the string `tt(b@n)' to
`tt(bar@news)'.

This function accepts the tt(compadd) options `tt(-V)', `tt(-J)',
`tt(-1)', `tt(-2)', `tt(-n)', `tt(-X)', `tt(-M)', `tt(-P)', `tt(-S)',
`tt(-r)', `tt(-R)', and `tt(-q)' and passes them on to the tt(compadd)
builtin used to add the matches.
)
findex(_sequence)
item(tt(_sequence) [ tt(-s) var(sep) ] [ tt(-n) var(max) ] [ tt(-d) ] var(function) [ tt(-) ] ...)(
This function is a wrapper to other functions for completing items in a
separated list. The same function is used to complete each item in the
list. The separator is specified with the tt(-s) option. If tt(-s) is
omitted it will use `tt(,)'. Duplicate values are not matched unless
tt(-d) is specified. If there is a fixed or maximum number of items in
the list, this can be specified with the tt(-n) option.

Common tt(compadd) options are passed on to the function. It is possible
to use tt(compadd) directly with tt(_sequence), though tt(_values) may
be more appropriate in this situation.
)
findex(_setup)
item(tt(_setup) var(tag) [ var(group) ])(
This function sets up the special
parameters used by the completion system appropriately for the var(tag)
given as the first argument.  It uses the styles tt(list-colors),
tt(list-packed), tt(list-rows-first), tt(last-prompt), tt(accept-exact),
tt(menu) and tt(force-list).

The optional var(group) supplies the name of the group in which the
matches will be placed.  If it is not given, the var(tag) is used as
the group name.

This function is called automatically from tt(_description)
and hence is not normally called explicitly.
)
findex(_store_cache)
item(tt(_store_cache) var(cache_identifier) var(param) ...)(
This function, together with tt(_retrieve_cache) and
tt(_cache_invalid), implements a caching layer which can be used
in any completion function.  Data obtained by
costly operations are stored in parameters;
this function then dumps the values of those parameters to a file.  The
data can then be retrieved quickly from that file via tt(_retrieve_cache),
even in different instances of the shell.

The var(cache_identifier) specifies the file which the data should be
dumped to.  The file is stored in a directory specified by the
tt(cache-path) style which defaults to tt(~/.zcompcache).  The remaining
var(param)s arguments are the parameters to dump to the file.

The return status is zero if storage was successful.  The function will
only attempt storage if the tt(use-cache) style is set, so you can
call this function without worrying about whether the user wanted to
use the caching layer.

The completion function may avoid calling tt(_retrieve_cache) when it
already has the completion data available as parameters. 
However, in that case it should
call tt(_cache_invalid) to check whether the data in the parameters and
in the cache are still valid.

See the _perl_modules completion function for a simple example of
the usage of the caching layer.
)
findex(_tags)
item(tt(_tags) [ [ tt(-C) var(name) ] var(tag) ... ])(
If called with arguments, these are taken to be the names of tags
valid for completions in the current context.  These tags are stored
internally and sorted by using the tt(tag-order) style.

Next, tt(_tags) is called repeatedly without arguments from the same
completion function.  This successively selects the first, second,
etc. set of tags requested by the user.  The return status is zero if at
least one of the tags is requested and non-zero otherwise.  To test if a
particular tag is to be tried, the tt(_requested) function should be
called (see above).

If `tt(-C) var(name)' is given, var(name) is temporarily stored in the
var(argument) field (the fifth) of the context in the tt(curcontext) parameter
during the call to tt(_tags); the field is restored on exit.  This
allows tt(_tags) to use a more 
specific context without having to change and reset the
tt(curcontext) parameter (which has the same effect).
)
findex(_tilde_files)
item(tt(_tilde_files))(
Like tt(_files), but resolve leading tildes according to the rules of
filename expansion, so the suggested completions don't start with
a `tt(~)' even if the filename on the command-line does.
)
findex(_values)
item(tt(_values) [ tt(-O) var(name) ] [ tt(-s) var(sep) ] [ tt(-S) var(sep) ] [ tt(-wC) ] var(desc) var(spec) ...)(
This is used to complete arbitrary keywords (values) and their arguments,
or lists of such combinations.

If the first argument is the option `tt(-O) var(name)', it will be used
in the same way as by the tt(_arguments) function.  In other words, the
elements of the var(name) array will be passed to tt(compadd)
when executing an action.

If the first argument (or the first argument after `tt(-O) var(name)')
is `tt(-s)', the next argument is used as the character that separates
multiple values.  This character is automatically added after each value
in an auto-removable fashion (see below); all values completed by
`tt(_values -s)' appear in the same word on the command line, unlike
completion using tt(_arguments).  If this option is not present, only a
single value will be completed per word.

Normally, tt(_values) will only use the current word to determine
which values are already present on the command line and hence are not
to be completed again.  If the tt(-w) option is given, other arguments
are examined as well.

The first non-option argument, var(desc), is used as a string to print as a
description before listing the values.

All other arguments describe the possible values and their
arguments in the same format used for the description of options by
the tt(_arguments) function (see above).  The only differences are that
no minus or plus sign is required at the beginning,
values can have only one argument, and the forms of action
beginning with an equal sign are not supported.

The character separating a value from its argument can be set using the
option tt(-S) (like tt(-s), followed by the character to use as the
separator in the next argument).  By default the equals
sign will be used as the separator between values and arguments.

Example:

example(_values -s , 'description' \ 
        '*foo[bar]' \ 
        '(two)*one[number]:first count:' \ 
        'two[another number]::second count:(1 2 3)')

This describes three possible values: `tt(foo)', `tt(one)', and
`tt(two)'.  The first is described as `tt(bar)', takes no argument 
and may appear more than once.  The second is described as
`tt(number)', may appear more than once, and takes one mandatory
argument described as `tt(first count)'; no action is
specified, so it will not be completed.  The
`tt((two))' at the beginning says that if the value `tt(one)' is on
the line, the value `tt(two)' will no longer be considered a possible
completion.  Finally, the last value (`tt(two)') is described
as `tt(another number)' and takes an optional argument described as
`tt(second count)' for which the completions (to appear after an
`tt(=)') are `tt(1)', `tt(2)', and `tt(3)'.  The tt(_values) function
will complete lists of these values separated by commas.

Like tt(_arguments), this function temporarily adds another context name
component to the arguments element (the fifth) of the current context
while executing the var(action).  Here this name is just the name of the
value for which the argument is completed.

The style tt(verbose) is used to decide if the descriptions for the
values (but not those for the arguments) should be printed.

The associative array tt(val_args) is used to report values and their
arguments; this works similarly to the tt(opt_args) associative array
used by tt(_arguments).  Hence the function calling tt(_values) should
declare the local parameters tt(state), tt(state_descr), tt(line),
tt(context) and tt(val_args):

example(local context state state_descr line
typeset -A val_args)

when using an action of the form `tt(->)var(string)'.  With this
function the tt(context) parameter will be set to the name of the
value whose argument is to be completed.  Note that for tt(_values),
the tt(state) and tt(state_descr) are scalars rather than arrays.
Only a single matching state is returned.

Note also that tt(_values) normally adds the character used as the
separator between values as an auto-removable suffix (similar to a
`tt(/)' after a directory).  However, this is not possible for a
`tt(->)var(string)' action as the matches for the argument are
generated by the calling function.  To get the usual behaviour,
the calling function can add the separator var(x) as a suffix by
passing the options `tt(-qS) var(x)' either directly or indirectly to
tt(compadd).

The option tt(-C) is treated in the same way as it is by tt(_arguments).
In that case the parameter tt(curcontext) should be made local instead 
of tt(context) (as described above).
)
findex(_wanted)
item(tt(_wanted) [ tt(-x) ] [ tt(-C) var(name) ]  [ tt(-12VJ) ] var(tag) var(name) var(descr) var(command) [ var(arg) ...])(
In many contexts, completion can only generate one particular set of
matches, usually corresponding to a single tag.  However, it is
still necessary to decide whether the user requires matches of this type.
This function is useful in such a case.

The arguments to tt(_wanted) are the same as those to tt(_requested),
i.e. arguments to be passed to tt(_description).  However, in this case
the var(command) is not optional;  all the processing of tags, including
the loop over both tags and tag labels and the generation of matches,
is carried out automatically by tt(_wanted).

Hence to offer only one tag and immediately add the corresponding
matches with the given description:

example(local expl
_wanted tag expl 'description' \ 
    compadd -- var(match1) var(match2)...)

See also the use of tt(_wanted) in the example function in
ifzman(the subsection `Dynamic named directories' in zmanref(zshexpn))\
ifnzman(noderef(Dynamic named directories)).

Note that, as for tt(_requested), the var(command) must be able to
accept options to be passed down to tt(compadd).

Like tt(_tags) this function supports the tt(-C) option to give a
different name for the argument context field.  The tt(-x) option has
the same meaning as for tt(_description).
)
findex(_widgets)
item(tt(_widgets) [ tt(-g) var(pattern) ])(
This function completes names of zle widgets (see
ifzman(the section `Widgets' in zmanref(zshzle))\
ifnzman(noderef(Zle Widgets))\
).  The var(pattern), if present, is matched against values of the tt($widgets)
special parameter, documented in 
ifzman(the section `The zsh/zleparameter Module' in zmanref(zshmodules))\
ifnzman(noderef(The zsh/zleparameter Module)).
)
enditem()

texinode(Completion System Variables)(Completion Directories)(Completion Functions)(Completion System)
sect(Completion System Variables)
cindex(completion system, variables)

There are some standard variables, initialised by the tt(_main_complete)
function and then used from other functions.

The standard variables are:

startitem()
item(tt(_comp_caller_options))(
The completion system uses tt(setopt) to set a number of options. This
allows functions to be written without concern for compatibility with
every possible combination of user options. However, sometimes completion
needs to know what the user's option preferences are. These are saved
in the tt(_comp_caller_options) associative array. Option names, spelled
in lowercase without underscores, are mapped to one or other of the
strings `tt(on)' and `tt(off)'.
)
item(tt(_comp_priv_prefix))(
Completion functions such as tt(_sudo) can set the tt(_comp_priv_prefix)
array to a command prefix that may then be used by tt(_call_program) to
match the privileges when calling programs to generate matches.
)
enditem()

vindex(compprefuncs, use of)
vindex(comppostfuncs, use of)
Two more features are offered by the tt(_main_complete) function.  The
arrays tt(compprefuncs) and tt(comppostfuncs) may contain
names of functions that are to be called immediately before or after
completion has been tried.  A function will only be called once unless
it explicitly reinserts itself into the array.

texinode(Completion Directories)()(Completion System Variables)(Completion System)
sect(Completion Directories)
cindex(completion system, directory structure)

In the source distribution, the files are contained in various
subdirectories of the tt(Completion) directory.  They may have been
installed in the same structure, or into one single function directory.
The following is a description of the files found in the original directory
structure.  If you wish to alter an installed file, you will need to copy
it to some directory which appears earlier in your tt(fpath) than the
standard directory where it appears.

startitem()
item(tt(Base))(
The core functions and special completion widgets automatically bound
to keys.  You will certainly need most of these, though will
probably not need to alter them.  Many of these are documented above.
)
item(tt(Zsh))(
Functions for completing arguments of shell builtin commands and
utility functions for this.  Some of these are also used by functions from
the tt(Unix) directory.
)
item(tt(Unix))(
Functions for completing arguments of external commands and suites of
commands.  They may need modifying for your system, although in many cases
some attempt is made to decide which version of a command is present.  For
example, completion for the tt(mount) command tries to determine the system
it is running on, while completion for many other utilities try to decide
whether the GNU version of the command is in use, and hence whether the
tt(-)tt(-help) option is supported.
)
item(tt(X), tt(AIX), tt(BSD), ...)(
Completion and utility function for commands available only on some systems.
These are not arranged hierarchically, so, for example, both the
tt(Linux) and tt(Debian) directories, as well as the tt(X) directory,
may be useful on your system.
)
enditem()
