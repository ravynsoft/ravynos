#   Copyright (C) 1994-2023 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.

# Please email any bugs, comments, and/or additions to this file to:
# bug-dejagnu@prep.ai.mit.edu

# Written by Ian Lance Taylor <ian@cygnus.com>

if ![is_remote host] {
    if {[which $OBJCOPY] == 0} then {
        perror "$OBJCOPY does not exist"
        return
    }
}

send_user "Version [binutil_version $OBJCOPY]"

if ![is_remote host] {
    set tempfile tmpdir/bintest.o
    set copyfile tmpdir/copy
} else {
    set tempfile [remote_download host tmpdir/bintest.o]
    set copyfile copy
}

# Test that objcopy does not modify a file when copying it.
# "object" or "executable" values for type are supported.

proc objcopy_test {testname srcfile type asflags ldflags} {
    global OBJCOPY
    global OBJCOPYFLAGS
    global srcdir
    global subdir
    global tempfile
    global copyfile
    set t_tempfile $tempfile
    set t_copyfile ${copyfile}.o

    if { $type != "object" && $type != "executable" } {
	error "objcopy_test accepts only \"object\" or \"executable\" values for type"
    }

    if {![binutils_assemble_flags $srcdir/$subdir/${srcfile} $t_tempfile "$asflags"]} then {
	unsupported "objcopy $type ($testname)"
	remote_file host delete $t_tempfile
	return
    }

    set xflags ""
    if { $type == "executable" } {
	global LD
	# Check that LD exists
	if {[which $LD] == 0} then {
	    untested "objcopy $type ($testname)"
	    return
	}

	# Use tempfile and copyfile without the .o extension for executable files
	set t_tempfile [string range $tempfile 0 end-2]
	set t_copyfile $copyfile
	set got [binutils_run $LD "$tempfile -o $t_tempfile $ldflags"]
	if { ![string equal "" $got] } then {
	    unsupported "objcopy $type ($testname)"
	    return
	}
	set xflags "--preserve-dates"
	sleep 1
    }

    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS $xflags $t_tempfile $t_copyfile"]

    if ![string equal "" $got] then {
	send_log "$got\n"
	fail "objcopy $type ($testname)"
    } else {
	send_log "cmp $t_tempfile $t_copyfile\n"
	verbose "cmp $t_tempfile $t_copyfile"
	if [is_remote host] {
	    set src1 tmpdir/bintest
	    set src2 tmpdir/copy
	    remote_upload host $t_tempfile $src1
	    remote_upload host $t_copyfile $src2
	} else {
	    set src1 $t_tempfile
	    set src2 $t_copyfile
	}
	set status [remote_exec build cmp "${src1} ${src2}"]
	set exec_output [lindex $status 1]
	set exec_output [prune_warnings $exec_output]

	if [string equal "" $exec_output] then {
	    pass "objcopy $type ($testname)"
	    if { $type == "executable" } {
		set dir [file dirname $t_copyfile]
		set f2 [file tail $t_copyfile]
		set status [remote_exec host find "$dir -name $f2 -newer $t_tempfile -print"]
		set exec_output [lindex $status 1]
		if [string equal "" $exec_output] then {
		    pass "objcopy $type ($testname) timestamp"
		} else {
		    fail "objcopy $type ($testname) timestamp"
		}
	    }
	} else {
	    send_log "$exec_output\n"
	    verbose "$exec_output" 1

	    # On OSF/1, this succeeds with gas and fails with /bin/as.
	    setup_xfail "alpha*-*-osf*"

	    fail "objcopy $type ($testname)"
	}
    }
}

setup_xfail "hppa*-*-*"
setup_xfail "tic54x-*-*"
clear_xfail "hppa*64*-*-hpux*" "hppa*-*-linux*" "hppa*-*-lites*"
clear_xfail "hppa*-*-*n*bsd*" "hppa*-*-*elf*"
objcopy_test "simple copy" bintest.s object "" ""

# Test verilog data width
proc objcopy_test_verilog {testname} {
    global OBJCOPY
    global OBJCOPYFLAGS
    global srcdir
    global subdir
    global copyfile
    set binfile tmpdir/verilogtest.o
    set verilog tmpdir/verilog

    set got [binutils_assemble $srcdir/$subdir/verilogtest.s $binfile]
    if {![binutils_assemble $srcdir/$subdir/verilogtest.s $binfile]} then {
	unsupported "objcopy ($testname)"
	return
    }

    set got [binutils_run $OBJCOPY "-O verilog $binfile $verilog"]
    if ![string equal "" $got] then {
	fail "objcopy ($testname)"
    }

    set got [binutils_run $OBJCOPY "-O verilog --verilog-data-width 0 $binfile $verilog-0.hex"]
    if ![regexp "error: verilog data width must be 1, 2, 4, 8 or 16" $got] then {
	fail "objcopy ($testname 0) {$got}"
    } else {
	pass "objcopy ($testname 0)"
    }

    foreach width {1 2} {
	set got [binutils_run $OBJCOPY "-O verilog --verilog-data-width $width $binfile $verilog-$width.hex"]
	if ![string equal "" $got] then {
	    fail "objcopy ($testname $width)"
	}
        send_log "regexp_diff $verilog-$width.hex $srcdir/$subdir/verilog-$width.hex\n"
	if {! [regexp_diff "$verilog-$width.hex" "$srcdir/$subdir/verilog-$width.hex"]} {
	    pass "objcopy ($testname $width)"
	} else {
	    fail "objcopy ($testname $width)"
	}
    }

    # 16-bit little-endian targets fail the following tests because the
    # verilog backend does not convert from 16-bits to 32-bits before it
    # converts from internal format to little endian format.
    if { [istarget tic54*-*-*] || [istarget pdp11-*-*] } {
	untested "verilog width-4 and width-8 tests"
	return
    }
    
    foreach width {4 8} {
	set got [binutils_run $OBJCOPY "-O verilog --verilog-data-width $width $binfile $verilog-$width.hex"]
	if ![string equal "" $got] then {
	    fail "objcopy ($testname $width)"
	}
        send_log "regexp_diff $verilog-$width.hex $srcdir/$subdir/verilog-$width.hex\n"
	if {! [regexp_diff "$verilog-$width.hex" "$srcdir/$subdir/verilog-$width.hex"]} {
	    pass "objcopy ($testname $width)"
	} else {
	    fail "objcopy ($testname $width)"
	}
    }

    # Test generating endian correct output.    
    set testname "objcopy (verilog output endian-ness == input endian-ness)"
    set got [binutils_run $OBJCOPY "-O verilog --verilog-data-width 4 $binfile $verilog-I4.hex"]
    if ![string equal "" $got] then {
	fail $testname
    }
    send_log "regexp_diff $verilog-I4.hex $srcdir/$subdir/verilog-I4.hex\n"
    if {! [regexp_diff "$verilog-I4.hex" "$srcdir/$subdir/verilog-I4.hex"]} {
	pass $testname 
    } else {
	fail $testname 
    }
}

objcopy_test_verilog "verilog data width"

if { [file exists $tempfile] } {
    # Test reversing bytes in a section.

    set reversed ${tempfile}-reversed
    set sect_names [get_standard_section_names]
    if { $sect_names != "" } {
	if { [istarget hppa*-*-hpux*] } {
	    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -j \$PRIVATE\$ -j [lindex $sect_names 1] --reverse-bytes=4 $tempfile $reversed"]
	} else {
	    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -j [lindex $sect_names 1] --reverse-bytes=4 $tempfile $reversed"]
	}
    } else {
	set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -j .data --reverse-bytes=4 $tempfile $reversed"]
    }

    if ![string equal "" $got] then {
	fail "objcopy --reverse-bytes"
    } else {
	if [is_remote host] {
	    remote_upload host ${reversed} tmpdir/copy-reversed.o
	    set reversed tmpdir/copy-reversed.o
	}

	set origdata [binutils_run $OBJDUMP "$OBJDUMPFLAGS -s -j .data $tempfile"]
	set  revdata [binutils_run $OBJDUMP "$OBJDUMPFLAGS -s -j .data $reversed"]

	set want "^ \[0-9\]+ (\[0-9\]+)"
	set found_orig [regexp -lineanchor $want $origdata -> origdata]
	set found_rev [regexp -lineanchor $want $revdata -> revdata]

	if {$found_orig == 0 || $found_rev == 0} then {
	    fail "objcopy --reverse-bytes"
	} else {
	    scan $origdata "%2x%2x%2x%2x" b1 b2 b3 b4
	    scan $revdata "%2x%2x%2x%2x" c4 c3 c2 c1

	    if {$b1 == $c1 && $b2 == $c2 && $b3 == $c3 && $b4 == $c4} then {
		pass "objcopy --reverse-bytes"
	    } else {
		fail "objcopy --reverse-bytes"
	    }
	}
    }
}

# Test interleaved copy of multiple byte width

set sequence_file sequence_file
set file [open ${sequence_file} w]
puts ${file} "12345678"
close ${file}

if [is_remote host] {
    remote_upload host ${sequence_file} tmpdir/sequence_file
    set sequence_file tmpdir/sequence_file
}

set got [binutils_run $OBJCOPY "-I binary -i 4 -b 0 --interleave-width 2 ${sequence_file} ${copyfile}"]

if ![string equal "" $got] then {
    fail "objcopy -i --interleave-width"
} else {
    if [is_remote host] {
	remote_upload host ${copyfile} tmpdir/interleave_output
	set interleave_output tmpdir/interleave_output
    } else {
	set interleave_output ${copyfile}
    }

    set file [open ${interleave_output} r]
    gets $file line
    send_log "$line\n"
    verbose $line

    if ![string equal "1256" $line] then {
	fail "objcopy -i --interleave-width"
    }
    pass "objcopy -i --interleave-width"

    close $file
}

# Test generating S records.

if { [file exists $tempfile] } {
    # We make the srec filename 8.3 compatible. Note that the header string
    # matched against depends on the name of the file. Ugh.

    if [is_remote host] {
	set srecfile copy.sre
	set header_string S00B0000636F70792E737265C1
    } else {
	set srecfile ${copyfile}.srec
	set header_string S0130000746D706469722F636F70792E7372656397
    }

    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec $tempfile ${srecfile}"]

    if ![string equal "" $got] then {
	fail "objcopy -O srec"
    } else {
	if [is_remote host] {
	    remote_upload host ${srecfile} tmpdir/copy.srec
	    set srecfile tmpdir/copy.srec
	}
	set file [open ${srecfile} r]

	# The first S record is fixed by the file name we are using.
	gets $file line
	send_log "$line\n"
	verbose $line
	if ![regexp "$header_string.*" $line] {
	    send_log "bad header\n"
	    fail "objcopy -O srec"
	} else {
	    while {[gets $file line] != -1 \
		       && [regexp "^S\[123\]\[0-9a-fA-F\]+\[\r\n\]*$" $line]} {
		send_log "$line\n"
		verbose $line
		set line "**EOF**"
	    }
	    send_log "$line\n"
	    verbose $line
	    if ![regexp "^S\[789\]\[0-9a-fA-F\]+\[\r\n\]*$" $line] then {
		send_log "bad trailer\n"
		fail "objcopy -O srec"
	    } else {
		if {[gets $file line] != -1} then {
		    send_log "garbage at end\n"
		    send_log "$line\n"
		    verbose $line
		    fail "objcopy -O srec"
		} else {
		    set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -f ${srecfile}"]
		    if ![regexp "file format srec" $got] then {
			send_log "objdump failed\n"
			fail "objcopy -O srec"
		    } else {
			pass "objcopy -O srec"
		    }
		}
	    }
	}

	close $file
    }
}

# Test setting and adjusting the start address.  We only test this
# while generating S records, because we may not be able to set the
# start address for other object file formats, and the S record case
# is the only useful one anyhow.

set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -f $tempfile"]
if ![regexp "start address (\[0-9a-fA-FxX\]+)" $got all origstart] then {
    perror "objdump can not recognize bintest.o"
    set origstart ""
} else {
    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec --set-start 0x7654 $tempfile ${copyfile}.srec"]
    if ![string equal "" $got] then {
	fail "objcopy --set-start"
    } else {
	set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -f ${copyfile}.srec"]
	if ![regexp "file format srec.*start address (\[0-9a-fA-FxX\]+)" $got all srecstart] then {
	    fail "objcopy --set-start"
	} else {
	    if {$srecstart != 0x7654} then {
		send_log "$srecstart != 0x7654\n"
		fail "objcopy --set-start"
	    } else {
		pass "objcopy --set-start"
	    }
	}
    }

    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec --adjust-start 0x123 $tempfile ${copyfile}.srec"]
    if ![string equal "" $got] then {
	fail "objcopy --adjust-start"
    } else {
	set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -f ${copyfile}.srec"]
	if ![regexp "file format srec.*start address (\[0-9a-fA-FxX\]+)" $got all srecstart] then {
	    fail "objcopy --adjust-start"
	} else {
	    if {$srecstart != $origstart + 0x123} then {
		send_log "$srecstart != $origstart + 0x123\n"
		fail "objcopy --adjust-start"
	    } else {
		pass "objcopy --adjust-start"
	    }
	}
    }
}

# Test adjusting the overall VMA, and adjusting the VMA of a
# particular section.  We again only test this when generating S
# records.

set low ""
set lowname ""

set headers [binutils_run $OBJDUMP "$OBJDUMPFLAGS -h $tempfile"]

set headers_regexp "\[ 	0-9\]+(\[^ 	\]+)\[ 	\]*(\[0-9a-fA-F\]+)\[ 	\]+\[0-9a-fA-F\]+\[ 	\]+(\[0-9a-fA-F\]+)\[ 	\]+\[0-9a-fA-F\]+\[ 	\]+2\[*\]\[*\]\[0-9\]+(.*)"

set got $headers
while {[regexp $headers_regexp $got all name size vma rest]} {
    set vma 0x$vma
    set size 0x$size
    if {$size != 0} {
	if {$low == "" || $vma < $low} {
            set low $vma
	    set lowname $name
	}
    }
    set got $rest
}

if {$low == "" || $origstart == ""} then {
    perror "objdump can not recognize bintest.o"
} else {
    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec --adjust-vma 0x123 $tempfile ${copyfile}.srec"]
    if ![string equal "" $got] then {
        fail "objcopy --adjust-vma"
    } else {
	set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -fh ${copyfile}.srec"]
	set want "file format srec.*start address\[ 	\]*(\[0-9a-fA-FxX\]+).*sec1\[ 	\]+\[0-9a-fA-F\]+\[ 	\]+(\[0-9a-fA-F\]+)"
	if ![regexp $want $got all start vma] then {
	    fail "objcopy --adjust-vma"
	} else {
	    set vma 0x$vma
	    if {$vma != $low + 0x123} then {
		send_log "$vma != $low + 0x123\n"
		fail "objcopy --adjust-vma"
	    } else {
		if {$start != $origstart + 0x123} then {
		    send_log "$start != $origstart + 0x123\n"
		    fail "objcopy --adjust-vma"
		} else {
		    pass "objcopy --adjust-vma"
		}
	    }
	}
    }

    set arg ""
    set got $headers
    while {[regexp $headers_regexp $got all name size vma rest]} {
	set vma 0x$vma
	if {$vma == $low} then {
	    set arg "$arg --adjust-section-vma $name+4"
	}
	set got $rest
    }

    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec $arg $tempfile ${copyfile}.srec"]
    if ![string equal "" $got] then {
	fail "objcopy --adjust-section-vma +"
    } else {
	set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -h ${copyfile}.srec"]
	set want "file format srec.*sec1\[ 	\]+\[0-9a-fA-F\]+\[ 	\]+(\[0-9a-fA-F\]+)"
	if ![regexp $want $got all vma] then {
	    fail "objcopy --adjust-section-vma +"
	} else {
	    set vma 0x$vma
	    if {$vma != $low + 4} then {
		send_log "$vma != $low + 4\n"
		fail "objcopy --adjust-section-vma +"
	    } else {
		pass "objcopy --adjust-section-vma +"
	    }
	}
    }

    regsub -all "\\+4" $arg "=[expr $low + 4]" argeq
    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec $argeq $tempfile ${copyfile}.srec"]
    if ![string equal "" $got] then {
	fail "objcopy --adjust-section-vma ="
    } else {
	set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -h ${copyfile}.srec"]
	set want "file format srec.*sec1\[ 	\]+\[0-9a-fA-F\]+\[ 	\]+(\[0-9a-fA-F\]+)"
	if ![regexp $want $got all vma] then {
	    fail "objcopy --adjust-section-vma ="
	} else {
	    set vma 0x$vma
	    if {$vma != $low + 4} then {
		send_log "$vma != $low + 4\n"
		fail "objcopy --adjust-section-vma ="
	    } else {
		pass "objcopy --adjust-section-vma ="
	    }
	}
    }
}

# Test stripping an object.

proc strip_test { } {
    global AR
    global CC
    global STRIP
    global STRIPFLAGS
    global NM
    global NMFLAGS
    global srcdir
    global subdir
    global READELF

    set test "strip"

    if { [target_compile $srcdir/$subdir/testprog.c tmpdir/testprog.o object debug] != "" } {
	untested $test
	return
    }

    set osabi_fail "false"
    if [is_elf_format] {
	verbose -log "$READELF -a tmpdir/testprog.o > tmpdir/osabi.in"
	set exec_output [remote_exec host "$READELF -h tmpdir/testprog.o" "" "/dev/null" "tmpdir/osabi.in"]
	if { [lindex $exec_output 0] != 0 } then {
	    fail "$test preserving OS/ABI"
	    set osabi_fail "true"
	} else {
	    verbose -log "grep OS/ABI tmpdir/osabi.in"
	    catch "exec grep OS/ABI tmpdir/osabi.in" osabi_in
	}
    }

    if [is_remote host] {
	set archive libstrip.a
	set objfile [remote_download host tmpdir/testprog.o]
	remote_file host delete $archive
    } else {
	set archive tmpdir/libstrip.a
	set objfile tmpdir/testprog.o
    }

    remote_file build delete tmpdir/libstrip.a

    set exec_output [binutils_run $AR "rc $archive ${objfile}"]
    set exec_output [prune_warnings $exec_output]
    if ![string equal "" $exec_output] {
	fail $test
	unresolved "$test preserving OS/ABI"
	return
    }

    set exec_output [binutils_run $STRIP "-g $archive"]
    set exec_output [prune_warnings $exec_output]
    if ![string equal "" $exec_output] {
	fail $test
	unresolved "$test preserving OS/ABI"
	return
    }

    set exec_output [binutils_run $STRIP "$STRIPFLAGS $archive"]
    set exec_output [prune_warnings $exec_output]
    if ![string equal "" $exec_output] {
	fail $test
	unresolved "$test preserving OS/ABI"
	return
    }

    if { $osabi_fail != "true" && [is_elf_format] } {
	verbose -log "$READELF -a tmpdir/testprog.o > tmpdir/osabi.out"
	set exec_output [remote_exec host "$READELF -h tmpdir/testprog.o" "" "/dev/null" "tmpdir/osabi.out"]
	if { [lindex $exec_output 0] != 0 } then {
	    fail "$test preserving OS/ABI"
	} else {
	    verbose -log "grep OS/ABI tmpdir/osabi.out"
	    catch "exec grep OS/ABI tmpdir/osabi.out" osabi_out
	    if { "$osabi_in" == "$osabi_out" } {
		pass "$test preserving OS/ABI"
	    } else {
		fail "$test preserving OS/ABI"
	    }
	}
    }

    if { [target_compile $srcdir/$subdir/testprog.c tmpdir/testprog.o object debug] != "" } {
	untested $test
	return
    }

    if [is_remote host] {
	set objfile [remote_download host tmpdir/testprog.o]
    } else {
	set objfile tmpdir/testprog.o
    }

    set exec_output [binutils_run $STRIP "$STRIPFLAGS $objfile"]
    set exec_output [prune_warnings $exec_output]
    if ![string equal "" $exec_output] {
	fail $test
	return
    }

    set exec_output [binutils_run $NM "-a $NMFLAGS $objfile"]
    set exec_output [prune_warnings $exec_output]
    if ![string match "*: no symbols*" $exec_output] {
	fail $test
	return
    }

    pass $test
}

strip_test

# Test stripping an object file with saving a symbol

proc strip_test_with_saving_a_symbol { } {
    global CC
    global STRIP
    global STRIPFLAGS
    global NM
    global NMFLAGS
    global srcdir
    global subdir

    set test "strip with saving a symbol"

    if { [target_compile $srcdir/$subdir/testprog.c tmpdir/testprog.o object debug] != "" } {
	untested $test
	return
    }

    if [is_remote host] {
	set objfile [remote_download host tmpdir/testprog.o]
    } else {
	set objfile tmpdir/testprog.o
    }

    set exec_output [binutils_run $STRIP "$STRIPFLAGS -K main -K _main $objfile"]
    set exec_output [prune_warnings $exec_output]
    if ![string equal "" $exec_output] {
	fail $test
	return
    }

    set exec_output [binutils_run $NM "$NMFLAGS $objfile"]
    set exec_output [prune_warnings $exec_output]
    if {![regexp {^([0-9a-fA-F]+)?[ ]+[TtDd] _?main} $exec_output]} {
	fail $test
	return
    }

    pass $test
}

strip_test_with_saving_a_symbol

# Build a final executable.

set exe [exeext]
set test_prog "testprog${exe}"

proc copy_setup { } {
    global srcdir
    global subdir
    global gcc_gas_flag
    global test_prog
    global host_triplet

    if {[target_info exists needs_status_wrapper] && \
	    [target_info needs_status_wrapper] != "0"} {
	set res [build_wrapper testglue.o]
    } else {
	set res ""
    }
    set flags { debug }

    if { [istarget *-*-uclinux*] && ![istarget tic6x-*-*] && ![istarget arm*-*-uclinuxfdpiceabi] } {
	return 1
    }

    if { $res != "" } {
	lappend flags "additional_flags=[lindex $res 1]"
	set add_libs "testglue.o"
    } else {
	set add_libs ""
    }

    if { [istarget *-*-linux*]
	 || [istarget *-*-gnu*] } {
	foreach i $gcc_gas_flag {
	    set flags "additional_flags=$i $flags"
	}
    }
    if { [target_compile "$srcdir/$subdir/testprog.c $add_libs" tmpdir/$test_prog executable $flags]  != "" } {
	return 2
    }

    set result [remote_load target tmpdir/$test_prog]
    set status [lindex $result 0]

    if { $status != "pass"  } {
	send_log "cannot run executable, status = ${status} on ${host_triplet}\n"
	return 3
    }

    return 0
}

# Test copying an executable.

proc copy_executable { prog flags test1 test2 } {
    global test_prog

    if [is_remote host] {
	set testfile [remote_download host tmpdir/$test_prog]
	set testcopy copyprog
    } else {
	set testfile tmpdir/$test_prog
	set testcopy tmpdir/copyprog
    }
    remote_file host delete $testcopy

    set exec_output [binutils_run $prog "$flags $testfile $testcopy"]

    if ![string equal "" $exec_output] {
	fail $test1
	if [string equal "" $test2] {
	    return
	}
	fail $test2
	return
    }

    if [is_remote host] {
	remote_upload host $testcopy tmpdir/copyprog
    }

    set status [remote_exec build "cmp" "tmpdir/$test_prog tmpdir/copyprog"]
    set exec_output [lindex $status 1]

    if [string equal "" $exec_output] then {
	pass $test1
    } else {
	send_log "$exec_output\n"
	verbose "$exec_output"

	# This will fail for many reasons.  For example, it will most
	# likely fail if a non-GNU linker is used.  Therefore, we do
	# not insist that it pass.  If you are using an assembler and
	# linker based on the same BFD as objcopy, it is worth
	# investigating to see why this failure occurs.  If we are
	# cross compiling, we assume that a GNU linker is being used,
	# and expect it to succeed.
	if {[isnative]} then {
	    setup_xfail "*-*-*"
	}

	# This also fails for some mips targets.  See elf32-mips.c
	# mips_elf_sym_is_global.
	if { [is_bad_symtab] } then {
	    setup_xfail "*-*-*"
	}

	setup_xfail "arm*-*-pe"
	setup_xfail "*-*-mingw*"
	setup_xfail "*-*-cygwin*"

	fail $test1
    }

    if [string equal "" $test2] {
	return
    }

    set output [remote_load target tmpdir/copyprog]
    set status [lindex $output 0]
    if { $status != "pass" } {
	fail $test2
    } else {
	pass $test2
    }
}

# Test stripping an executable

proc strip_executable { prog flags test1 test2 } {
    global NM
    global NMFLAGS
    global READELF

    remote_file build delete tmpdir/striprog
    remote_download build tmpdir/copyprog tmpdir/striprog
    if [is_remote host] {
	set copyfile [remote_download host tmpdir/striprog]
    } else {
	set copyfile tmpdir/striprog
    }

    set osabi_fail "false"
    if [is_elf_format] {
	verbose -log "$READELF -a ${copyfile} > tmpdir/osabi.in"
	set exec_output [remote_exec host "$READELF -h ${copyfile}" "" "/dev/null" "tmpdir/osabi.in"]
	if { [lindex $exec_output 0] != 0 } then {
	    fail "$test1 preserving OS/ABI"
	    set osabi_fail "true"
	} else {
	    verbose -log "grep OS/ABI tmpdir/osabi.in"
	    catch "exec grep OS/ABI tmpdir/osabi.in" osabi_in
	}
     }

    set exec_output [binutils_run $prog "$flags ${copyfile}"]
    if ![string equal "" $exec_output] {
	fail $test1
	if [string equal "" $test2] {
	    return
	}
	fail $test2
	return
    }

    if [is_remote host] {
	remote_upload host ${copyfile} tmpdir/striprog
    }

    if { $osabi_fail != "true" && [is_elf_format] } {
	verbose -log "$READELF -a ${copyfile} > tmpdir/osabi.out"
	set exec_output [remote_exec host "$READELF -h ${copyfile}" "" "/dev/null" "tmpdir/osabi.out"]
	if { [lindex $exec_output 0] != 0 } then {
	    fail "$test1 preserving OS/ABI"
	} else {
	    verbose -log "grep OS/ABI tmpdir/osabi.out"
	    catch "exec grep OS/ABI tmpdir/osabi.out" osabi_out
	    if { "$osabi_in" == "$osabi_out" } {
		pass "$test1 preserving OS/ABI"
	    } else {
		fail "$test1 preserving OS/ABI"
	    }
	}
    }

    set exec_output [binutils_run $NM "$NMFLAGS ${copyfile}"]
    if ![string match "*: no symbols*" $exec_output] {
	fail $test1
	return
    }

    if [string equal "" $test2] {
	return
    }

    set result [remote_load target tmpdir/striprog]
    set status [lindex $result 0]
    if { $status != "pass" } {
	fail $test2
        return
    }

    pass $test2
}

# Test stripping an executable with saving a symbol

proc strip_executable_with_saving_a_symbol { prog flags test1 test2 } {
    global NM
    global NMFLAGS

    remote_file build delete tmpdir/striprog
    remote_download build tmpdir/copyprog tmpdir/striprog
    if [is_remote host] {
	set copyfile [remote_download host tmpdir/striprog]
    } else {
	set copyfile tmpdir/striprog
    }

    set exec_output [binutils_run $prog "$flags ${copyfile}"]
    if ![string equal "" $exec_output] {
	fail $test1
	if [string equal "" $test2] {
	    return
	}
	fail $test2
	return
    }

    set exec_output [binutils_run $NM "$NMFLAGS ${copyfile}"]
    if { [istarget mmix-knuth-mmixware] } {
	# Whenever there's a symbol in the mmo format, there's the symbol
	# Main, so remove it manually from the expected output for sake of
	# this test.

	# Using "" not {} to get the \n and \r translated.
	regsub "^\[0-9a-fA-F\]+\[ \]+T Main\[\n\r\]+" $exec_output "" exec_output
    }

    if {![regexp {^([0-9a-fA-F]+)?[ ]+[TtDd] _?main} $exec_output]} {
	fail $test1
	return
    }

    if [string equal "" $test2] {
	return
    }

    if [is_remote host] {
	remote_upload host ${copyfile} tmpdir/striprog
    }

    set result [remote_load target tmpdir/striprog]
    set status [lindex $result 0]
    if { $status != "pass" } {
	fail $test2
        return
    }

    pass $test2
}

# Test keeping only debug symbols of an executable

proc keep_debug_symbols_and_test_copy { prog1 flags1 test1 prog2 flags2 test2 } {
    remote_file build delete tmpdir/striprog
    remote_download build tmpdir/copyprog tmpdir/striprog
    if [is_remote host] {
	set copyfile [remote_download host tmpdir/striprog]
    } else {
	set copyfile tmpdir/striprog
    }

    set exec_output [binutils_run $prog1 "$flags1 ${copyfile}"]
    if ![string equal "" $exec_output] {
	fail $test1
	return
    }
    pass $test1

    set exec_output [binutils_run $prog2 "$flags2 ${copyfile}"]
    if ![string equal "" $exec_output] {
	fail $test2
	return
    }
    pass $test2
}

# Tests that in a debug only copy of a file the sections
# headers whose types have been changed to NOBITS still
# retain their sh_link fields.

proc keep_debug_symbols_and_check_links { prog flags test } {
    global READELF

    remote_file build delete tmpdir/striprog
    remote_download build tmpdir/copyprog tmpdir/striprog
    if [is_remote host] {
	set copyfile [remote_download host tmpdir/striprog]
    } else {
	set copyfile tmpdir/striprog
    }

    set exec_output [binutils_run $prog "$flags ${copyfile}"]
    if ![string equal "" $exec_output] {
	fail $test
	return
    }

    set got [binutils_run $READELF "-S --wide ${copyfile}"]

    set fails 0
    # Regexp to match a section with NOBITS type and extract its name and sh_link fields
    while {[regexp \
		{[^a-zA-Z]+([a-zA-Z0-9_\.]+)[ 	]+NOBITS[ 	]+[0-9a-fA-F]+ [0-9a-fA-F]+ [0-9a-fA-F]+ [0-9]+[ A]+([0-9]+)(.*)} \
		$got all name link rest]} {
	set sh_link 0x$link
	if {$sh_link == 0} {
	    # Only some NOBITS sections should have a non-zero sh_link field.
	    # Look for them by name.
	    verbose "NOBITS section .$name has a 0 sh_link field\n"
	    switch $name {
		"rela.*"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"rel.*"		{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"hash"		{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"gnu_version"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"dynsym"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"gnu.version_r"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"dynamic"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"symtab"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
	    }
	}
	set got $rest
    }

    if {$fails == 0} {
	pass $test
    } else {
	fail $test
    }
}

# For ELF relocatables, test that --only-keep-debug
# marks non-debug output sections as NOBITS.

proc keep_debug_symbols_for_elf_relocatable { prog flags test } {
    global srcdir
    global subdir
    global READELF

    if { [target_compile $srcdir/$subdir/testprog.c tmpdir/testprog.o object debug] != "" } {
	untested $test
	return
    }

    if [is_remote host] {
	set relocatable [remote_download host tmpdir/testprog.o]
    } else {
	set relocatable tmpdir/testprog.o
    }

    set non_debug_sections {}
    set got [binutils_run $READELF "-S --wide ${relocatable}"]
    while { [regexp \
	    {[^a-zA-Z]+([a-zA-Z0-9_\.]+)[ \t]+([A-Z]+)[ \t]+[0-9a-f]+ [0-9a-f]+ [0-9a-f]+ [0-9]+[ \t]+([A-Z]*)[ \t]+[0-9]+(.*)} \
	    $got all name type flag rest] } {
	if { $type != "NOTE" && [regexp {[AG]} $flag] } {
	    lappend non_debug_sections $name
	}
	set got $rest
    }

    set exec_output [binutils_run $prog "$flags ${relocatable}"]
    if ![string equal "" $exec_output] {
	fail $test
	return
    }

    set fails 0
    set got [binutils_run $READELF "-S --wide ${relocatable}"]
    while { [regexp \
	    {[^a-zA-Z]+([a-zA-Z0-9_\.]+)[ \t]+([A-Z]+)[ \t]+[0-9a-f]+ [0-9a-f]+ [0-9a-f]+ [0-9]+[ \t]+[A-Z]*[ \t]+[0-9]+(.*)} \
	    $got all name type rest] } {
	if { [lsearch -exact $non_debug_sections $name] >= 0 && $type != "NOBITS" } {
	    set fails 1
	    send_log "Expected SHT_NOBITS type for .$name\n"
	}
	set got $rest
    }
    if { $fails == 1 } {
	fail $test
	return
    }

    pass $test
}

set test1 "simple objcopy of executable"
set test1r "run objcopy of executable"
set test2 "strip executable"
set test2r "run stripped executable"
set test3 "strip executable with saving a symbol"
set test3r "run stripped executable with saving a symbol"
set test4 "keep only debug data"
set test5 "simple objcopy of debug data"
if [is_elf_format] {
    set test6 "NOBITS sections retain sh_link field"
    set test7 "--only-keep-debug for ELF relocatables"
}

switch [copy_setup] {
    "1" {
	# do nothing
    }
    "2" {
	untested $test1
	untested $test1r
	untested $test2
	untested $test2r
	untested $test3
	untested $test3r
	untested $test4
	untested $test5
	if [is_elf_format] {
	    untested $test6
	}
    }
    "3" {
	copy_executable "$OBJCOPY" "$OBJCOPYFLAGS" "$test1" ""
	unsupported $test1r
	strip_executable "$STRIP" "$STRIPFLAGS" "$test2" ""
	unsupported $test2r
	strip_executable_with_saving_a_symbol "$STRIP" "-K main -K _main $STRIPFLAGS" "$test3" ""
	unsupported $test3r
	keep_debug_symbols_and_test_copy "$STRIP" "--only-keep-debug $STRIPFLAGS" "$test4" \
					 "$OBJCOPY" "$OBJCOPYFLAGS" "$test5"
	if [is_elf_format] {
	    keep_debug_symbols_and_check_links "$STRIP" "--only-keep-debug $STRIPFLAGS" "$test6"
	    keep_debug_symbols_for_elf_relocatable "$STRIP" "--only-keep-debug $STRIPFLAGS" "$test7"
	}
    }
    "0" {
	copy_executable "$OBJCOPY" "$OBJCOPYFLAGS" "$test1" "$test1r"
	strip_executable "$STRIP" "$STRIPFLAGS" "$test2" "$test2r"
	strip_executable_with_saving_a_symbol "$STRIP" "-K main -K _main $STRIPFLAGS" "$test3" "$test3r"
	keep_debug_symbols_and_test_copy "$STRIP" "--only-keep-debug $STRIPFLAGS" "$test4" \
					 "$OBJCOPY" "$OBJCOPYFLAGS" "$test5"
	if [is_elf_format] {
	    keep_debug_symbols_and_check_links "$STRIP" "--only-keep-debug $STRIPFLAGS" "$test6"
	    keep_debug_symbols_for_elf_relocatable "$STRIP" "--only-keep-debug $STRIPFLAGS" "$test7"
	}
    }
}

proc objcopy_test_readelf {testname srcfile} {
    global OBJCOPY
    global OBJCOPYFLAGS
    global READELF
    global srcdir
    global subdir

    if {![binutils_assemble $srcdir/$subdir/${srcfile} tmpdir/bintest.o]} then {
	unsupported "objcopy ($testname)"
	return
    }

    verbose -log "$OBJCOPY $OBJCOPYFLAGS tmpdir/bintest.o tmpdir/copy.o"
    set exec_output [remote_exec host "$OBJCOPY $OBJCOPYFLAGS tmpdir/bintest.o tmpdir/copy.o"]
    if { [lindex $exec_output 0] != 0
	 || ![string equal "" [lindex $exec_output 1]] } then {
	fail "objcopy ($testname)"
	return
    }

    verbose -log "$READELF -a tmpdir/bintest.o > tmpdir/bintest.o.out"
    set exec_output [remote_exec host "$READELF -a tmpdir/bintest.o" "" "/dev/null" "tmpdir/bintest.o.out"]
    if { [lindex $exec_output 0] != 0 } then {
	fail "objcopy ($testname)"
	return
    }
    set exec_output [prune_warnings [lindex $exec_output 1]]
    if ![string equal "" $exec_output] then {
	unresolved "objcopy ($testname)"
	return
    }

    verbose -log "$READELF -a tmpdir/copy.o > tmpdir/copy.o.out"
    set exec_output [remote_exec host "$READELF -a tmpdir/copy.o" "" "/dev/null" "tmpdir/copy.o.out"]
    if { [lindex $exec_output 0] != 0 } then {
	fail "objcopy ($testname)"
	return
    }
    set exec_output [prune_warnings [lindex $exec_output 1]]
    if ![string equal "" $exec_output] then {
	unresolved "objcopy ($testname)"
	return
    }

    verbose -log "diff tmpdir/bintest.o.out tmpdir/copy.o.out"
    catch "exec diff tmpdir/bintest.o.out tmpdir/copy.o.out" exec_output
    set exec_output [prune_warnings $exec_output]

    if [string equal "" $exec_output] then {
	pass "objcopy ($testname)"
    } else {
	fail "objcopy ($testname)"
    }
}

proc objcopy_test_symbol_manipulation {} {
    global srcdir
    global subdir

    set test_list [lsort [glob -nocomplain $srcdir/$subdir/symbols-*.d]]
    foreach t $test_list {
        # We need to strip the ".d", but can leave the dirname.
        verbose [file rootname $t]
        run_dump_test [file rootname $t]
    }

    if { [supports_gnu_unique] } {
	run_dump_test "weaken-gnu-unique"
    }
}

proc objcopy_test_elf_common_symbols {} {
    global srcdir
    global subdir

    # hpux has a non-standard common directive.
    if { [istarget "*-*-hpux*"] } then {
	return
    }

    set test_list [lsort [glob -nocomplain $srcdir/$subdir/common-*.d]]
    foreach t $test_list {
        # We need to strip the ".d", but can leave the dirname.
        verbose [file rootname $t]
        run_dump_test [file rootname $t]
    }
}

# ia64 specific tests
if { ([istarget "ia64-*-elf*"]
       || [istarget "ia64-*-linux*"]) } {
    objcopy_test "ia64 link order" link-order.s object "" ""
}

# ELF specific tests
set elf64 ""
if [is_elf_format] {
    objcopy_test_symbol_manipulation
    objcopy_test_elf_common_symbols
    objcopy_test "ELF unknown section type" unknown.s object "" ""
    objcopy_test_readelf "ELF group 1" group.s
    objcopy_test_readelf "ELF group 2" group-2.s
    objcopy_test_readelf "ELF group 3" group-3.s
    objcopy_test_readelf "ELF group 4" group-4.s
    objcopy_test_readelf "GNU_MBIND section" mbind1.s
    run_dump_test "group-5"
    run_dump_test "group-6"
    run_dump_test "group-7a"
    run_dump_test "group-7b"
    run_dump_test "group-7c"
    run_dump_test "copy-1"
    run_dump_test "note-1"
    # Use copytest.o from the note-1 test to determine ELF32 or ELF64
    if [is_elf64 tmpdir/copytest.o] {
	set elf64 "--defsym ELF64=1"
	run_dump_test "note-2-64"
	run_dump_test "note-3-64"
	run_dump_test "note-4-64"
	run_dump_test "note-6-64"
    } else {
	run_dump_test "note-2-32"
	run_dump_test "note-3-32"
	run_dump_test "note-4-32"
	run_dump_test "note-6-32"
    }
    run_dump_test "note-5"
}

run_dump_test "copy-2"
run_dump_test "copy-3"
run_dump_test "copy-4"
run_dump_test "copy-5"
run_dump_test "copy-6"

# Use bintest.o from the copy-4 test to determine ELF reloc type
set reloc_format rel
if { [is_elf_format] && [is_rela tmpdir/bintest.o] } {
    set reloc_format rela
}
run_dump_test "pr19020a"
run_dump_test "pr19020b"

if [is_elf_format] {
    run_dump_test "strip-1"
    run_dump_test "strip-2"
    run_dump_test "strip-3"
    run_dump_test "strip-4"
    run_dump_test "strip-5"
    run_dump_test "strip-6"
    run_dump_test "strip-7"
    run_dump_test "strip-8"
    run_dump_test "strip-9"
    run_dump_test "strip-12"

    if { [istarget "mips64*-*-openbsd*"] \
	 || [istarget "mips64*-*-*-gnuabi64"] } {
	set reloc_format mips64
    }
    # A relocation type not supported by any target
    if { [istarget "nds32*-*"] } {
	set reloc 255
    } else {
	set reloc 215
    }
    run_dump_test "strip-13" [list \
				  [list source strip-13${reloc_format}.s] \
				  [list as "${elf64} --defsym RELOC=${reloc}"]]
    # Select a relocation number that corresponds to one actually
    # supported by the target and ABI being tested.
    if { [istarget "aarch64*-*"] } {
	set reloc 259
    } elseif { [istarget "ia64*-*"] \
	       || [istarget "m32r*-*"] \
	       || [istarget "nds32*-*"] \
	       || [istarget "v850*-*"] } {
	set reloc 50
    } elseif { [istarget "pru-*"] } {
	set reloc 11
    } else {
	set reloc 1
    }
    run_dump_test "strip-14" [list \
				  [list source strip-14${reloc_format}.s] \
				  [list as "${elf64} --defsym RELOC=${reloc}"]]
    run_dump_test "strip-15" [list \
				  [list source strip-15${reloc_format}.s] \
				  [list as "${elf64} --defsym RELOC=${reloc}"]]

    # This requires STB_GNU_UNIQUE support with OSABI set to GNU.
    if { [supports_gnu_unique] } {
	run_dump_test "strip-10"
    }
    run_dump_test "strip-11"

    if { [istarget "i*86-*"] || [istarget "x86_64-*-*"] } {
	# Check to make sure we don't strip a symbol named in relocations.
	set test "objcopy keeps symbols needed by relocs"

	set srcfile $srcdir/$subdir/needed-by-reloc.s

	if {![binutils_assemble $srcfile tmpdir/bintest.o]} then {
	    unsupported $test
	} else {
	    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS --strip-symbol=foo tmpdir/bintest.o ${copyfile}.o"]

	    if [regexp "not stripping symbol `foo' because it is named in a relocation" $got] {
		pass $test
	    } else {
		fail $test
	    }
	}
    }

    # The symbol table for some MIPS targets is sorted differently than
    # the ELF canonical order, so the regexps in localize-hidden-1.d fail
    # to match.
    if { [is_bad_symtab] } then {
	setup_xfail "*-*-*"
    }
    run_dump_test "localize-hidden-1"
    run_dump_test "testranges"
    run_dump_test "testranges-ia64"

    run_dump_test "add-section"
    run_dump_test "add-symbol"
    run_dump_test "add-empty-section"

    run_dump_test "exclude-1a"
    run_dump_test "exclude-1b"

    run_dump_test "only-section-01"
    run_dump_test "remove-section-01"

    run_dump_test "keep-section-1"
    run_dump_test "keep-section-2"

    # Test the remove relocation functionality
    set test_list [lsort [glob -nocomplain $srcdir/$subdir/remove-relocs-*.d]]
    foreach t $test_list {
        # We need to strip the ".d", but can leave the dirname.
        verbose [file rootname $t]
        run_dump_test [file rootname $t]
    }

    # Test --strip-section-headers
    run_dump_test "strip-section-headers-1" [list \
			  [list source strip-15${reloc_format}.s] \
			  [list as "${elf64} --defsym RELOC=${reloc}"]]
}
run_dump_test "localize-hidden-2"

# Test objcopying an object file without global symbol

proc objcopy_test_without_global_symbol { } {
    global OBJCOPY
    global OBJCOPYFLAGS
    global OBJDUMP
    global OBJDUMPFLAGS
    global srcdir
    global subdir

    set test "strip without global symbol "

    if { [target_compile $srcdir/$subdir/pr19547.c tmpdir/pr19547.o object debug] != "" } {
	untested $test
	return
    }

    if [is_remote host] {
	set objfile [remote_download host tmpdir/pr19547.o]
    } else {
	set objfile tmpdir/pr19547.o
    }

    set exec_output [binutils_run $OBJCOPY "$OBJCOPYFLAGS --strip-unneeded $objfile"]
    set exec_output [prune_warnings $exec_output]
    if ![string equal "" $exec_output] {
	fail $test
	return
    }

    set exec_output [binutils_run $OBJDUMP "$OBJDUMPFLAGS -t $objfile"]
    set exec_output [prune_warnings $exec_output]
    if {![regexp "no symbols" $exec_output]} {
	fail $test
	return
    }

    pass $test
}

# The AArch64 and ARM targets preserve mapping symbols
# in object files, so they will fail this test.
setup_xfail aarch64*-*-* arm*-*-*

objcopy_test_without_global_symbol

# objcopy remove relocation from executable test

proc objcopy_remove_relocations_from_executable { } {
    global OBJCOPY
    global srcdir
    global subdir
    global READELF

    set test "remove-section relocation sections"

    if { [target_compile $srcdir/$subdir/testprog.c tmpdir/pr23611 executable debug] != "" } {
	untested $test
	return
    }

    if [is_remote host] {
	set objfile [remote_download host tmpdir/pr23611]
    } else {
	set objfile tmpdir/pr23611
    }
    set out tmpdir/pr23611.out

    set exec_output1 [binutils_run $OBJCOPY "-R .rela.plt -R .rela.dyn -R .rel.plt -R .rel.dyn $objfile $out"]

    set exec_output1 [prune_warnings $exec_output1]
    if ![string equal "" $exec_output1] {
	fail $test
	return
    }

    set exec_output2 [binutils_run $READELF "-S $out"]
    if { [string match "*.rel.plt*" $exec_output2] || [string match "*.rela.plt*" $exec_output2] || [string match "*.rel.dyn*" $exec_output2] || [string match "*.rela.dyn*" $exec_output2] } {
	fail $test
	return
    }
    pass $test
}

if [is_elf_format] {
    objcopy_remove_relocations_from_executable
}

run_dump_test "pr23633"

run_dump_test "set-section-alignment"

setup_xfail "hppa*-*-*"
setup_xfail "spu-*-*"
clear_xfail "hppa*64*-*-hpux*" "hppa*-*-linux*" "hppa*-*-lites*"
clear_xfail "hppa*-*-*n*bsd*" "hppa*-*-*elf*"
if { [istarget pdp11-*-*] } {
    set src "pr25662-pdp11.s"
} else {
    set src "pr25662.s"
}

set ldflags "-T$srcdir/$subdir/pr25662.ld"
if { [istarget *-*-cygwin] || [istarget *-*-mingw*] } {
   append ldflags " --disable-reloc-section"
}

#xcoff doesn't support arbitrary sections
if { ![is_xcoff_format] } {
    objcopy_test "pr25662" $src executable "" $ldflags
}

run_dump_test "rename-section-01"
