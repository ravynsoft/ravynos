# Esperanto language file for GNU Bash.
# Copyright (C) 2011 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Sergio Pokrovskij <sergio.pokrovskij@gmail.com>, 1998, ... 2020.
#
# -*- eval: (po-consider-source-path "~/Documents/Eo/Work/i18n/5.1/bash-5.1/builtins"); -*-
# -*- eval: (po-consider-source-path "~/Documents/Eo/Work/i18n/5.1/bash-5.1"); -*-
# Stilaj notoj:
# La angulaj citiloj limigas «plurajn vortojn»,
# 99-66 estas la citiloj de „unuvortaĵo‟
#
# La mesaĝojn pri internaj eraroj (markitajn per XXX) probable malnecesas traduki.
#
# ---- Glosaro:
# associative array         asocitabelo (info "(bash)Arrays")
# brace expansion           vinkulmalvolvo
# callback                  retrovoko
# compound array assignment tutopa tabelvalorizo
# extended file attributes  kromatributoj (de dosiero)
# to force                  ... per superforto
# granted                   jesigita
# here-document             tuj-dokumento (info "(bash)Redirections")
# indexed array             entjerindica tabelo (info "(bash)Arrays")
# positional parameter      numerparametro ($1 ...) (info "(bash)Positional Parameters")
# resolve (symbolic links)  elnodigi
# special builtin           speciala komando (info "(coreutils)Special built-in utilities")
# substitution              anstataŭigo (info "(bash)Shell Expansions")
# unset                     malvalorizi (variablon); malaktivigi, malŝalti (opcion, nomon)
msgid ""
msgstr ""
"Project-Id-Version: GNU bash 5.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2020-12-13 10:53+0700\n"
"Last-Translator: Sergio Pokrovskij <sergio.pokrovskij@gmail.com>\n"
"Language-Team: Esperanto <translation-team-eo@lists.sourceforge.net>\n"
"Language: eo\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "Misa tabel-indico"

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: ne plu nomreferenco (la atributo nameref forigitas)"

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: Maleblas konverti entjerindican tabelon en asocitabelon"

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: Valorizato havu nombran indicon"

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: Valorizante per asocitabelo uzu indicon"

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: Ne prosperis krei: %s"

# XXX: internal_error
#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: Mankas klavartabelo por komando"

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: La unua ne-blankspaca signo ne estas „\"‟"

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "Mankas ferma „%c‟ en %s"

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: Mankas disiga dupunkto"

#: bashline.c:4733
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "«%s»: Ne eblas malligi en komandaj klavaĵoj"

# XXX: internal_error
#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "vinkulmalvolvo: Maleblas memorhavigo por %s"

# XXX: internal_error
#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "vinkulmalvolvo: Fiaskis memorhavigo por %u elementoj"

# XXX: internal_error
#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "vinkulmalvolvo: Fiaskis memorhavigo por %s"

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "%s: Maltaŭgas por uzi kiel alinomon"

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "liniredaktado ne estas ebligita"

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "„%s‟: Misa nomo por klavartabelo"

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: Ne eblas legi: %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "%s: Nekonata funkcinomo"

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s malhavas klavligon\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s vokeblas per "

#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "%s: Ne eblas malligi"

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "iteracinombrilo"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "Sencas nur en iteracio „for‟, „while‟ aŭ „until‟"

# caller [expr] =>
# caller [ESPRIMO]
#: builtins/caller.def:136
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Liveras la kuntekston de la kuranta procedurvoko.\n"
"\n"
"    Se ESPRIMO malestas, liveru «$line $filename».  Se ESPRIMO\n"
"    ĉeestas, liveru «$line $subroutine $filename»; ĉi tiu krominformo\n"
"    uzeblas por vidigi la vok-stakon.\n"
"\n"
"    La valoro de ESPRIMO indikas, kiom da vokkadroj retroiri disde la\n"
"    kuranta; la pinta kadro havas la numeron 0."

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "HOME malhavas valoron"

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "Tro multe da argumentoj"

#: builtins/cd.def:342
msgid "null directory"
msgstr "NUL-dosierujo"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "OLDPWD malhavas valoron"

#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "linio %dª: "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "Averto: "

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s: Uzmaniero: "

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: La opcio bezonas argumenton"

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: Necesas nombra argumento"

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s: Ne trovita"

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s: Misa opcio"

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s: Misa opcinomo"

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "„%s‟ ne estas taŭga nomo"

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "Misa okuma nombro"

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "Misa 16uma nombro"

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "Misa nombro"

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: Misa signalindiko"

#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "„%s‟: Nek proceznumero, nek taŭga laborindiko"

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s: Nurlega variablo"

#: builtins/common.c:273
#, fuzzy, c-format
msgid "%s: cannot assign"
msgstr "%s: Malaktivigo fiaskis"

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s estas ekster sia variejo"

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "argumento"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s estas ekster sia variejo"

#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s: Ne estas tia laboro"

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s: Ĉi tiu ŝelo ne disponigas laborregadon"

#: builtins/common.c:301
msgid "no job control"
msgstr "Laborregado ne disponeblas"

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s: Limigita"

#: builtins/common.c:313
msgid "restricted"
msgstr "limigita"

#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "„%s‟ ne estas primitiva komando ŝela"

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "Eraro ĉe skribo: %s"

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "Eraro ĉe agordado de terminalaj atributoj: %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "Eraro ĉe akiro de terminalaj atributoj: %s"

#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: Eraro ĉe provo determini la kurantan dosierujon: %s: %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: Ambigua laborindiko"

#: builtins/common.c:971
msgid "help not available in this version"
msgstr "helpilo mankas en ĉi tiu versio"

#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: Malaktivigo fiaskis: nurlega %s"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s: Malaktivigo fiaskis"

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s: Misa nomo de ago"

#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s: Kompletigo ne estas specifita"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "Averto: La opcio -F povas funkcii alie ol vi eble supozas"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "Averto: La opcio -C povas funkcii alie ol vi eble supozas"

#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "Ni ne estas en plenumado de kompletiga funkcio"

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "Uzeblas nur ene de funkcio"

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "„-f‟ ne estas uzebla por fari funkciojn"

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s: Nurlega funkcio"

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: Referenca variablo ne povas esti tabelo"

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: Nomreferenca variablo ne referencu sin mem"

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr "%s: Cikla nomreferenco"

#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "„%s“: Misa variablonomo por nomreferenco"

#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: Ĉi tiel ne eblas neniigi tabelvariablojn"

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: Ne eblas konverti asocitabelon en entjerindican tabelon"

#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: Tutopa tabelvalorizo citila estas evitinda"

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "Rultempa ŝargo ne disponeblas"

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "Ne malfermiĝis dinamika biblioteko %s: %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "Mankas %s en la dinamika biblioteko%s: %s"

#: builtins/enable.def:422
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: primitiva komando dinamika jam ŝargitas"

#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "Ŝarga funkcio por %s liveris fiaskon (%d): ne ŝargite"

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: Ne ŝargita dinamike"

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: Ne eblas forigi: %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s estas dosierujo"

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s: Ne ordinara dosiero"

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s: Tro granda dosiero"

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: Neplenumebla duuma dosiero"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: Maleblas plenumi: %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "adiaŭ\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "La ŝelo ne estas saluta; eliru per «exit»"

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Restas haltigitaj laboroj.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Restas rulataj laboroj.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "Komando ne trovita"

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr "Historia indiko"

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: Ne malfermiĝis labordosiero: %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "kuranta"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "La laboro %d estas lanĉita sen laborregado"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: Misa opcio -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: La opcio bezonas argumenton -- %c\n"

#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "Nomkonservado (haketado, «hashing») estas malŝaltita"

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: Hakettabelo estas malplena\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "Trafoj\tKomando\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Ŝelaj komandoj kongruaj kun la ŝlosilvorto «"
msgstr[1] "Ŝelaj komandoj kongruaj kun la ŝlosilvortoj «"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"»\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"Helpaĵo pri „%s‟ malestas.\n"
"Provu «help help» aŭ «man -k %s» aŭ «info %s»."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: Fiaskis malfermo de %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Jenaj komandoj estas enkonstruitaj.  Tajpu „help‟ por eligi la liston.\n"
"Tajpu «help NOMO» por informoj pri la funkcio NOMO.\n"
"Uzu «info bash» por la ĝenerala informo pri la ŝelo.\n"
"Uzu «man -k» aŭ «info» por informo pri komandoj ĉi tie ne listigitaj.\n"
"\n"
"Steleto (*) tuj post nomo indikas, ke la komando estas malebligita.\n"
"\n"

#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "Ne pli ol unu el -anrw estas uzebla"

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "pozicio en la historio"

#: builtins/history.def:338
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: Maltaŭga tempomarko"

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: Historia malvolvo fiaskis"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: inlib fiaskis"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "La uzo de „-x‟ malebligas aliajn opciojn"

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: Argumento estu proceznumero aŭ laborindiko"

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Nekonata eraro"

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "Mankas esprimo"

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: ĝi ne estas entjerindica tabelo"

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: Misa indiko de dosiernumero"

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: Misa dosiernumero: %s"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s: Misa lininombro"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: Misa tabelbazo"

# Supozeble callback => retrovoko ??
#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: Misa kvanto ĉe retrovoko"

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "Mankas nomo de tabelvariablo"

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr "necesas subteno de tabelvariabloj"

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "„%s‟: Mankas formata signo"

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "%c: Misa tempoformato"

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "„%c‟: Misa signo formata"

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "Averto: %s: %s"

# XXX: internal_error
#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr "Miso ĉe analizado de formato: %s"

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "Mankas 16uma cifero por \\x"

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "Post „%c‟ mankas unikoda cifero"

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "Ne estas alia dosierujo"

#: builtins/pushd.def:360
#, c-format
msgid "%s: invalid argument"
msgstr "%s: Maltaŭga argumento"

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "<mankas kuranta dosierujo>"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "Dosierujstako malplenas"

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "indico de dosierujstako"

# dirs [-clpv] [+N] [-N]
#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Listigu la kurantan dosierujstakon. La dosierujoj trafas en\n"
"    la stakon per la komando „pushd‟ kaj estas forigeblaj per la\n"
"    komando „popd‟.\n"
"\n"
"    Opcioj:\n"
"    -c\tforviŝu la dosierujstakon (forigu ĉiujn erojn)\n"
"    -l\tne uzu tildon en la dosierujnomoj bazitaj relative\n"
"      \tal via hejma dosierujo\n"
"    -p\teligu dosierujstakon lokante po unu eron sur linio\n"
"    -v\teligu dosierujstakon lokante po unu eron sur linio,\n"
"\tprefiksante la dosierujnomon per ĝia numero en la stako\n"
"\n"
"    Argumentoj:\n"
"    +N\teligu la Nan eron nombrante de maldekstre en la listo eligebla\n"
"\tper „dirs‟ sen opcioj, numerante ekde 0.\n"
"\n"
"    -N\teligu la Nan eron nombrante de dekstre en la listo eligebla\n"
"\tper „dirs‟ sen opcioj, numerante ekde 0."

# pushd [dir | +N | -N] [-n]
#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Surstakigu dosierujon sur la stakon da dosierujoj, aŭ cikle ŝovu\n"
"    la stakon tiel, ke la nova stakpinto iĝu la kuranta dosierujo.\n"
"    Senargumente, permutu la du plej suprajn dosierujojn de la stako.\n"
"\n"
"    Opcioj:\n"
"    -n\tNe ŝanĝu la kurantan dosierujon surstakigante dosierujon sur\n"
"    \tla stakon; do, nur la stakon ŝanĝu.\n"
"\n"
"    +N\tCikle ŝovu la stakon tiel ke la Nª dosierujo (nombrante de\n"
"    \tmaldekstre en la listo eligebla per „dirs‟, numerante de 0)\n"
"        iĝu la pinta.\n"
"\n"
"    -N\tCikle ŝovu la stakon tiel ke la Nª dosierujo (nombrante de\n"
"    \tdekstre en la listo eligebla per „dirs‟, numerante de 0) iĝu\n"
"        la pinta.\n"
"\n"
"    dir\tsurstakigu la dosierujon dir kaj faru ĝin la nova kuranta\n"
"    \tdosierujo labora.\n"
"\n"
"    Vi povas vidigi la stakon da dosierujoj per la komando „dirs‟."

# popd [+N | -N] [-n]
#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Elstakigu erojn el la stako de dosierujoj.  Senargumente, forigu la\n"
"    pintan dosierujon kaj iru (cd) en la novan pintan dosierujon.\n"
"\n"
"\n"
"    Opcioj:\n"
"    -n\tNe ŝanĝu la kurantan dosierujon demetante dosierujon el la\n"
"\tstako; do, nur la stakon ŝanĝu.\n"
"\n"
"    Argumentoj:\n"
"    +N\tforigu la Nan eron de maldekstre de la listo eligebla per\n"
"\t„dirs‟, numerante ekde 0.  Ekz-e: «popd +0» forigas la plej\n"
"\tmaldekstran dosierujon; «popd +1», ĝian najbaron.\n"
"\n"
"    -N\tforigu la Nan eron de dekstre de la listo eligebla per „dirs‟,\n"
"\tnumerante ekde 0.  Ekz-e: «popd -0» forigas la lastan\n"
"\tdosierujon; «popd -1», la antaŭlastan.\n"
"\n"
"    Vi povas vidigi la stakon da dosierujoj per la komando „dirs‟."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: Misa indiko de atendotempo"

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "Lega (read) eraro: %d: %s"

#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr ""
"„return‟ sencas nur en funkcio aŭ punkte vokita („.‟, „source‟) skripto"

#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr "Ne eblas samtempe malaktivigi funkcion kaj variablon"

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s: Ne tabela variablo"

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s: Ne funkcio"

#: builtins/setattr.def:194
#, c-format
msgid "%s: cannot export"
msgstr "%s: Ne eblas eksporti"

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "Nombrilo de „shift‟"

#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "Maleblas samtempe ŝalti kaj malŝalti ŝelan opcion"

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: Misa nomo de ŝela opcio"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "Necesas dosiernoma argumento"

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s: Dosiero ne trovita"

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "Ne eblas halteti"

#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "Ne eblas haltetigi salutan ŝelon"

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "„%s‟ alinomas jenon: «%s»\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "„%s‟ estas ŝlosilvorto de la ŝelo\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s estas funkcio\n"

#: builtins/type.def:299
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "„%s‟ estas speciala primitiva ŝelkomando\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "„%s‟ estas primitiva komando de la ŝelo\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "„%s‟ estas „%s‟\n"

#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "„%s‟ estas metita en hakettabelon (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: Maltaŭga argumento por limo"

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "„%c‟: Misa komando"

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: Fiaskis provo legi limon: %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "limo"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: Malprosperis ŝanĝi limon: %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "Okuma nombro"

# Misa modifilo: «umask Z-w» aŭ «umask aZw»
#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "„%c‟: Maltaŭga simbolo por atingorajta modifilo"

# Misa kategorio: ne [rw] ktp
#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "„%c‟: La signo ne estas simbolo de atingorajta kategorio"

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " linio "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "La ĵusa komando: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Ĉesigado ..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr "INFORMO: "

#: error.c:310
#, fuzzy, c-format
msgid "DEBUG warning: "
msgstr "Averto: "

#: error.c:488
msgid "unknown command error"
msgstr "Nekonata komand-eraro"

#: error.c:489
msgid "bad command type"
msgstr "Misa komandotipo"

#: error.c:490
msgid "bad connector"
msgstr "Misa stir-operacio"

#: error.c:491
msgid "bad jump"
msgstr "Misa salto"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s: Neligita variablo"

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aTro longe sen enigo: Aŭtomata seancofino\n"

# XXX: internal error:
#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "Fiaskis provo nomumi la disponaĵon «/dev/null» ĉefenigujo: %s"

# XXX: internal error:
#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: „%c‟: Misa formatsigno"

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: la kunprocezo [%d:%s] ankoraŭ ekzistas"

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "Eraro en dukto"

#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: La ingado de „eval“oj superis sian maksimumon (%d)"

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: La ingado de „source“oj superis sian maksimumon (%d)"

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: La ingado de funkcioj superis sian maksimumon (%d)"

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: Malpermesitas uzi „/‟ en komandonomoj"

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s: Komando ne trovita"

# XXX: internal error:
#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5975
#, fuzzy, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: Neplenumebla duuma dosiero"

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: Misa interpretilo"

#: execute_cmd.c:6037
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: Neplenumebla duuma dosiero: %s"

#: execute_cmd.c:6123
#, c-format
msgid "`%s': is a special builtin"
msgstr "„%s‟ estas primitiva komando speciala"

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "Ne eblas kunnomumi al dosiernumero %d la dosiernumeron %d"

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "Tro profunda rekursio en esprimo"

#: expr.c:291
msgid "recursion stack underflow"
msgstr "Rekursistako elĉerpita"

#: expr.c:478
msgid "syntax error in expression"
msgstr "Sintaksa eraro en esprimo"

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "Provo valorizi ne-variablon"

#: expr.c:531
msgid "syntax error in variable assignment"
msgstr "Sintaksa eraro en valorizo de variablo"

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "Divido per 0"

#: expr.c:593
msgid "bug: bad expassign token"
msgstr "CIMO: Misa operacisigno en kombinita valorizsimbolo"

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "„:‟ mankas kondiĉa esprimo"

#: expr.c:973
msgid "exponent less than 0"
msgstr "Negativa eksponento"

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "Post antaŭkremento aperu nomo de variablo"

#: expr.c:1057
msgid "missing `)'"
msgstr "Mankas „)‟"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "Sintaksa eraro: Mankas operando"

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "Sintaksa eraro: Misa operacisimbolo aritmetika"

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (misa simbolo estas „%s‟)"

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "Maltaŭga bazo nombrosistema"

#: expr.c:1587
msgid "invalid integer constant"
msgstr "Maltaŭga konstanto entjera"

#: expr.c:1603
msgid "value too great for base"
msgstr "Tro granda valoro por bazo de nombrosistemo"

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s: Misa esprimo\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getwd: Ne eblas atingi patrajn dosierujojn"

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "Ne eblas reŝalti senprokrastan reĝimon por dosiernumero %d"

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "Maleblas disponigi novan dosiernumeron por Baŝa enigo el n-ro %d"

#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: La nova dosiernumero (fd %d) jam havas bufron"

# ZZZ: sys_error (_("start_pipeline: pgrp pipe"));
#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: procezgrupo dukto"

# ZZZ: internal_warning
#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"

# ZZZ: internal_warning
#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "Forke farita proceznumero %d aperas en rulata laboro %d"

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "Haltigita laboro %d kun procezgrupo %ld estas forigata"

# ifdef DEBUG ... internal_warning():
#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) marked as still alive"

#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: Ne estas tia proceznumero (%ld)!"

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "Signalo %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Farite"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Haltigita"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Haltigita(%s)"

#: jobs.c:1881
msgid "Running"
msgstr "Rulata"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Farite(%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Eliro %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "Nekonata stato"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(nekropsio elŝutita)"

#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (labordosierujo: %s)"

#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "provo atribui (setpgid) procezgrupon %2$ld de la procezido %1$ld"

#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: La procezo %ld ne estas ido de ĉi tiu ŝelo"

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: Malestas informoj pri procezo %ld"

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: La laboro %d estas haltigita"

# XXX: internal_error
#: jobs.c:3551
#, c-format
msgid "%s: no current jobs"
msgstr "%s: no current jobs"

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s: La laboro finiĝis"

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: La laboro %d jam estas fona"

# XXX: internal warning:
#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: WNOHANG iĝas ŝaltita por eviti nedifintan pendiĝon"

#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s: linio %dª: "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr "(nekropsio elŝutita)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(nun labordosierujo estas: %s)\n"

#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp fiaskis"

#: jobs.c:4434
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: laborregado ne funkcias en la fono"

#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: liniaranĝo"

#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid()"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "ne prosperis atribui grupon (%d) de terminala procezo"

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "Ĉi tiu ŝelo ne disponigas laborregadon"

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: Malveras la aserto: %s\n"

# XXX: debug?
#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: aserto sufokita\r\n"

# XXX: internal error
#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "nekonata"

# XXX: debug?
#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "malloc: Skribdifektita bloko en malokupa listo (free list)"

# XXX: debug?
#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "free: La argumento montras blokon jam malokupitan"

# XXX: debug?
#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "free: La argumento ne montras generitan memoron"

# XXX: debug?
#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: Okazis maltroo; mh_nbytes estas ekster sia variejo"

# XXX: debug?
#: lib/malloc/malloc.c:1007
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: Okazis maltroo; «magic8» difektitas"

# XXX: debug?
#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "free: La ĉapa kaj vosta longoj de memorpeco ne estas egalaj"

# XXX: debug?
#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "realloc: La argumento ne montras generitan memoron"

# XXX: debug?
#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: Okazis maltroo; mh_nbytes estas ekster sia variejo"

# XXX: debug?
#: lib/malloc/malloc.c:1197
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: Okazis maltroo; «magic8» difektitas"

# XXX: debug?
#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: La ĉapa kaj vosta longoj de memorpeco ne estas egalaj"

# XXX: debug?
#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: „alloc‟-tabelo elĉerpiĝis je FIND_ALLOC?\n"

# XXX: debug?
#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p jam en la tabelo kvazaŭ kreita (?)\n"

# XXX: debug?
#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p jam en la tabelo kvazaŭ malokupita (?)\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "Misa bazo nombrosistema"

# XXX: internal error
#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: Nekonata retnodo"

#  XXX: internal error
#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: Misa servo-indiko"

# XXX: internal error
#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: Misa retvojo-indiko"

# XXX: internal error
#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "Reta funkciado ne disponeblas"

# XXX: internal warning:
#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: Maleblas ŝanĝi lokaĵaron (%s)"

# XXX: internal warning:
#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: Maleblas ŝanĝi lokaĵaron (%s): %s"

# XXX: fatal_error
#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: ne eblas ŝanĝi la lokaĵaron (%s)"

# XXX: fatal_error
#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: ne eblas ŝanĝi la lokaĵaron (%s): %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Vi havas poŝton en $_"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Nova poŝto en $_"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "La poŝto en %s estas jam legita\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "Sintaksa eraro: Necesas aritmetika esprimo"

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "Sintaksa eraro: Neatendita „;‟"

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "Sintaksa eraro: „((%s))‟"

#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: Misa ordontipo %d"

# internal_warning():
#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "Tuj-dokumenton de linio %d limigas dosierfino (mankas „%s‟)"

# XXX: programming_error
#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: Alidirektada komando „%d‟ ekster sia variejo"

# internal_warning():
#: parse.y:2428
#, c-format
msgid ""
"shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line "
"truncated"
msgstr ""
"shell_getc: shell_input_line_size (%zu) superas SIZE_MAX (%lu): la linio "
"tranĉita"

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr "La nombro de tuj-documentoj superis sian maksimumon"

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "Neatendita dosierfino dum serĉo de responda „%c‟"

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "Neatendita dosierfino dum serĉo de „]]‟"

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "Sintaksa eraro en kondiĉa esprimo: Neatendita simbolo „%s‟"

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "Sintaksa eraro en kondiĉa esprimo"

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "Nekonvena simbolo „%s‟ anstataŭ „)‟"

#: parse.y:4543
msgid "expected `)'"
msgstr "Mankas „)‟"

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "La argumento „%s‟ ne konvenas por unuloka kondiĉa operacisimbolo"

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr "Maltaŭga argumento por unuloka kondiĉa operacisimbolo"

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "Misa simbolo „%s‟ anstataŭ duloka kondiĉa operacisigno"

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr "ĉi tie devas esti duloka kondiĉa operacisigno"

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "La argumento „%s‟ ne konvenas por duloka kondiĉa operacisimbolo"

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr "<maltaŭga argumento por duloka kondiĉa operacisimbolo"

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "Misa simbolo „%c‟ en kondiĉa komando"

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "Misa simbolo „%s‟ en kondiĉa komando"

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "Misa simbolo „%d‟ en kondiĉa komando"

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "Sintaksa eraro apud neatendita simbolo „%s‟"

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "Sintaksa eraro apud „%s‟"

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "Sintaksa eraro: Neatendita dosierfino"

#: parse.y:6151
msgid "syntax error"
msgstr "Sintaksa eraro"

#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Uzu «%s» por eliri el la ŝelo.\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "Neatendita dosierfino dum serĉo de responda „)‟"

# XXX: internal_error
#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "Kompletigo: Funkcio „%s‟ ne trovita"

# XXX: internal_warning
#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: ĉu ciklo de reprovoj?"

# XXX: programming_error
#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULL COMPSPEC"

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: Misa stir-operacio „%d‟"

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: Misa dosiernumero"

# XXX: internal error:
#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: dosierreferenco == NULL"

# XXX: internal error:
#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != fileno xtrace fp (%d)"

# XXX: programming_error
#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: „%c‟: Misa formatsigno"

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "Ekstervarieja dosiernumero"

# XXX: internal_error
#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: Ambigua alidirektado"

# XXX: internal_error
#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: Maleblas surskribi ekzistantan dosieron"

# XXX: internal_error
#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: Limigita ŝelo: malpermesitas alidirekti eligon"

# XXX: internal_error
#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "Malprosperis krei labordosieron por tuj-dokumento: %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: Maleblas konservi la dosiernumeron en la variablo"

# XXX: internal_warning
#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "«/dev/(tcp|udp)/host/port» ne disponeblas ekster retumado"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "Alidirektada eraro: Fiaskis kunnomumo al dosiernumero"

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "Mankas «/tmp», bv krei ĝin!"

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "«/tmp» devas esti valida dosierujo"

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr "La reĝimo de struktura tekstaranĝo ne funkcias en dialogaj ŝeloj"

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: Misa opcio"

#: shell.c:1343
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "Ne eblas ŝanĝi UID-on al %d: la efektiva UID estas %d"

#: shell.c:1354
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "Ne eblas ŝanĝi GID-on al %d: la efektiva GID estas %d"

# XXX: internal_warning
#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr "Maleblas lanĉi erarserĉilon: la erarserĉa reĝimo malŝaltitas."

#: shell.c:1658
#, c-format
msgid "%s: Is a directory"
msgstr "%s : ĉi tio estas dosierujo"

#: shell.c:1907
msgid "I have no name!"
msgstr "Mi ne havas nomon!"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNUa «bash», versio %s-(%s)\n"

#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Uzo:\t%s [GNUa opcio longforma] [opcio] ...\n"
"\t%s [GNUa opcio longforma] [opcio] SKRIPTODOSIERO ...\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "GNUaj opcioj longformaj:\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Ŝelaj opcioj:\n"

#: shell.c:2069
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-ilrsD aŭ -c KOMANDO aŭ -O SHOPT_OPCIO\t\t(nur ĉe voko)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s aŭ -o opcio\n"

# bash --help
#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Por pluaj informoj pri la opcioj tajpu: «%s -c \"help set\"»\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "Por scii pli pri la primitivaj ŝelkomandoj tajpu: „%s -c help‟\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Por raporti pri eraroj uzu la komandon „bashbug‟\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr ""
"La hejmpaĝo de Baŝo (anglalingva): <http://www.gnu.org/software/bash>\n"

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr ""
"Ĝenerala helpilo pri uzo de GNUa programaro: <http://www.gnu.org/gethelp/>\n"

# XXX: internal_error
#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: Misa operacio"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Ŝtopsignalo"

# Hangup detected on controlling terminal or death of controlling
# process
#: siglist.c:51
msgid "Hangup"
msgstr "Malkonekto"

# Interrupt from keyboard
#: siglist.c:55
msgid "Interrupt"
msgstr "Interrompo"

# Quit from keyboard
#: siglist.c:59
msgid "Quit"
msgstr "Klavara eliro"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Miskomando"

# SIGTRAP        5        Core    Trace/breakpoint trap
#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Spurada kontrolpunkto"

# Abort signal from abort(3)
#: siglist.c:75
msgid "ABORT instruction"
msgstr "Komando ABORT"

# SIGEMT is not specified in POSIX 1003.1-2001, but  neverthless  appears
# on  most  other Unices, where its default action is typically to termi-
# nate the process with a core dump.
#: siglist.c:79
msgid "EMT instruction"
msgstr "EMT-komando"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Glitpunkta escepto"

# SIGKILL       9       Term    Kill signal
# Nek kaptebla nek ignorebla (malkiel ABORT)
#: siglist.c:87
msgid "Killed"
msgstr "Murdu"

#: siglist.c:91
msgid "Bus error"
msgstr "Bus-eraro"

# SIGSEGV      11       Core    Invalid memory reference
#: siglist.c:95
msgid "Segmentation fault"
msgstr "Adreseraro"

# SIGSYS      12,-,12     Core    Bad argument to routine (SVID)
#: siglist.c:99
msgid "Bad system call"
msgstr "Misa sistemvoko"

# SIGPIPE      13       Term    Broken pipe: write to pipe with no readers
#: siglist.c:103
msgid "Broken pipe"
msgstr "Rompita dukto"

# SIGALRM      14       Term    Timer signal from alarm(2)
#: siglist.c:107
msgid "Alarm clock"
msgstr "Vekhorloĝo"

# SIGTERM     15       Term    Termination signal
#: siglist.c:111
msgid "Terminated"
msgstr "Finiĝu"

# SIGURG      16,23,21    Ign     Urgent condition on socket (4.2 BSD)
#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Urĝa stato eneliga"

# SIGSTOP   17,19,23    Stop    Stop process
# Nek kaptebla nek ignorebla (samkiel SIGKILL)
# Haltu (poste eblos plu iri, vd SIGCONT)
#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Haltu (signalo)"

# SIGCONT   19,18,25            Continue if stopped
#: siglist.c:127
msgid "Continue"
msgstr "Pluen"

# SIGCHLD   20,17,18    Ign     Child stopped or terminated
#: siglist.c:135
msgid "Child death or stop"
msgstr "Procezido mortis aŭ haltis"

# SIGTTIN   21,21,26    Stop    tty input for background process
#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Haltu (pro terminalenigo)"

# SIGTTOU   22,22,27    Stop    tty output for background process
#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Haltu (pro terminaleligo)"

# SIGIO       23,29,22    Term    I/O now possible (4.2 BSD)
#: siglist.c:147
msgid "I/O ready"
msgstr "Eneligo pretas"

# SIGXCPU     24,24,30    Core    CPU time limit exceeded (4.2 BSD)
#: siglist.c:151
msgid "CPU limit"
msgstr "Ĉefprocesora tempolimo"

# SIGXFSZ     25,25,31    Core    File size limit exceeded (4.2 BSD)
#: siglist.c:155
msgid "File limit"
msgstr "Dosiera longolimo"

# SIGVTALRM   26,26,28    Term    Virtual alarm clock (4.2 BSD)
#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Vekilo (virtuala)"

# SIGPROF     27,27,29    Term    Profiling timer expired
#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Vekilo (profilada)"

# SIGWINCH    28,28,20    Ign     Window resize signal (4.3 BSD, Sun)
#: siglist.c:167
msgid "Window changed"
msgstr "Fenestro ŝanĝiĝis"

# SIGLOST      -,-,-      Term    File lock lost
#: siglist.c:171
msgid "Record lock"
msgstr "Dosierŝloso"

# SIGUSR1   30,10,16    Term    User-defined signal 1
#: siglist.c:175
msgid "User signal 1"
msgstr "Uzulsignalo 1ª"

#: siglist.c:179
msgid "User signal 2"
msgstr "Uzulsignalo 2ª"

# Harbor File Transfer:
#: siglist.c:183
msgid "HFT input data pending"
msgstr "Pendas HFT-enigo"

# SIGPWR      29,30,19    Term    Power failure (System V)
#: siglist.c:187
msgid "power failure imminent"
msgstr "Energiprovizo paneontas"

# SIGDANGER
#: siglist.c:191
msgid "system crash imminent"
msgstr "La sistemo estas kraŝonta"

# SIGMIGRATE:
#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "La procezo iru al alia ĉefprocesoro"

# SIGPRE
#: siglist.c:199
msgid "programming error"
msgstr "Programeraro"

# SIGGRANT (monopola??)
#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "HFT-monitorreĝimo jesigita"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "HFT-monitorreĝimo forprenita"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "HFT-sonsekvenco finiĝis"

# SIGINFO      29,-,-             A synonym for SIGPWR
#: siglist.c:215
msgid "Information request"
msgstr "Informmendo"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Nekonata signalo n-ro %d"

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "Misa anstataŭigo: Mankas ferma „%s‟ en %s"

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: Maleblas valorizi tabelanon per listo"

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "Ne prosperis fari dukton por proceza anstataŭigo"

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "Ne prosperis krei idon por proceza anstataŭigo"

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "Ne prosperis malfermi nomitan dukton %s porlegan"

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "Ne prosperis malfermi nomitan dukton %s por skribado"

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "Ne prosperis kunnomumi nomhavan dukton %s kiel dosiernumeron %d"

#: subst.c:6370
msgid "command substitution: ignored null byte in input"
msgstr "Komanda anstataŭigo: nul-bajto en enigaĵo, ignorita"

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "Ne prosperis fari dukton por komanda anstataŭigo"

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "Ne prosperis krei procezidon por komanda anstataŭigo"

#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: Ne prosperis kunnomumi la dosiernumeron 1 al dukto"

#: subst.c:7082 subst.c:10252
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: Misa variablonomo por nomreferenco"

#: subst.c:7178 subst.c:7196 subst.c:7369
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: Misa malvolvo malrekta"

#: subst.c:7212 subst.c:7377
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: Maltaŭga variablonomo"

#: subst.c:7478
#, c-format
msgid "%s: parameter not set"
msgstr "%s: Parametro estas malaktiva"

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: Parametro estas NUL aŭ malaktiva"

#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: subĉeno-esprimo < 0"

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s: Misa anstataŭigo"

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: ĉi tiel ne valorizebla"

# XXX: internal warning:
#: subst.c:10111
msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr ""
"Ontaj versioj de la ŝelo plenumos komputon kiel aritmetikan anstataŭigon"

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "Misa anstataŭigo: Mankas ferma „`‟ en %s"

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "Nenio kongrua: %s"

#: test.c:147
msgid "argument expected"
msgstr "Mankas argumento"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: Mankas entjera esprimo"

#: test.c:265
msgid "`)' expected"
msgstr "Mankas „)‟"

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "Anstataŭ „)‟ troviĝas %s"

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: Tie devas esti duloka operacisigno"

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: Tie devas esti unuloka operacisigno"

#: test.c:896
msgid "missing `]'"
msgstr "Mankas „]‟"

#: test.c:914
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "Sintaksa eraro: Neatendita «%s»"

#: trap.c:220
msgid "invalid signal number"
msgstr "Misa signalnumero"

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr ""
"trap handler: La nivelo de kaptilotraktiloj superis sian maksimumon (%d)"

# XXX: internal_warning
#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: Misa valoro en trap_list[%d]: %p"

# XXX: internal_warning
#: trap.c:416
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: Signaltraktilo SIG_DFL resendas %d (%s) al mi mem"

#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: Misa signalnumero %d"

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "Eraro ĉe importo de funkcidifino por „%s‟"

# XXX: internal_warning
#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "%d estas tro granda ŝelnivelo; mallevita ĝis 1"

# XXX: internal_error
#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: Malestas funkcia kunteksto en ĉi-regiono"

#: variables.c:2661
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: Variablo ne valorizebla"

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr ""

#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: Nomreferenco valorizata per entjero"

# XXX: internal_error
#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: Malestas funkcia kunteksto en ĉi-regiono"

# XXX: internal_error
#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "«exportstr» de %s estas NUL"

# XXX: internal_error
#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "Misa signo %d en eksporta signoĉeno por „%s‟"

# XXX: internal_error
#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "Mankas „=‟ en eksporta signoĉeno por „%s‟"

# XXX: internal_error
#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""
"pop_var_context: La kapo de „shell_variables‟ ne estas funkcia kunteksto"

# XXX: internal_error
#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: Mankas kunteksto de „global_variables‟"

# XXX: internal_error
#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: La kapo de „shell_variables‟ ne estas provizora regiono"

# XXX: internal_error
#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: Ne malfermeblas kiel DOSIERO"

# XXX: internal_error
#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: Misa valoro por spurada dosiernumero (trace file descriptor)"

# # XXX: internal_error
#: variables.c:6450
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s kongruo-nivelo estas ekster sia variejo"

#: version.c:46 version2.c:46
#, fuzzy
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "Copyright (C) 2020 ĉe «Free Software Foundation, Inc.»"

#: version.c:47 version2.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"La permesilo estas GPLv3+; t.e. GNU GPL, versio 3ª aŭ pli nova.\n"
"La tekston vd ĉe <http://gnu.org/licenses/gpl.html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNUa «bash», versio %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr "Ĉi tiu programo estas libera; vi rajtas libere ĝin ŝanĝi kaj pludoni."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "NENIA GARANTIO estas donita, tiom kiom tion permesas la leĝo."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: Malsukcesis okupi %lu bajtojn (%lu bajtoj disponigitaj)"

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: Malsukcesis okupi %lu bajtojn"

# XXX: fatal_error
#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: Malsukcesis okupi %lu bajtojn (%lu bajtoj disponigitaj)"

# XXX: fatal_error
#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: Malsukcesis okupi %lu bajtojn"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [NOMO[=VALORO] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] NOMO [NOMO ...]"

#: builtins.c:53
msgid ""
"bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpsvPSVX] [-m KLAVARTABELO] [-f DOSIERNOMO] [-q NOMO]\n"
"          [-u NOMO] [-r KLAVAĴO] [-x KLAVAĴO:ŜELKOMANDO]\n"
"          [KLAVAĴO:READLINE-FUNKCIO AŬ READLINE-KOMANDO] "

#: builtins.c:56
msgid "break [n]"
msgstr "break [N]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [N]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [ŜELAĴO [ARG ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [ESPRIMO]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [DOSIERUJO]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] KOMANDO [ARG ...]"

#: builtins.c:78
#, fuzzy
msgid ""
"declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] "
"[name ...]"
msgstr "declare [-aAfFgiIlnrtux] [-p] [NOMO[=VALORO] ...]"

#: builtins.c:80
#, fuzzy
msgid ""
"typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] "
"[name ...]"
msgstr "typeset [-aAfFgiIlnrtux] [-p] NOMO[=VALORO] ..."

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [OPCIO] NOMO[=VALORO] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [ARG ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [ARG ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f DOSIERNOMO] [NOMO ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [ARG ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts OPCIĈENO NOMO [ARG ...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a NOMO] [KOMANDO [ARGUMENTO ...]] [ALIDIREKTADO ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [N]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [N]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr ""
"fc [-e REDAKTILO] [-lnr] [UNUA] [LASTA] aŭ\n"
"fc -s [ŜABLONO=ANST] [KOMANDO]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [LABORINDIKO]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [LABORINDIKO]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p VOJNOMO] [-dt] [NOMO ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [ŜABLONO ...]"

#: builtins.c:123
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d POZICIO] [n] aŭ\n"
"history -awr [DOSIERNOMO] aŭ\n"
"history -ps ARG [ARG...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr ""
"jobs [-lnprs] [LABORINDIKO ...] aŭ\n"
"jobs -x KOMANDO [ARGS]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [LABORINDIKO ... | PROCEZNUMERO ...]"

#: builtins.c:134
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s SIGSNOM | -n SIGNUM | -SIGNOM] [PN | LABORINDIKO] ... aŭ\n"
"kill -l [SIGNOM]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let ARG [ARG ...]"

#: builtins.c:138
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a TABELO] [-d DISIG] [-i TEKSTO]\n"
"     [-n NSIGN] [-N NSIGN] [-p INVIT] [-t TLIM]\n"
"     [-u DN] [NOMO ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [N]"

#: builtins.c:142
#, fuzzy
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCHP] [-o OPCINOMO] [--] [ARG ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [NOMO ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [NOMO[=VALORO] ...]  aŭ  export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [NOMO[=VALORO] ...]   aŭ   readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [N]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source DOSIERNOMO [ARGUMENTOJ]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". DOSIERNOMO [ARGUMENTOJ]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [ESPRIMO]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ ARG... ]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[ARG] SIGNALINDIKO ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] NOMO [NOMO ...]"

#: builtins.c:171
#, fuzzy
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPT] [LIMO]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [REĜIMO]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p VARIABLO] [IND ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [PN ...]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NOMO [in VORTOJ ... ] ; do KOMANDOJ; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( ESPR1; ESPR2; ESPR3 )); do KOMANDOJ; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NONO [in VORTOJ ... ;] do KOMANDOJ; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] DUKTO"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case VORTO in [ŜABLONO [| ŜABLONO]...) KOMANDOJ ;;]... esac"

#: builtins.c:194
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if KOMANDOJ; then KOMANDOJ; [ elif KOMANDOJ; then KOMANDOJ; ]... [ else "
"KOMANDOJ; ] fi"

#: builtins.c:196
#, fuzzy
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while KOMANDOJ; do KOMANDOJ; done"

#: builtins.c:198
#, fuzzy
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until KOMANDOJ; do KOMANDOJ; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NOMO] KOMANDO [ALIDIREKTADOJ]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function NOMO { KOMANDOJ ; }  aŭ  NOMO () { KOMANDOJ ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ KOMANDOJ ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "LABORINDIKO [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( ESPRIMO ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ ESPRIMO ]]"

# Ĉu "variables" estas serĉa ŝlosilo ?
# T.e. "help var" aŭ "help variabl", sed ne "nelp variabloj"?
#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr "var - Nomoj kaj signifo de kelkaj ŝelvariabloj"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | DOSIERUJO]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [OPCINOMO ...]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v VAR] FORMATO [ARGUMENTOJ]"

#: builtins.c:231
msgid ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-"
"W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o OPCIO] [-A AGO] [-G ŜABLONO]\n"
"         [-W VORTLISTO] [-F FUNKCIO] [-C KOMANDO] [-X FILTRILO]\n"
"         [-P PREFIKSO] [-S SUFIKSO] [NOMO ...]"

#: builtins.c:235
msgid ""
"compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-"
"F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o OPCIO]  [-A AGO] [-G ŜABLONO]\n"
"        [-W VORTLISTO] [-F FUNKCIO] [-C KOMANDO] [-X FILTRILO]\n"
"        [-P PREFIKSO] [-S SUFIKSO] [VORTO]"

#: builtins.c:239
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o OPCIO] [-DEI] [NOMO ...]"

#: builtins.c:242
msgid ""
"mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"mapfile [-d DISIG] [-n KIOM] [-O ORIGINO] [-s KIOM] [-t] [-u DN]\n"
"        [-C RETROVOKO] [-c KVANTO] [TABELO]"

#: builtins.c:244
msgid ""
"readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"readarray [-d DISIG] [-n KIOM] [-O ORIGINO] [-s KIOM] [-t]\n"
"          [-u DN] [-C RETROVOKO] [-c KVANTO] [TABELO]"

#  alias:
#: builtins.c:256
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"Difinu aŭ listigu alinomojn.\n"
"\n"
"    Sen argumento aŭ kun la opcio  -p  „alias‟ eligas en la ĉefeligujon\n"
"    la liston da alinomoj en la reuzebla formo «alias NOMO=VALORO».\n"
"\n"
"    Alie, ĉiu NOMO iĝas difinita kiel alinomo por indikita VALORO.\n"
"    Vosta spaceto en la VALORO kaŭzas teston, ĉu la sekva vorto estas\n"
"    alinome anstataŭigenda ĉe la komputo de la alinomo.\n"
"\n"
"    Opcioj:\n"
"    -p\teligu ĉiujn difinitajn alinomojn en reuzebla formo.\n"
"\n"
"    Elirstato:\n"
"    La komando „alias‟ liveras „true‟ krom se aperas NOMO ne difinita\n"
"    alinome."

# unalias [-a] name [name ...]
# unalias [-a] NOMO [NOMO ...]
#: builtins.c:278
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Forigu la NOMOjn el la listo de difinitaj alinomoj.\n"
"\n"
"    Opcioj:\n"
"    -a\tSe enestas la opcio „-a‟, ĉiujn alinomojn forigu\n"
"\n"
"    Liveru sukceson krom se name ne estas difinita alinome."

# bind [-lpvsPVS] [-m KLAVARTABELO] [-f DOSIERNOMO] [-q NOMO] [-u NOMO]
#      [-r KLAVAĴO] [-x KLAVAĴO:ŜELKOMANDO]
#      [KLAVAĴO:READLINE-FUNKCIO AŬ READLINE-KOMANDO]
#: builtins.c:291
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated "
"commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Difinu klavligojn kaj variablojn.\n"
"\n"
"    Ligu klavosekvencon al linilega funkcio, aŭ al makroo, aŭ valorizu\n"
"    linilegan variablon.  La sintakso de ne-opcia argumento estas tiu\n"
"    de «~/.inputrc», tamen la ligon oni esprimu unuargumente; ekz-e:\n"
"    bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"\n"
"    Opcioj:\n"
"    -m KLAVARTABELO   Uzu KLAVARTABELOn dum la daŭro de ĉi tiu komando.\n"
"                      La eblaj nomoj de klavartabelo estas: „emacs‟,\n"
"                      „emacs-standard‟, „emacs-meta‟, „emacs-ctlx‟,\n"
"                      „vi‟, „vi-move‟, „vi-command‟ kaj „vi-insert‟.\n"
"    -l                Listigu funkcinomojn.\n"
"    -P                Listigu funkcinomojn kaj klavligojn.\n"
"    -p                Listigu funkcinomojn kaj klavligojn en formo\n"
"                      reuzebla por enigo.\n"
"    -S                Listigu makroajn klavsekvencojn kaj ilian valoron.\n"
"    -s                Listigu makroajn klavsekvencojn kaj ilian valoron\n"
"                      en formo reuzebla por enigo.\n"
"    -V                Listigu variablonomojn kaj ilian valoron.\n"
"    -v                Listigu variablonomojn kaj ilian valoron en formo\n"
"                      reuzebla por enigo.\n"
"    -q FUNKCINOMO     Demando pri la klavoj ligitaj al la FUNKCINOMO.\n"
"    -u FUNKCINOMO     Malligu ĉiujn klavligojn disde la FUNKCINOMO.\n"
"    -r KLAVAĴO        Forigu la ligon de la klavsekvenco KLAVAĴO\n"
"    -f DOSIERNOMO     Legu klavligojn el DOSIERNOMO\n"
"    -x KLAVAĴO:ŜELKOMANDO  La ŜELKOMANDO plenumiĝu ĉe enigo de KLAVAĴO.\n"
"    -X                Listigu klavosekvencojn ligitajn per „-x‟ kaj la\n"
"                      koncernajn komandojn en formo reuzebla por enigo.\n"
"    \n"
"    Elirstato:\n"
"    0, krom se nekonata opcio estas donita aŭ eraro okazis."

# exit:
#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Finu iteracion FOR, WHILE aŭ UNTIL\n"
"\n"
"    Eliru ekster iteracion FOR, WHILE aŭ UNTIL. Se N estas donita,\n"
"    iru N iteraciajn nivelojn eksteren.\n"
"\n"
"    Elirstato:\n"
"    Ĝi estas 0, kondiĉe ke N estas pli granda ol aŭ egala al 1."

# continue:
#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Daŭrigu iteraciadon de ordono FOR, WHILE aŭ UNTIL\n"
"\n"
"    Pasu al la sekva iteraciero de  FOR, WHILE aŭ UNTIL.\n"
"    Se N estas donita, eliru ĝis la nivelon de la Nª inganta\n"
"    iteraciordono.\n"
"\n"
"    Elirstato:\n"
"    Ĝi estas 0, kondiĉe ke N estas pli granda ol aŭ egala al 1."

# builtin [shell-builtin [arg ...]]
# builtin [ŜELAĴO [ARG ...]]
#: builtins.c:354
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Rulu primitivan ŝelkomandon\n"
"\n"
"    Plenumu primitivan ŝelkomandon ŜELAĴO kun la argumentoj ARG sen la\n"
"    normala komadoserĉo.  Tio utilas se oni volas uzi la nomon de\n"
"    ŝelaĵo por nomi funkcion, sed bezonas la koncernan primitivon en\n"
"    la funkcio mem.\n"
"\n"
"    Elirstato:\n"
"    Tiu de de ŜELAĴO; aŭ malsukceso, se ŜELAĴO ne estas primitiva\n"
"    ŝelkomando."

# caller [expr] =>
# caller [ESPRIMO]
#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Liveru la kuntekston de la kuranta procedurvoko\n"
"\n"
"    Se ESPRIMO malestas, liveru «$line $filename».  Se ESPRIMO\n"
"    ĉeestas, liveru «$line $subroutine $filename»; ĉi tiu krominformo\n"
"    uzeblas por vidigi la vok-stakon.\n"
"\n"
"    La valoro de ESPRIMO indikas, kiom da vokkadroj retroiri disde la\n"
"    kuranta; la pinta kadro havas la numeron 0.\n"
"\n"
"    Elirstato:\n"
"    Ĝi estas 0, kondiĉe ke la ŝelo plenumas ŝelfunkcion kaj la ESPRIMO\n"
"    estas valida."

# cd:
#: builtins.c:387
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname "
"component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully "
"when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Ŝanĝu la kurantan laboran dosierujon de la ŝelo.\n"
"\n"
"    La kuranta dosierujo iĝu DOSIERUJO -- aŭ, se DOSIERUJO malestas,\n"
"    la valoro de la variablo $HOME.\n"
"\n"
"    La variablo $CDPATH difinas la serĉvojon por la dosierujo\n"
"    entenanta DOSIERUJOn.  En $CDPATH, dupunkto „:‟ apartigas\n"
"    alternativajn dosierujojn, vakua dosierujnomo egalas la kurantan.\n"
"    Se DOSIERUJO komenciĝas per „/‟, la variablo $CDPATH ne estas uzata.\n"
"\n"
"    Se la dosierujo ne troviĝas, kaj la ŝela opcio „cdable_vars‟ estas\n"
"    ŝaltita, la vorto estas interpretata kiel variablonomo.  Se tiu\n"
"    variablo havas valoron, tiu valoro estas uzata kiel DOSIERUJO.\n"
"\n"
"    Opcioj:\n"
"    -L\tlaŭu simbolajn Ligilojn: en DOSIERUJO, traktu la aperojn de\n"
"\t„..“ antaŭ ol elnodigi la simbolajn ligilojn\n"
"    -P\tuzu la Fizikan strukturon de dosierujoj, elnodiginte simbolajn\n"
"\tligilojn de DOSIERUJO antaŭ ol trakti la aperojn de „..“\n"
"    -e\teliru kun nenula elirstato se „-P‟ ĉeestas kaj la\n"
"\tkuranta dosierujo ne estas determinebla\n"
"    -@\tse la operaciumo tion ebligas, prezentu dosieron posedantan\n"
"\tkromatributojn kiel dosierujon entenatan la dosieratributojn\n"
"\n"
"    Defaŭlte la simbolaj ligiloj estas laŭataj, kvazaŭ „-L‟ ĉeestus.\n"
"    La traktado de „..“ konsistas en forigo de la ĵus-antaŭa vojnoma\n"
"    ero retrodirekte ĝis la oblikvo „/“ aŭ la komenco de DOSIERUJO.\n"
"\n"
"    Elirstato:\n"
"    Ĝi estas 0, se la dosierujŝanĝo sukcesis, kaj se, ĉeeste de „-P‟,\n"
"    $PWD sukcese valoriziĝis; nenulo aliokaze."

# pwd [-LP]
#: builtins.c:425
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Eligu la nomon de kuranta labora dosierujo\n"
"\n"
"    Opcioj:\n"
"    -L  eligu la valoron de $PWD, se ĝi indikas la kurantan laboran\n"
"        dosierujon\n"
"    -P  eligu la nomon de la fizika dosierujo, sen eventualaj simbolaj\n"
"        ligiloj\n"
"\n"
"    Defaŭlte „pwd‟ kondutas tiel, kiel kun la opcio „-L‟.\n"
"\n"
"    Elirstato:\n"
"    0, krom se aperas misa opcio aŭ la kuranta dosierujo estas\n"
"    nelegebla."

#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Malplena ordono\n"
"\n"
"    Senefika: La komando nenion faras.\n"
"\n"
"    Elirstato:\n"
"    Ĉiam sukcesa."

# true
#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Liveru sukcesan rezulton\n"
"\n"
"    Elirstato:\n"
"    Ĉiam sukcesa."

# false:
#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Liveru fiaskon.\n"
"\n"
"    Elirstato:\n"
"    Ĉiam malsukcesa."

# command [-pVv] command [arg ...]
# command [-pVv] KOMANDO [ARG ...]
#: builtins.c:471
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Plenumu simplan komandon aŭ vidigu informojn pri komandoj\n"
"\n"
"    Plenumu KOMANDOn kun ARGoj sen atenti eventualajn ŝelfunkciojn\n"
"    samnomajn; aŭ vidigu informojn pri indikitaj KOMANDOj.  Uzeblas\n"
"    por voki komandojn de disko malgraŭ la ekzisto de samnomaj\n"
"    funkcioj.\n"
"\n"
"    Opcioj:\n"
"    -p  Uzu la defaŭltan valoron de la de la variablo $PATH (tio\n"
"\tebligas trovi ĉiujn normajn utilaĵojn)\n"
"    -v\tEligu komandopriskribon laŭ la maniero de la primitivaĵo „type‟\n"
"    -V\tEligu pli detalan priskribon de KOMANDO\n"
"\n"
"    Elirstato:\n"
"    Tiu de KOMANDO; aŭ malsukceso, se KOMANDO ne troveblas."

# declare [-aAfFgilnrtux] [-p] [name[=value] ...]
# declare [-aAfFgilnrtux] [-p] [NOMO[=VALORO] ...]
#: builtins.c:490
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Difinu valorojn aŭ atributojn de variabloj.\n"
"\n"
"    Deklaru variablojn aŭ atribuu al ili atributojn.\tSe NOMOj\n"
"    mankas, anstataŭe eligu la valoron de ĉiuj variabloj.\n"
"\n"
"    Opcioj:\n"
"    -f\tla ago aŭ eligo koncernu nur la funkciajn NOMOjn kaj difinojn\n"
"    -F\teligu nur funkcinomojn (ĉe erarserĉo, ankaŭ lininumeron kaj\n"
"\tfontodosieran nomon) sen difinoj\n"
"    -g  se uzita en ŝelfunkcio, kreu mallokan variablon;\n"
"        aliokaze, ignoru\n"
"    -I  ĉe kreo de loka variblo, heredigu la atributojn kaj la valoron\n"
"        de samnoma variablo el antaŭa regiono\n"
"    -p\teligu la atributojn kaj la valorojn de ĉiu NOMO\n"
"\n"
"    Opcioj atributdonaj:\n"
"    -a\tla NOMOj estu entjerindicaj tabeloj (se realigite)\n"
"    -A\tla NOMOj estu asocitabeloj (se realigite)\n"
"    -i\thavigu al la variabloj NOMOj la atributon „integer‟ (entjera)\n"
"    -l\tminuskligu la valoron de ĉiu NOMO ĉe valorizo\n"
"    -n  NOMO estu referenco al variablo nomata per ĝia valoro\n"
"    -r\tla variabloj NOMOj estu nurlegaj\n"
"    -t\thavigu al la NOMOj la atributon „trace‟ (spurata)\n"
"    -u\tmajuskligu la valoron de ĉiu NOMO ĉe valorizo\n"
"    -x\teksportu la variablojn NOMOj\n"
"\n"
"    La uzo de „+‟ anstataŭ „-‟ malŝaltas la koncernan attributon.\n"
"\n"
"    Por la variabloj posedantaj la atributon entjera, ĉe ĉiu valorizo\n"
"    okazas aritmetika komputado (vd la komandon „let‟).\n"
" \n"
"    Uzite en funkcio, „declare‟ faras la NOMOjn lokaj, samkiel la\n"
"    komando „local‟.  La opcio „-g‟ ĉi tiun efikon abolas.\n"
"\n"
"    Eliistato:\n"
"    Sukceso, krom se aperas misa opcio aŭ okazas eraro ĉe valorizo de "
"variablo."

# typeset [-aAfFgilrtux] [-p] name[=value] ...
#: builtins.c:532
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Difinu atributojn kaj valorojn de variabloj\n"
"\n"
"   Sinonimo de „declare“. Vd «help declare»."

# local [option] name[=value] ...
# local [OPCIO] NOMO[=VALORO] ...
#: builtins.c:540
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Difinu lokajn variablojn\n"
"\n"
"    Kreu lokan variablon NOMO kaj ĝin valorizu per VALORO.  OPCIO\n"
"    povas esti ajna el la opcioj de „declare‟.\n"
"\n"
"    Lokaj variabloj uzeblas nur ene de funkcio; ili estas videblaj nur\n"
"    en la funkcio kie ili estas difinitaj kaj en ĝiaj idoj.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio, okazas valoriza eraro, aŭ la\n"
"    ŝelo ne estas plenumanta funkcion."

# echo:
#: builtins.c:557
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by "
"a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value "
"HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal "
"value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Eligu la argumentojn en la ĉefeligujon\n"
"\n"
"    Eligu en la ĉefeligujon la ARGojn disigante ilin per po unu\n"
"    spaceto, postmetu linirompon.\n"
"\n"
"    Opcioj:\n"
"    -n\tne aldonu la finan linirompon\n"
"    -e\taktivigu interpretadon de la ĉi-subaj eskapaj deklivaĵoj\n"
"    -E\tmalaktivigu interpretadon de la ĉi-subaj espapaj deklivaĵoj\n"
"\n"
"    „echo‟ povas interpreti la sekvajn literojn prefiksitajn per\n"
"    deklivo (per la signo „\\‟):\n"
"\t\\a\tpepo (sonsignalo)\n"
"\t\\b\tretropaŝo\n"
"\t\\c\tĉesigu pluan eligon\n"
"\t\\e\teskapsigno\n"
"\t\\E\teskapsigno\n"
"\t\\f\tpaĝ-avanco\n"
"\t\\n\tlinifino\n"
"\t\\r\tĉaretreveno\n"
"\t\\t\thorizontala tabo\n"
"\t\\v\tvertikala tabo\n"
"\t\\\\\tdeklivo „\\‟\n"
"\t\\0CCC\tla signo kies Askia kodono estas CCC (okume).  CCC\n"
"\t\tpovas enteni 0, 1, 2 aŭ 3 okumajn ciferojn\n"
"\t\\xHH\tla signo kies 8-bita kodono estas HH (16-ume).  HH\n"
"\t\tpovas enteni unu aŭ du 16-umajn ciferojn\n"
"        \\uHHHH  la Unikoda signo kies kodono estas la 16-uma\n"
"                nombro HHHH.  HHHH povas enteni de unu ĝis kvar\n"
"                16-umajn ciferojn.\n"
"        \\UHHHHHHHH  la Unikoda signo kies kodono estas la 16-uma\n"
"                nombro HHHHHHHH.  HHHHHHHH povas enteni de unu ĝis\n"
"                ok 16-umajn ciferojn.\n"
"\n"
"    Elirstato:\n"
"    Sukcesa, krom se okazas elig-eraro."

# echo [-n] [ARG ...]
#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Skribu argumentojn en la ĉefeligujon\n"
"\n"
"    Eligu la ARGojn en la ĉefeligujon, aldonu linifinilon.\n"
"\n"
"    Opcio:\n"
"    -n  Ne aldonu postan linifinilon\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se okazas skriberaro."

# enable [-a] [-dnps] [-f filename] [name ...]
# enable [-a] [-dnps] [-f DOSIERNOMO] [NOMO ...]
#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Aktivigu aŭ malaktivigu primitivajn komandojn\n"
"\n"
"    Aktivigu aŭ malaktivigu primitivajn ŝelkomandojn.  Tio ebligas\n"
"    uzi eksteran komandon, samnoman kun primitivaĵo, sen indiki\n"
"    ĝian plenan vojon.\n"
"\n"
"    Opcioj:\n"
"    -a\tListigu la primitivaĵojn indikante, ĉu ili estas aktivaj\n"
"    -n  Malaktivigu la NOMOjn, aŭ listigu la malaktivajn primitivaĵojn\n"
"    -p\tListigu primitivaĵojn en formo taŭga por reuzo\n"
"    -s  Eligu nur la «specialajn» ŝelfunkciojn de Posix\n"
"\n"
"    Opcioj regantaj dinamikan ŝargadon:\n"
"    -f\tŜargu primitivaĵon NOMO el la dinamika biblioteko DOSIERNOMO\n"
"    -d  Forigu ŝelkomandon dinamike ŝargitan per  -f\n"
"\n"
"    Senopcie: Aktivigu ĉiujn NOMOjn\n"
"\n"
"    Ekz-e por uzi la „test‟on troveblan en  $PATH  anstataŭ la\n"
"    samnoman primitivan ŝelkomandon, diru: «enable -n test».\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se NOMO ne estas primitiva ŝelkomando aŭ okazis\n"
"    eraro."

# eval [ARG ...]
#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Plenumu argumentojn kiel ŝelkomandon\n"
"\n"
"    Kunmetu la ARGojn en unu ĉenon, uzu la rezulton kiel enigaĵon por\n"
"    la ŝelo kaj plenumu la legita(j)n komando(j)n.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komandoĉeno; sukceso, se la komando estas vakua."

# getopts optstring name [arg] =>
# getopts OPCIĈENO NOMO [ARG]
#: builtins.c:652
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Analizu opciajn argumentojn\n"
"\n"
"    La funkcion „getopts‟ uzas ŝelproceduroj por analizi opciformajn\n"
"    numerparametrojn.\n"
"\n"
"    La argumento OPCIĈENO entenas la rekonendajn opciliterojn; se\n"
"    literon sekvas dupunkto, la opcio postulas argumenton, disde ĝi\n"
"    apartigendan per blanka spaco.\n"
"\n"
"    Ĉe ĉiu voko „getopts‟ liveros la vican opcion en la ŝelvariablon\n"
"    $NOMO (estigante la variablon se ĝi ne ekzistas); kaj la indicon\n"
"    de la sekve traktota argumento en la ŝelvariablon OPTIND.  OPTIND\n"
"    ricevas la komencan valoron  1  ĉe ĉiu voko de la ŝelo aŭ ŝela\n"
"    skripto.  Kiam opcio bezonas argumenton, „getopts‟ liveras tiun\n"
"    argumenton en la ŝelvariablon  OPTARG.\n"
"\n"
"    La funkcio „getopts‟ raportas pri eraroj dumaniere. Se la unua\n"
"    signo de OPCIĈENO estas dupunkto,  „getopts‟  prisilentas\n"
"    erarojn.  En tiu reĝimo, nenia erarmesaĝo estas eligata.\n"
"    Renkontinte misan opcion, „getopts‟ metas la trovitan opciliteron\n"
"    en  OPTARG.  Se mankas bezonata argumento, la ŝelvariablo  NOMO\n"
"    ricevas la valoron  ':', kaj la variablo OPTARG,  la trovitan\n"
"    opcion.  Se „getopts‟ ne estas en silenta reĝimo kaj trovas\n"
"    misan opcion, tiam NOMO ricevas la valoron '?' kaj  OPTARG\n"
"    senvaloriĝas.  Se mankas bezonata opcio, NOMO ricevas la\n"
"    valoron '?', OPTARG senvaloriĝas kaj erarmesaĝo estas eligata.\n"
"\n"
"    Se la ŝelvariablo  OPTERR  havas la valoron  0,  „getopts‟\n"
"    malaktivigas la eligon de erarmesaĝoj, eĉ se la unua signo de\n"
"    OPCIĈENO ne estas dupunkto.  La apriora valoro de OPTERR estas 1.\n"
"\n"
"    Normale „getopts‟ analizas la numerparametrojn, sed okaze de\n"
"    argumentoj donitaj kiel ARG-valoroj „getopts‟ anstataŭe analizas\n"
"    ilin.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, se opcio estas trovita; malsukceso, se renkontiĝis\n"
"    la fino de la opcioj aŭ okazis eraro."

# exec [-cl] [-a name] [command [arguments ...]] [redirection ...]
# exec [-cl] [-a NOMO] [KOMANDO [ARGUMENTOJ ...]] [ALIDIREKTADO ...]
#: builtins.c:694
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""
"Anstataŭigu la ŝelon je la donita komando\n"
"\n"
"    Plenumu la KOMANDOn, anstataŭigante la ŝelon je la donita\n"
"    programo.  La ARGUMENTOj servas kiel argumentoj por KOMANDO.\n"
"    Se KOMANDO ne estas indikita, la alidirektadoj okazu en \n"
"    la kuranta ŝelo.\n"
"\n"
"    Opcioj:\n"
"    -a NOMO  Pasigu NOMOn al KOMANDO kiel la argumenton  argv[0]\n"
"    -c\tLa plenumo de KOMANDO okazu en vakua medio\n"
"    -l\tMetu minuson en la nulan argumenton pasigatan al KOMANDO\n"
"\n"
"    Se la komandon ne eblas plenumi kaj la ŝelo ne estas dialoga, tiam\n"
"    la ŝelo finiĝas, krom se la opcio „execfail‟ estas aktiva.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se KOMANDO ne estas trovita aŭ okazis eraro pri\n"
"    alirektado."

# exit [n]
#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Forlasu la ŝelon\n"
"\n"
"    Forlasu la ŝelon kun elirstato N.  Se  N  mankas, la elirstato\n"
"    estas tiu de la plej ĵuse plenumita komando."

# logout [N]
#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""
"Adiaŭ, saluta ŝelo!\n"
"\n"
"    Eliru el saluta ŝelo kun la elirstato  N.  Liveru malsukceson, se\n"
"    plenumate ne en saluta ŝelo."

# ZZZ: fc [-e ename] [-nlr] [first] [last] or
#      fc -s [pat=rep] [command] =>
# fc [-e REDAKTILO] [-lnr] [UNUA] [LASTA] aŭ
# fc -s [ŜABLONO=ANST] [KOMANDO]
#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""
"Eligu aŭ plenumu komandojn el la historilisto\n"
"\n"
"    „fc‟ servas por listigi aŭ redakti kaj replenumi komandojn el la\n"
"    historilisto.  UNUA  kaj  LASTA  povas esti numeroj, indikantaj\n"
"    intervalon da numeroj; aŭ, se  UNUA  estas signoĉeno, ĝi indikas\n"
"    la plej ĵusan komandon komenciĝantan per tiu signoĉeno.\n"
"\n"
"    Opcioj:\n"
"    -e REDAKTILO\tla uzota redaktilo.  Defaŭlte FCEDIT, poste\n"
"\tEDITOR, poste „vi‟\n"
"    -l\tnur eligu la liniojn sen redakti ilin\n"
"    -n\teligu sennumere (nur la liniojn)\n"
"    -r\tinversigu la ordon de la linioj (komencu per la plej ĵusaj).\n"
"\n"
"    «fc -s [ŜABLONO=ANST ...] [KOMANDO]» plenumas la KOMANDOn en kiu\n"
"    ĉiu apero de ŜABLONO estas la anstataŭigita je ANST.\n"
"\n"
"    Oportuna alinomo por tio estas «alias r='fc -s'», tiel ke ekz-e per\n"
"    «r cc» oni rulos la plej ĵusan komandon komenciĝantan per «cc», kaj\n"
"    per «r» replenumigas la ĵusan komandon.\n"
"\n"
"    Elisrstato:\n"
"    Sukceso, aŭ la elirstato de la plenumita KOMANDO; nenulo, se okazis\n"
"    eraro."

# fg [job_spec] => fg [LABORINDIKO]
#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Movu laboron en la dialogon\n"
"\n"
"    Faru la laboron  LABORINDIKO  dialoga kaj la kuranta.  Se\n"
"    LABORINDIKO malestas, apliku la ŝelan koncepton pri la kuranta\n"
"    laboro.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la dialogigita komando; aŭ malsukceso, se okazis eraro."

# bg [job_spec] => bg [LABORINDIKO]
#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Forŝovu laboron fonen\n"
"\n"
"    Forŝovu la laboron  LABORINDIKO  en la fonon, faru ĝin kvazaŭ\n"
"    lanĉita kun „&‟.  Se nenia laboro estas indikita, apliku la\n"
"    ŝelan koncepton pri la kuranta laboro.\n"
"\n"
"    Elirstato:\\n\"\n"
"    Sukceso, kondiĉe ke laborregadon estas ŝaltita kaj ne okazis\n"
"    eraro."

# hash [-lr] [-p VOJNOMO] [-dt] [NOMO ...]
#: builtins.c:793
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Registru aŭ vidigu vojnomojn de programoj\n"
"\n"
"    Por ĉiu komando NOMO, trovu kaj registru en hakettabelo la\n"
"    kompletan vojon al ties programo.  Se nenia argumento estas\n"
"    donita, eligu la informojn pri la memorataj komandoj.\n"
"\n"
"    Opcioj:\n"
"    -d  Forgesu la registritajn vojojn por ĉiu NOMO\n"
"    -l  Eligu en formo reuzeblan por enigo\n"
"    -p VOJNOMO\tuzu VOJNOMOn kiel kompletan vojon por la NOMO\n"
"    -r  Forgesu ĉiujn registritajn vojojn\n"
"    -t  Eligu la registritajn vojojn por ĉiu NOMO, mentante la NOMOn\n"
"        titole antaŭ ĝia vojo se estas pluraj NOMOj\n"
"\n"
"    Argumentoj:\n"
"    NOMO  Ĉiu NOMO estas serĉota en $PATH kaj registrota en la\n"
"\thakettabelo de registritaj komandoj\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas netrovebla NOMO aŭ misa opcio."

# help [-ds] [pattern ...]
# help [-ds] [ŜABLONO ...]
#: builtins.c:818
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""
"Vidigu informon pri prmitivaj komandoj\n"
"\n"
"    Eligu mallongan resummon pri la primitivaj komandoj.  Se ĉeestas\n"
"    ŜABLONO, eligu detalan helpon pri ĉiuj komandoj kongruaj kun la\n"
"    ŝablono; alie eligu nur liston da temoj.\n"
"\n"
"    Opcioj:\n"
"    -d\tEligu mallongajn priskribojn de ĉiuj temoj\n"
"    -m\tVidigu uzmanieron en la „manpaĝa‟ stilo (kiel la komando „man‟)\n"
"    -s\tEligu nur mallongan resumon pri ĉiu trovita kongruaĵo\n"
"\n"
"    Argumentoj:\n"
"    ŜABLONO  Komenca signoĉeno de temtitolo\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se mankas kongruaĵoj por ŜABLONO, aŭ aperis\n"
"    misa opcio."

# ZZZ history [-c] [-d offset] [n] or
#     history -awr [filename] or
#     history -ps arg [arg...] =>
# history [-c] [-d POZICIO] [n] aŭ
# history -awr [DOSIERNOMO] aŭ
# history -ps ARG [ARG...]
#: builtins.c:842
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Eligu aŭ redaktu la historiliston.\n"
"\n"
"    Eligu la liston de enigitaj komandoj kun lininumeroj. La ŝanĝitajn\n"
"    liniojn marku per  „*‟.  Kun argumento  n,  eligu nur la ĵusajn\n"
"    n  liniojn.\n"
"\n"
"    Opcioj:\n"
"    -c  forviŝu la tutan historion (forigu ĉiujn erojn el la listo)\n"
"    -d POZICIO  forviŝu la linion kies numero estas  POZICIO.  Por\n"
"        POZICIO negativa la numerado iras reen ekde la fino de la\n"
"        historio \n"
"    -a  aldonu la historiliniojn de la kuranta seanco al la\n"
"        historidosiero\n"
"    -n  legu ĉiujn ankoraŭ ne legitajn liniojn el la historidosiero\n"
"        kaj aldonu ilin en la historiliston\n"
"    -r  legu la dosieron kaj aldonu ĝian enhavon al la kuranta\n"
"        historilisto\n"
"    -w  konservu la kurantan historion en la historidosiero\n"
"\n"
"    -p  plenumu historian anstataŭigon por ĉiu el la argumentoj ARG\n"
"        kaj eligu la rezulton sen konservi ion en la historilisto\n"
"\n"
"    -s  enŝovu la neopciajn argumentojn  ARG  en la historiliston\n"
"        kiel unu apartan linion\n"
"\n"
"    Se ĉeestas  DOSIERNOMO,  uzu ĝin kiel nomon de historidosiero;\n"
"    alie, se la variablo HISTFILE havas valoron, uzu ĉi tiun;\n"
"    alie uzu «~/.bash_history».\n"
"\n"
"    Se la variablo HISTTIMEFORMAT havas valoron kaj se ĉi tiu ne\n"
"    estas null, tiam ĝi servu kiel formata ĉeno en  strftime(3)  por\n"
"    tempostampi ĉiun linion en eligaĵoj de historio.  Aliokaze nenia\n"
"    tempostampo estu eligata.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se renkontiĝas mis opcio aŭ okazis eraro."

# ZZZ jobs [-lnprs] [jobspec ...] or
#     jobs -x command [args] =>
# jobs [-lnprs] [LABORINDIKO ...] aŭ
# jobs -x KOMANDO [ARGS]
#: builtins.c:879
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Montru la staton de laboroj\n"
"\n"
"    Eligu liston da aktivaj laboroj.  Se  LABORINDIKO  estas donita,\n"
"    nur pri tiu laboro informu.  Senopcie, montru la staton de ĉiuj\n"
"    aktivaj laboroj.\n"
"\n"
"    Opcioj:\n"
"    -l  eligu, krom la normalajn informojn, ankaŭ la proceznumerojn\n"
"    -n  listigu nur la procezojn kies stato ŝanĝiĝis post la lasta\n"
"        informmendo\n"
"    -p  eligu nur la proceznumerojn\n"
"    -r  informu nur pri la laboroj aktivaj (rulataj)\n"
"    -s  informu nur pri la laboroj haltigitaj\n"
"\n"
"    La opcio -x lanĉas la  KOMANDOn,  antaŭe ŝanĝinte ĉiujn\n"
"    laborindikojn aperantajn en la argumentoj  ARGS  je la\n"
"    proceznumero de la ĉefprocezo de la grupo.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se enestas misa opcio aŭ okazis eraro.\n"
"    Ĉe „-x‟, la elirstato de la KOMANDO."

# disown [-h] [-ar] [jobspec ...]
#: builtins.c:906
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Forigu laborojn el la kuranta ŝelo\n"
"\n"
"    Forigu ĉiun laboron indikitan per argumento  LABORINDIKO  el\n"
"    la tabelo de aktivaj laboroj.  Se nenia laboro estas indikita,\n"
"    apliku la ŝelan koncepton pri la kuranta laboro.\n"
"\n"
"    Opcioj:\n"
"    -a  forigu ĉiujn laborojn el la labortabelo\n"
"    -h  anstataŭ forigi laboron el la tabelo, marku ĝin tiel, ke la\n"
"        signalo SIGHUP ne estu plusendita al la laboro(j) kiam tian\n"
"        signalon ricevas la ŝelo\n"
"    -r  forigu nur rulatajn laborojn\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se enestas misa opcio aŭ LABORINDIKO."

# ZZZ: kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or
#      kill -l [sigspec] =>
# kill [-s SIGSNOM | -n SIGNUM | -SIGNOM] PN | LABORINDIKO ... aŭ
# kill -l [SIGNOM]
#: builtins.c:925
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Sendu signalon al laboro\n"
"\n"
"    Sendu al la procezoj, indikitaj per sia proceznumero  PN  (aŭ\n"
"    per la LABORINDIKO) la signalon  SIGNOM  aŭ  SIGNUM.  Se nek\n"
"    SIGNUM  nek  SIGNOM  enestas, sendu SIGTERM.\n"
"\n"
"    Opcioj:\n"
"    -s\tSIGNOM estas nomo de signalo\n"
"    -n\tSIGNUM estas numero de signalo\n"
"    -l  listigu signalnomojn; la eventuale sekvantaj entjeraj\n"
"        argumentoj estas signalnumeroj, ĉeeste de kiuj nur la al\n"
"        ili respondaj signalnomoj estu eligataj\n"
"    -L  sinonimo por  -l\n"
"\n"
"    „kill‟ estas primitiva ŝelkomando pro du kaŭzoj:\n"
"    unue, ĝi ebligas uzi laborindikojn anstataŭ proceznumerojn;\n"
"    kaj due, se la maksimuma nombro de kreeblaj procezoj estas\n"
"    atingita, ne necesas lanĉi kroman procezon por ĉesigi iun alian.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se enestas misa opcio aŭ okazis eraro."

# let arg [arg ...]
# let ARG [ARG ...]
#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Komputu aritmetikan esprimon\n"
"\n"
"    Ĉiu arg estas komputenda aritmetika esprimo. La komputado uzas\n"
"    fikslongajn entjerojn sen kontrolo pri trooj; tamen divido per 0\n"
"    estas kaptata kaj raportata kiel eraro.  En la sekvanta listo da\n"
"    operacioj la samprioritataj operacisimboloj aperas kune.  La\n"
"    grupoj estas aranĝitaj laŭ malkresko de ligforto.\n"
"\n"
"\tnomo++, nomo--\tpostkrementoj de variablo\n"
"\t++nomo, --nomo\tantaŭkrementoj de variablo\n"
"\t-, +\t\tunulokaj minus, plus\n"
"\t!, ~\t\tlogika kaj laŭbita negoj\n"
"        **              potencigo\n"
"\t*, /, %\t\tmultipliko, divido, resto\n"
"\t+, -\t\tadicio, subtraho\n"
"\t<<, >>\t\tlaŭbitaj ŝovoj maldekstren kaj dekstren\n"
"\t<=, >=, <, >\tkomparaj operacioj\n"
"\t==, !=\t\tegalo, neegalo\n"
"\t&\t\tlaŭbita KAJ\n"
"\t^\t\tlaŭbita DISAŬ\n"
"\t|\t\tlaŭbita AŬ\n"
"\t&&\t\tlogika KAJ\n"
"\t||\t\tlogika AŬ\n"
"\tesprimo ? esprimo : esprimo\n"
"\t\t\tkondiĉa esprimo\n"
"\t=, *=, /=, %=,\n"
"\t+=, -=, <<=, >>=,\n"
"\t&=, ^=, |=\tvalorizoj\n"
"\n"
"    Ŝelvariabloj uzeblas kiel operandoj.  En esprimo la nomon de\n"
"    variablo anstataŭas ĝia valoro (altipigita al fikslonga entjero).\n"
"    Por tia uzo en esprimo variablo ne bezonas havi ŝaltita sian\n"
"    atributon „entjera‟.\n"
"\n"
"    La operacioj plenumiĝas laŭ la ligforto de siaj operacisignoj.  La\n"
"    enkrampigitaj subesprimoj plenumiĝas unue, kaj tio ebligas\n"
"    ĉirkaŭiri la supre priskribitajn regulojn pri la ligfortoj.\n"
"\n"
"    Elirstato:\n"
"    Se la komputo de la lasta  ARG  donas  0,  la komando „let‟\n"
"    liveras  1;  alie ĝi liveras  0."

# read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars]
#      [-p prompt] [-t timeout] [-u fd] [name ...]
# read [-ers] [-a TABELO] [-d DISIG] [-i TEKSTO] [-n NSIGN] [-N NSIGN]
#      [-p INVIT] [-t TLIM] [-u DN] [NOMO ...]
#: builtins.c:994
#, fuzzy
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters. By default, the backslash character escapes delimiter "
"characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, "
"unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out\n"
"    (in which case it's greater than 128), a variable assignment error "
"occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Legu linion el la ĉefenigujo kaj disigu ĝin en kampojn\n"
"\n"
"    Legu unu linion el la ĉefenigujo, aŭ el la dosiero indikita\n"
"    per dosiernumero DN, se la opcio -u estas donita.  La linion\n"
"    disigu en kampojn, kiel ĉe vortodisigo, kaj la unuan vorton ricevu\n"
"    la unua argumento NOMO; la duan, la dua NOMO ktp; la lasta NOMO\n"
"    ricevu ĉiujn restantajn vortojn.  Nur la signoj troveblaj en la\n"
"    variablo $IFS rolas kiel vortodisigiloj.\n"
"\n"
"    Se nenia NOMO estas donita, konservu la legitan linion en la\n"
"    variablo REPLY.\n"
"\n"
"    Opcioj:\n"
"    -a TABELO\tla legatajn vortojn konservu en la sinsekvaj anoj de\n"
"\t\tTABELO, komencante ekde la indico 0\n"
"    -d DISIG\tlegu ĝis la unua signo de la disigilo DISIG (anstataŭ\n"
"\t\tlegi ĝis linifino)\n"
"    -e\t\tuzu Readline por akiri la linion\n"
"    -i TEKSTO\tuzu TEKSTOn kiel komencan tekston por Readline\n"
"    -n NSIGN\tĉesu leginte NSIGN da signoj (anstataŭ legi ĝis\n"
"\t\tlinifino), krom se disigilo aperas pli frue\n"
"    -N NSIGN\tlegu ekzakte NSIGN da signoj (tra ĉiuj disigiloj), krom\n"
"                se la dosierfino aŭ la tempolimo atingiĝos pli frue\n"
"    -p INVIT\teligu la invitĉenon  INVIT  sen liniavanco antaŭ la\n"
"\t\tatendata enigo\n"
"    -r\t\tla deklivo „\\‟ estu ordinara signo (ne eskapsigno)\n"
"    -s\t\tsilentigu la eĥon de la terminala enigo\n"
"    -t TLIM\tla komando  read  ĉesiĝu kun fiaska elirstato se\n"
"\t\tkompleta linio da enigaĵo ne estas ricevita dum\t TLIM\n"
"\t\tda sekundoj.  Se la variablo  TMOUT  havas valoron, ĉi\n"
"\t\ttiu estas uzata kiel defaŭlta atendolimo.  TLIM povas\n"
"\t\testi frakcio.  Se TLIM estas 0,\t read  tuj finiĝas sen\n"
"                provi ion legi, sed sukcesas nur se engaĵo pretas\n"
"                ĉe la indikita dosiernumero.  La elirstato estas pli\n"
"                granda ol 128 se la atendotempo estas atingita\n"
"    -u DN\tlegu per la dosiernunero DN anstataŭ el la ĉefenigujo\n"
"\n"
"    Elirstato:\n"
"    Ĝi estas 0, krom se renkontiĝas dosierfino, aŭ atendolimo estas\n"
"    atingita (tiuokaze ĝi superas 128), aŭ okazas valoriza eraro, aŭ\n"
"    -u indikas nevalidan dosiernumeron."

# return [n]
# return [N]
#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Revenu el ŝelfunkcio\n"
"\n"
"    Igas la funkcion aŭ punkte vokitan („.‟, „source‟) skripton finiĝi\n"
"    kaj liveri la donitan valoron  N  kiel elirstaton.  Se  N  mankas,\n"
"    la elirstato estas tiu de la ĵusa komando.\n"
"\n"
"    Elirstato:\n"
"    N, aŭ malsukceso se la ŝelo ne plenumas ŝelfunkcion aŭ skripton."

# set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]
# set [-abefhkmnptuvxBCHP] [-o OPCINOMO] [--] [ARG ...]
#: builtins.c:1055
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell "
"functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Donu aŭ forprenu valorojn de ŝelvariabloj kaj numerparametroj.\n"
"\n"
"    Ŝanĝu la valoron de ŝelatributoj kaj numerparametroj, aŭ vidigu la\n"
"    nomojn kaj valorojn de ŝelvariabloj.\n"
"\n"
"    Opcioj:\n"
"    -a\tMarku eksportendaj la variablojn ŝanĝitajn aŭ kreitajn\n"
"    -b\tTuj sciigu pri finiĝo de fonaj laboroj\n"
"    -e\tEliru tuj se ajna komando finiĝis kun elirstato alia ol 0\n"
"    -f\tMalŝaltu generadon de dosiernomoj (globbing)\n"
"    -h\tRegistru en hakettabelo la situon de komandoj serĉataj\n"
"    -k\tĈiujn valorizojn en ajna parto de komandolinio rigardu\n"
"\tkiel valorizojn de ŝelvariabloj por la labormedio de la\n"
"\tkomando, ne nur la valorizojn antaŭ la komandonomo\n"
"    -m\tAktivigu la laborregadon\n"
"    -n\tLegu la komandojn sen plenumi ilin\n"
"    -o OPCINOMO\n"
"\tAktivigu la variablon respondan al la OPCIONOMO:\n"
"\t    allexport\tsamkiel -a\n"
"\t    braceexpand\tsamkiel -B\n"
"\t    emacs\tuzu emakseskan interfacon por liniredaktado\n"
"\t    errexit\tsamkiel -e\n"
"\t    errtrace\tsamkiel -E\n"
"\t    functrace\tsamkiel -T\n"
"\t    hashall\tsamkiel -h\n"
"\t    histexpand\tsamkiel -H\n"
"\t    history\tebligu komandohistorion\n"
"\t    ignoreeof\tla ŝelo ne finiĝu leginte dosierfinilon\n"
"\t    interactive-comments\n"
"\t\t\ttoleru komentojn en dialogaj komandoj\n"
"\t    keyword\tsamkiel -k\n"
"\t    monitor\tsamkiel -m\n"
"\t    noclobber\tsamkiel -C\n"
"\t    noexec\tsamkiel -n\n"
"\t    noglob\tsamkiel -f\n"
"\t    notify\tsamkiel -b\n"
"\t    nounset\tsamkiel -u\n"
"\t    onecmd\tsamkiel -t\n"
"\t    physical\tsamkiel -P\n"
"\t    pipefail\tla elirstato de dukto estu la elirstato\n"
"\t\t\tde la lasta komando finiĝinta nenule, aŭ\n"
"\t\t\t0, se neniu komando alie finiĝis\n"
"\t    posix\tŝanĝu la konduton de Baŝo ĉie kie ĝia defaŭlta\n"
"\t\t\tfunkciado devias disde Pozikso, tiel ke ĝi\n"
"\t\t\tkonformu al tiu normo\n"
"\t    privileged\tsamkiel -p\n"
"\t    verbose\tsamkiel -v\n"
"\t    vi\t\tuzu vi-eskan interfacon por liniredaktado\n"
"\t    xtrace\tsamkiel -x\n"
"    -p\tPrivilegia reĝimo, aktiviĝas meme kiam la reala kaj efektiva\n"
"\tidentoj de la uzanto malkongruas.  La dosiero $ENV ne estas\n"
"\ttraktata, nek la ŝelfunkcioj, importataj el la medio.\n"
"\tMalaktivigo de tiu opcio ŝanĝas la efektivajn uid kaj gid\n"
"\tlaŭ la realaj uid kaj gid\n"
"    -t\tFinu la ŝelon leginte kaj plenuminte unu komandon\n"
"    -u\tProvo anstataŭigi senvaloran variablon estu eraro\n"
"    -v\tEligu la komandoliniojn legatajn\n"
"    -x\tEligu la plenumotajn komandojn kaj iliajn argumentojn\n"
"    -B\tLa ŝelo faru vinkulmalvolvon\n"
"    -C\tSe aktiva, malebligu skribdifekti ekzistantajn ordinarajn\n"
"\tdosierojn per alidirektado de la eligo\n"
"    -E\tSe aktiva, la ERR-kaptilon (ERR trap) heredas la ŝelaj\n"
"\tfunkcioj\n"
"    -H\tEbligu atingi la historion !-stile. Defaŭlte la opcio estas\n"
"\taktiva en la dialogaj ŝeloj.\n"
"    -P\tLa simbolaj ligiloj estu travideblaj ĉe plenumo de komandoj\n"
"\tkiuj ŝanĝas la kurantan dosierujon („cd‟ ktp uzu «fizikan»\n"
"\tinterpreton de vojnomo).\n"
"    -T\tSe aktiva, la ŝelaj funkcioj heredas la kaptilojn (Traps)\n"
"\tDEBUG kaj RETURN \n"
"    --\tLa restantajn argumentojn uzu por valorizi la numerparametrojn.\n"
"\tSe tiaj argumentoj mankas, malvalorizu la numerparametrojn.\n"
"    -\tLa restantajn argumentojn uzu por valorizi la numerparametrojn.\n"
"\tLa opcioj -x kaj -v malaktiviĝas.\n"
"\n"
"    Uzante la signon + anstataŭ - vi povas malŝalti la opcion. La\n"
"    opciojn ankaŭ eblas uzi ĉe la voko de la ŝelo. La kuranta aro da\n"
"    aktivaj opcioj troveblas en $-.  La restantaj  n  argumentoj  ARG\n"
"    iĝas valoroj de la numervariabloj $1, $2 ... $n (en tiu ordo).\n"
"    Senargumente, eligu ĉiujn ŝelvariablojn.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se renkontiĝas misa opcio."

# unset [-f] [-v] [name ...]
# unset [-f] [-v] [NOMO ...]
#: builtins.c:1140
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Forviŝu valorojn kaj atributojn de ŝelaj funkcioj kaj variabloj\n"
"\n"
"    Por ĉiu NOMO, forviŝu la respondan variablon aŭ funkcion.\n"
"\n"
"    Opcioj:\n"
"    -f\ttraktu ĉiun NOMOn kiel funkcion\n"
"    -v  traktu ĉiun NOMOn kiel variablon\n"
"    -n  traktu ĉiun NOMOn kiel nomreferencon, kaj senvalorigu ĝin mem\n"
"        (kaj ne la referencatan variablon)\n"
" \n"
"    Se neniu el la du opcioj estas indikita, „unset‟ unue provos\n"
"    forviŝi variablon, kaj se tia ne troviĝos, funkcion.\n"
"\n"
"    Iujn variablojn ne eblas forviŝi.  Vd ankaŭ la helpon pri „readonly‟.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperis misa opcio aŭ NOMO estas nurlega."

# export [-fn] [name[=value] ...] or export -p
# export [-fn] [NOMO[=VALORO] ...]  aŭ  export -p
#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Marku ŝelvariablojn kiel eksportajn\n"
"\n"
"    Marku la NOMOjn por aŭtomata eksporto en la medion de la\n"
"    plenumotaj komandoj.  Se ĉeestas VALORO, uzu ĝin por valorizi\n"
"    NOMOn antaŭ ol eksporti.\n"
"\n"
"    Opcioj:\n"
"    -f\ttemas pri ŝelfunkcioj\n"
"    -n\tforviŝu la eksportomarkon de la NOMOj\n"
"    -p\teligu la liston de ĉiuj eksportaj variabloj kaj funkcioj\n"
"\n"
"    La opcio „--‟ ĉesigas pluan opcitraktadon.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperis nevalida NOMO aŭ misa opcio."

# readonly [-aAf] [name[=value] ...] or readonly -p
# readonly [-aAf] [NOMO[=VALORO] ...]  aŭ  readonly -p
#: builtins.c:1181
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Faru ŝelvariablojn neŝanĝeblaj\n"
"\n"
"    La donitaj NOMOj  iĝas nurlegaj kaj la valorojn de tiuj nomoj\n"
"    ne povas ŝanĝi posta valorizo.  Se ĉeestas VALORO, uzu ĝin por\n"
"    valorizi la NOMOn antaŭ ol fari ĝin nurlega.\n"
"\n"
"    Opcioj:\n"
"    -a\ttemas pri entjerindica tabelo indikita per plursignifa NOMO\n"
"    -A\ttemas pri la asocitabela signifo de plursignifa NOMO\n"
"    -f\ttemas pri la ŝelfunkcia signifo de plursignifa NOMO\n"
"    -p\teligu ĉiujn nurlegajn variablojn aŭ funkciojn, depende je\n"
"        tio, ĉu la opcio „-f“ estas aldonita\n"
"\n"
"    La opcio „--‟ ĉesigas pluan opcitraktadon.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas nevalida nomo aŭ misa opcio."

# shift [n]
#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Ŝovu numerparametrojn\n"
"\n"
"    La numerparametrojn  $N+1, $N+2 ...  renumeru al  $1, $2 ...\n"
"    Se  N  ne estas indikita, uzu  1  anstataŭe."

# source filename [arguments]
# source DOSIERNOMO [ARGUMENTOJ]
#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Plenumu komandojn el dosiero en la kuranta ŝelo\n"
"\n"
"    Legu kaj plenumu la komandojn el DOSIERNOMO en la kuranta ŝelo.\n"
"    Uzu la vojojn el la variablo  $PATH  por trovi la dosierujon de\n"
"    DOSIERNOMO.  La eventualaj ARGUMENTOJ iĝas la numerparametroj por\n"
"    plenumo de DOSIERNOMO.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komando laste plenumita en DOSIERNOMO; malsukceso, se\n"
"    DOSIERNOMO ne legeblas."

# suspend [-f]
#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Haltetigu la plenumon de la ŝelo\n"
"\n"
"    Haltetigu la plenumon de la ŝelo ĝis ĝi ricevos la signalon SIGCONT.\n"
"    Krom se per superforto, salutan ŝelon ne eblas haltetigi.\n"
"\n"
"    Opcio:\n"
"    -f\tSuperforte haltetu, eĉ se la ŝelo estas saluta ŝelo\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se laborregado estas malŝaltita aŭ okazis eraro."

# test [expr]
# test [ESPRIMO]
#: builtins.c:1262
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Komputu kondiĉan esprimon\n"
"\n"
"    Liveru elirstaton 0 (vera) aŭ 1 (malvera) laŭ la rezulto de\n"
"    komputado de la ESPRIMO.  La esprimoj povas esti unulokaj aŭ\n"
"    dulokaj.  La unulokaj plejparte servas por determini la statuson\n"
"    de dosiero.  Krome, estas operacioj super ĉenoj kaj la\n"
"    nombrokomparaj operacioj.\n"
"\n"
"    La konduto de test-komando dependas je la kiomo de ĝiaj argumentoj.\n"
"    Plenan priskribon donas «man bash».\n"
"\n"
"    Operacioj super dosieroj:\n"
"\n"
"\t-a DOSIERO\tVera se DOSIERO ekzistas\n"
"\t-b DOSIERO\tVera se DOSIERO estas por bloka eneligo\n"
"\t-c DOSIERO\tVera se DOSIERO estas por bajta eneligo\n"
"\t-d DOSIERO\tVera se DOSIERO estas dosierujo\n"
"\t-e DOSIERO\tVera se DOSIERO ekzistas\n"
"\t-f DOSIERO\tVera se DOSIERO ekzistas kaj estas ordinara\n"
"\t-g DOSIERO\tVera se DOSIERO havas set-group-id = 1\n"
"\t-h DOSIERO\tVera se DOSIERO estas simbola ligilo\n"
"\t-L DOSIERO\tVera se DOSIERO estas simbola ligilo\n"
"\t-k DOSIERO\tVera se la DOSIERO havas sticky = 1\n"
"\t-p DOSIERO\tVera se DOSIERO estas nomhava dukto\n"
"\t-r DOSIERO\tVera se vi rajtas legi DOSIEROn\n"
"\t-s DOSIERO\tVera se DOSIERO ekzistas kaj longas pli ol 0\n"
"\t-S DOSIERO\tVera se DOSIERO estas kontaktingo („socket‟)\n"
"\t-t DNUMERO\tVera se la dosiero DNUMERO estas terminala\n"
"\t-u DOSIERO\tVera se DOSIERO havas set-user-id = 1\n"
"\t-w DOSIERO\tVera se vi rajtas skribi en DOSIEROn\n"
"\t-x DOSIERO\tVera se vi rajtas lanĉi DOSIEROn\n"
"\t-O DOSIERO\tVera se DOSIERO estas via dosiero\n"
"\t-G DOSIERO\tVera se DOSIERO apartenas al via grupo\n"
"\t-N DOSIERO\tVera se DOSIERO ŝanĝiĝis post la lasta lego\n"
"\n"
"\tD_RO1 -nt D_RO2\tVera se la dosiero D_RO1 estas pli freŝa\n"
"\t\t\t(laŭ la ŝanĝodato) ol la dosiero D_RO2\n"
"\tD_RO1 -ot D_RO2\tVera se D_RO1 estas malpli freŝas ol D_RO2\n"
"\tD_RO1 -ef D_RO2\tVera se D_RO1 estas rekta ligilo al D_RO2\n"
"\n"
"    Operacioj super ĉenoj:\n"
"\n"
"\t-z ĈENO\t\tVera se ĈENO estas vakua\n"
"\t-n ĈENO\t\tVera se ĈENO ne estas vakua\n"
"\tĈENO\t\tVera se ĈENO ne estas vakua\n"
"\tĈENO1 = ĈENO2\tVera se la ĉenoj estas egalaj\n"
"\tĈENO1 != ĈENO2\tVera se la ĉenoj ne estas egalaj\n"
"\tĈENO1 < ĈENO2\tVera se ĈENO1 leksikografie antaŭas la\n"
"\t\t\tĉenon ĈENO2\n"
"\tĈENO1 > ĈENO2\tVera se ĈENO1 leksikografie sekvas la\n"
"\t\t\tĉenon ĈENO2\n"
"\n"
"    Diversaj operacioj:\n"
"\n"
"        -o OPCIO        Vera se la ŝelopcio OPCIO estas ŝaltita\n"
"        -v VAR          Vera se la ŝelvariablo VAR havas valoron\n"
"        -R VAR          Vera se la ŝelvariablo VAR havas valoron kaj\n"
"                        estas nomreferenco\n"
"\t! ESPR\t\tVera se la esprimo ESPR estas malvera\n"
"\tESPR1 -a ESPR2\tVera se ambaŭ esprimoj estas veraj\n"
"\tESPR1 -o ESPR2\tVera se ajna el la esprimoj estas vera\n"
"\n"
"\targ1 KP arg2\tAritmetikaj komparoj.  KP estas iu el la\n"
"\t\t\trilatoj -eq, -ne, -lt, -le, -gt, -ge\n"
"\n"
"    La aritmetikaj komparoj liveras veron se arg1 estas respektive\n"
"    egala, neegala, malplia ol, malplia aŭ egala al, plia ol,\n"
"    plia aŭ egala al arg2.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, se la rezulto de la komputo de ESPRIMO estas vero;\n"
"    malsukceso, se la rezulto estas malvero aŭ renkontiĝas misa\n"
"    argumento."

# [ arg... ]
#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Ĉi tiu estas sinonimo de la primitivo „test‟; tamen la lasta\n"
"    argumento devas esti „]‟ fermanta la esprimon komencitan per „[‟."

#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Vidigu proceztempojn\n"
"\n"
"    Eligu la tempojn akumulitajn de la uzanto kaj de la kerno\n"
"    por la ŝelo kaj ĝiaj procezidoj.\n"
"\n"
"    Elirstato:\n"
"    Ĉiam sukcesa."

# trap [-lp] [[arg] signal_spec ...]
# trap [-lp] [[ARG] SIGNALINDIKO ...]
#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  "
"If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or "
"a\n"
"    script run by the . or source builtins finishes executing.  A "
"SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause "
"the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""
"Kaptu signalojn kaj aliajn eventojn\n"
"\n"
"    Difinu kaj aktivigu traktilojn plenumotajn kiam ŝelo ricevos\n"
"    signalojn aŭ ĉe aliaj kondiĉoj.\n"
"\n"
"    La komando ARG estas legota kaj plenumota kiam la ŝelo ricevos\n"
"    signalon el SIGNALINDIKO.  Se ARG malestas (kaj SIGNALINDIKO\n"
"    konsistas el unu sola signalo) aŭ estas „-‟, ĉiuj indikitaj\n"
"    signaloj rericevas sian komencan valoron.  Se ARG estas vakua\n"
"    ĉeno, la ŝelo mem kaj komandoj el ĝi vokitaj malatentos ĉiujn\n"
"    signalojn de SIGNALINDIKO.\n"
"\n"
"    Se inter la signaloj SIGNALINDIKO estas „EXIT‟ (aŭ 0), tiam ARG de\n"
"    la komando plenumiĝos ĉe la eliro el la ŝelo. Se en SIGNALINDIKO\n"
"    estas „DEBUG‟, ARG plenumiĝos post ĉiu komando.  Se en\n"
"    SIGNALINDIKO estas „RETURN“, ARG plenumiĝos ĉiufoje kiam finiĝas\n"
"    skripto rulata per komando „.“ aŭ „source“.  La SIGNALINDIKO „ERR“\n"
"    igas ARGon plenumiĝi ĉiufoje kiam malsukceso de komando kaŭzus\n"
"    eliron el la ŝelo havanta la opcion „-e“ ŝaltita.\n"
"\n"
"    Senargumente trap listigas komandojn plenumotajn laŭ ĉiu signalo.\n"
"\n"
"    Opcioj:\n"
"    -l\tlistigu la signalnomojn kun la numeroj\n"
"    -p  vidigu la trap-komandojn por trakti ĉiun SIGNALINDIKOn\n"
"\n"
"    Ĉiu SIGNALINDIKO estas aŭ signalnomo el <signal.h>, aŭ\n"
"    signalnumero.  La signalnomoj estas usklecoblindaj, kaj la\n"
"    prefikso „SIG‟ estas ellasebla.  Signalon S oni povas sendi al la\n"
"    ŝelo per la komando «kill -S $$».\n"
"\n"
"    Elirstato:\n"
"    Sukceso, kondiĉe ke SIGNALINDIKOj kaj la opcioj estas taŭgaj."

# type [-afptP] name [name ...]
# type [-afptP] NOMO [NOMO ...]
#: builtins.c:1401
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""
"Vidigu informon pri tipo de komando\n"
"\n"
"    Por ĉiu NOMO, montru kion ĝi signifus en la pozicio de\n"
"    komadonomo.\n"
"\n"
"    Opcioj:\n"
"    -a\tlistigu ĉiujn lokojn entenantajn plenumeblan dosieron\n"
"        kun koncerna NOMO;  la listo inkludas alinomojn kaj\n"
"        funkciojn, se kaj nur se malestas la opcio  „-p‟\n"
"    -f  ekskludas el la serĉo la ŝelfunkciojn\n"
"    -P\tapliku vojserĉon laŭ PATH por ĉiu NOMO, eĉ se ekzistas tianoma\n"
"        funkcio, primitiva komando aŭ alinomo, kaj liveru la nomon de\n"
"        tiel plenumebla diskdosiero\n"
"    -p\teligu la nomon de dosiero kiu iĝus plenumata;\n"
"        aŭ nenion, se «type -t name» ne eligus „file‟\n"
"    -t\teligu unu vorton, iun el la sekvaj:\n"
"        „alias‟, „keyword‟, „function‟, „builtin‟, „file‟ aŭ „‟ --\n"
"        se NOMO  estas, respektive, alinomo, ŝela ŝlosilvorto,\n"
"        ŝelfunkcio, ŝela primitivo, dosiero aŭ nenio konata\n"
"\n"
"    Argumentoj:\n"
"    NOMO  Esplorenda komandonomo\n"
"\n"
"    Elirstato:\n"
"    Sukceso, se ĉiujn NOMOjn prosperis trovi; malsukceso, se estis\n"
"    netrovitaj."

# ulimit [-SHacdefilmnpqrstuvx] [limit]
# ulimit [-SHacdefilmnpqrstuvx] [LIMO]
#: builtins.c:1432
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Ŝanĝu risurcolimaĵojn de la ŝelo.\n"
"\n"
"    La komando „ulimit‟ ebligas mastrumi la risurcojn disponeblajn al\n"
"    la procezoj lanĉataj el la ŝelo (se la operaciumo ebligas tion).\n"
"\n"
"    Opcioj:\n"
"    -S  ŝanĝebla („soft‟) limo\n"
"    -H  firma („hard‟) limo\n"
"    -a  eligu ĉiujn kurantajn risurcolimaĵojn\n"
"    -b  la kontaktoskatola bufrolongo\n"
"    -c  maksimuma longo de nekropsia dosiero („core‟)\n"
"    -d  maksimuma longo de datumsegmento de procezo\n"
"    -e  maksimuma viciga prioritato („nice‟)\n"
"    -f  maksimuma longo de dosieroj skribataj de la ŝelo kaj ĝiaj idoj\n"
"    -i  maksimuma longo de pendaj signaloj\n"
"    -k  maksimuma nombro de kernaj atendovicoj (kqueues) disponigeblaj\n"
"        al la procezo \n"
"    -l  maksimuma longo de ŝlosebla procezmemoro (mlock)\n"
"    -m  maksimuma longo de rezida procezmemoro\n"
"    -n  maksimuma nombro de malfermitaj dosiernumeroj\n"
"    -p  longo de dukta bufro (pipe)\n"
"    -q  maksimuma nombro da bajtoj en atendovicoj de Poziksaj mesaĝoj\n"
"    -r  maksimuma prioritato realtempa\n"
"    -s  maksimuma longo de stako\n"
"    -t  maksimuma tempo ĉefprocesora (en sekundoj)\n"
"    -u  maksimuma nombro de procezoj de la uzanto\n"
"    -v  longo de la virtuala memoro\n"
"    -x  maksimuma nombro de dosierŝlosoj\n"
"    -P  maksimuma nombro de pseŭdoterminaloj\n"
"    -R  maksimuma daŭro de senblokiĝa rulo de realtempa procezo \n"
"    -T  maksimuma nombro de fadenoj\n"
"\n"
"    Ne ĉiuj opcioj disponeblas sur ĉiuj komputilaj platformoj.\n"
"\n"
"    Se LIMO estas indikita, ĝia valoro limigas la koncernan risurcon;\n"
"    la specialaj vortoj por LIMO: „soft‟, „hard‟, „unlimited‟\n"
"    signifas, respektive: «la kuranta ŝanĝebla limo», «la kuranta\n"
"    firma limo», «sen limo».  Alie estas eligata la kuranta valoro de\n"
"    la koncerna risurco.  Manko de opcioj implicas -f.\n"
"\n"
"    La valoroj estas en obloj de 1024 bajtoj, krom por la opcio -t,\n"
"    kiu estas en sekundoj; por -p, kiu estas en obloj de 512 bajtoj;\n"
"    kaj por -u, kiu estas sendimensia nombro de procezoj.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, kondiĉe ke la opcioj estas taŭgaj kaj ne okazis eraro."

# umask [-p] [-S] [mode]
# umask [-p] [-S] [REĜIMO]
#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Vidigu aŭ agordu dosierreĝiman maskon\n"
"\n"
"    La dosierkrea masko de la uzanto havu la valoron de la argumento\n"
"    REĜIMO.  Se REĜIMO mankas, eligu la kurantan valoron de la masko.\n"
"\n"
"    Se la argumento REĜIMO komenciĝas per cifero, ĝi estas\n"
"    interpretata kiel okuma nombro; alie, kiel simbola signoĉeno\n"
"    laŭ chmod(1).\n"
"\n"
"    Opcioj:\n"
"    -p\tse REĜIMO malestas, la eligaĵo havu formon taŭgan por enigo\n"
"    -S\tla eligo estu simbola; alie ĝi estas okuma nombro\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se REĜIMO estas nevalida aŭ aperas misa opcio."

# wait [-fn] [id ...]
# wait [-fn] [IND ...]
#: builtins.c:1503
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or "
"a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of "
"IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns "
"its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, "
"before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Atendu ke laboroj finiĝu, kaj liveru elirstaton.\n"
"\n"
"    Atendu finiĝon de ĉiu procezo indikita per IND (kiu povas esti\n"
"    proceznumero aŭ laborindiko) kaj liveru ĝian elirstaton.  Se IND\n"
"    malestas, atendu ĉiujn aktivajn procezidojn, kaj liveru la \n"
"    elirstaton 0.  Se IND estas laborindiko, atendu ĉiujn procezojn en\n"
"    la dukto de la laboro.\n"
"\n"
"    Kun la opcio „-n“: atendu finiĝon de unu el laboroj de la\n"
"    IND-listo aŭ, se neniu IND estas donita, de la sekva laboro, kaj\n"
"    liveru ĝian elirstaton.\n"
"\n"
"    Kun la opcio „-p“: la procezo aŭ la laborindiko de la laboro kies\n"
"    elirstato estas liverota valorizas la VARIABLOn indikitan per la\n"
"    opcia argumento. Komence, antaŭ ajna valorizo, la variablo estos\n"
"    malvalorizita. Tio utilas nur kune kun la opcio „-n“.\n"
"\n"
"    Kun la opcio „-f“: se la laborregado estas ŝaltita, atendu finiĝon\n"
"    de la donita IND (anstataŭ atendi ke ĝi ŝanĝu la staton)\n"
"\n"
"    Elirstato:\n"
"    Tiu de la lasta IND; malsukceso, se IND estas nevalida aŭ se\n"
"    renkontiĝas nevalida opcio, aŭ „-n“ estas donita kaj la ŝelo\n"
"    malhavas neatendatajn idojn.<"

# wait [pid ...]
# wait [PN ...]
#: builtins.c:1534
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination "
"status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an "
"invalid\n"
"    option is given."
msgstr ""
"Atendu ke procezoj finiĝu, kaj liveru elirstaton\n"
"\n"
"    Atendu finiĝon de ĉiu indikita procezoj kaj liveru ĝian elirstaton.\n"
"    Se PN malestas, atendu ĉiujn aktivajn procezidojn, kaj liveru la\n"
"    elirstaton 0.  PN  devas esti proceznumero.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la lasta PN; malsukceso, se PN estas nevalida aŭ se\n"
"    renkontiĝas nevalida opcio."

# for NAME [in WORDS ... ] ; do COMMANDS; done
# for NOMO [in VORTOJ ... ] ; do KOMANDOJ; done
#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Plenumu komandojn por ĉiu ero de listo\n"
"\n"
"    La iteracio „for‟ plenumas la KOMANDOJn por ĉiu ero de sia listo.\n"
"    Se la parto «in VORTOJ ...;» malestas, «in \"$@\"» estas uzata\n"
"    anstataŭe.  Por ĉiu el la VORTOJ, la NOMO estas valorizata per tiu\n"
"    ero kaj la KOMANDOJ estas plenumataj.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la laste plenumita komando."

# for (( exp1; exp2; exp3 )); do COMMANDS; done
# for (( ESPR1; ESPR2; ESPR3 )); do KOMANDOJ; done
#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Aritmetika iteracio\n"
"\n"
"    Ekvivalentas al\n"
"\t(( ESPR1 ))\n"
"\twhile (( ESPR2 )); do\n"
"\t   KOMANDOJ\n"
"\t   (( ESPR3 ))\n"
"\tdone\n"
"    kie ESPR1, ESPR2 kaj ESPR3 estas aritmetikaj esprimoj.  Se iu el\n"
"    ili malestas, 1 estas uzata anstataŭe.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la laste plenumita komando."

# select NAME [in WORDS ... ;] do COMMANDS; done
# select NONO [in VORTOJ ... ;] do KOMANDOJ; done
#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Elektu vortojn el listo kaj plenumu komandojn\n"
"\n"
"    Malvolvu VORTOJn, generante liston da vortoj.  Tiujn vortojn eligu\n"
"    en la ĉeferarujon, ĉiu antaŭate de sia numero.  Se „in VORTOJ‟\n"
"    malestas, prenu anstataŭe la enhavon de \"$@\".  Poste eligu la\n"
"    inviton laŭ la variablo PS3 kaj legu linion el la ĉefenigujo.  Se\n"
"    la linio konsistas el numero responda al iu el la vortoj eligitaj,\n"
"    la NOMO ricevu ĝin kiel sian valoron.  Se la linio entenas nenion,\n"
"    ripetu VORTOJn kaj la inviton.  Ĉe la dosierfino la komando\n"
"    finiĝas.  Ajna alia enigaĵo vakuigas la variablon NOMO.  La legita\n"
"    linio konserviĝas en la variablo REPLY.  Plenumu la KOMANDOJn post\n"
"    ĉiu elekto, ĝis renkontiĝos komando de eliro (break).\n"
"\n"
"    Elirstato:\n"
"    Tiu de la laste plenumita komando."

# time [-p] PIPELINE
# time [-p] DUKTO
#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Raportu tempon konsumitan de dukto\n"
"\n"
"    Plenumu la DUKTOn kaj poste eligu tabelon el la reala tempo,\n"
"    la ĉefprocesora tempo de la uzanto, kaj la ĉefprocesora tempo\n"
"    sistema, konsumitaj por plenumi la DUKTOn, kiam ĝi finĝos.\n"
"\n"
"    Opcio:\n"
"    -p\tprezentu la tempojn laŭ la portebla Poziksa formo\n"
"\n"
"    La variablo TIMEFORMAT difinas la formon de la eligaĵo.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la DUKTO."

# case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac
# case VORTO in [ŜABLONO [| ŜABLONO]...) KOMANDOJ ;;]... esac
#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Plenumu komandojn laŭ ŝablonkongruo \n"
"\n"
"    Plenumu KOMANDOJn kondiĉe ke VORTO kongruas kun ŜABLONO.\n"
"    La streko „|‟ servas por disigi ŝablonojn (se pluraj).\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komando laste plenumita."

# if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]...
# [ else COMMANDS; ] fi
# if KOMANDOJ; then KOMANDOJ;[ elif KOMANDOJ; then KOMANDOJ; ]...
# [ else KOMANDOJ; ] fi
#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Plenumu komandojn depende je kondiĉo\n"
"\n"
"    Plenumu la komandojn el «if KOMANDOJ». Se la elirstato estas 0,\n"
"    tiam plenumu la komandojn el «then KOMANDOJ». Alie, laŭvice,\n"
"    plenumu la komandoj el «elif KOMANDOJ», kaj se la elirstato\n"
"    estas 0, plenumu la komandojn de ties «then KOMANDOJ», post kio\n"
"    la komando „if‟ finiĝas.  Alie plenumu la komandojn el\n"
"    «else KOMANDOJ» (se tiaj enestas).  La elirstato estas tiu de la\n"
"    lasta komando plenumita, aŭ 0 se neniu el la kondiĉoj estis vera."

# while COMMANDS; do COMMANDS; done
# while KOMANDOJ; do KOMANDOJ; done
#: builtins.c:1648
#, fuzzy
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Plenumadu komandojn dum testo sukcesas\n"
"\n"
"    Ripete malvolvu kaj plenumu la KOMANDOJn dum la lasta el la\n"
"    KOMANDOJ de la „while‟-parto liveras elirstaton 0.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komando laste plenumita. "

# until COMMANDS; do COMMANDS; done
# until KOMANDOJ; do KOMANDOJ; done
#: builtins.c:1660
#, fuzzy
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Plenumadu komandojn ĝis kiam testo sukcesos\n"
"\n"
"    Ripete malvolvu kaj plenumu la komandojn dum la lasta el la\n"
"    KOMANDOJ de la „until‟-parto liveras elirstaton alian ol 0.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komando laste plenumita."

# coproc [NAME] command [redirections]
# coproc [NOMO] KOMANDO [ALIDIREKTADOJ]
#: builtins.c:1672
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Kreu kunprocezon nomotan NOMO\n"
"\n"
"    Plenumu KOMANDOn nesinkrone, konektinte per dukto ĝiajn ĉefelgujon\n"
"    kaj ĉefengujon al la dosiernumeroj listigitaj en la tabelo NOMO de\n"
"    la kuranta ŝelo ĉe la indicoj 0 kaj 1.  La defaŭlta NOMO estas\n"
"    „COPROC‟.\n"
"\n"
"    Elirstato:\n"
"    La komando  coproc  liveras la elirstaton 0."

# function name { COMMANDS ; } or name () { COMMANDS ; }
# function NOMO { KOMANDOJ ; }  aŭ  NOMO () { KOMANDOJ ; }
#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Difinu ŝelfunkcion\n"
"\n"
"    Kreu ŝelfunkcion kun NOMO.  Vokite kiel simpla komando,  NOMO\n"
"    plenumas la KOMANDOJn en la medio de la vokanta ŝelo.  Ĉe voko de\n"
"    NOMO la komandoliniajn argumentojn la funkcio ricevas en  $0...$n,\n"
"    kaj la funkcinomo registriĝas en  $FUNCNAME.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se NOMO estas nurlega."

# grouping_braces: { COMMANDS ; }
# { KOMANDOJ ; }
#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Arigu komandojn en komandan unuon\n"
"\n"
"    Plenumu la komandojn grupe.  Tiel eblas apliki alidirektadon al\n"
"    tuta grupo da komandoj.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komando laste plenumita."

# job_spec [&]
# LABORINDIKO [&]
#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Reaktivigu laboron en la fono\n"
"\n"
"    Samkiel la argumento LABORINDIKO en komando „fg‟.  Reaktivigu\n"
"    haltigitan aŭ fonan laboron.  LABORINDIKO povas esti labornomo aŭ\n"
"    labornumero.  Postmetita „&‟ sendas la laboron en la fonon,\n"
"    samkiel se la komando „bg‟ estus aplikita al LABORINDIKO.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la reakivigita laboro."

# (( expression ))
# (( ESPRIMO ))
#: builtins.c:1727
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Komputu aritmetikan esprimon\n"
"\n"
"    La ESPRIMO komputiĝas laŭ la aritmetikaj reguloj.\n"
"    Ekvivalentas al «let \"ESPRIMO\"».\n"
"\n"
"    Elirstato:\n"
"    1, se la rezulto de la ESPRIMO estas 0; 0 aliokaze."

# [[ expression ]]
# [[ ESPRIMO ]]
#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Plenumu kondiĉkomandon\n"
"\n"
"    Liveras elirstaton 0 aŭ 1 laŭ la rezulto de komputado de kondiĉa\n"
"    ESPRIMO.  Esprimoj konsistas el bazaj esprimoj, kiajn uzas la\n"
"    primitivaĵo „test‟, kaj komponiĝas per sekvaj operacioj:\n"
"\n"
"      ( ESPRIMO )   Liveras la valoron de ESPRIMO\n"
"      ! ESPRIMO\t    Vera, se ESPRIMO estas malvera; alie malvera\n"
"      ESP1 && ESP2  Vera, se veras ambaŭ ESP1 kaj ESP2; alie malvera\n"
"      ESP1 || ESP2  Vera, se veras ajna el ESP1 kaj ESP2; alie malvera\n"
"\n"
"    En la operacioj „==‟ kaj „!=‟ la signoĉeno dekstre de la operacisigno\n"
"    rolas kiel ŝablono, kongrueco al kiu estas testata.  Ĉe la\n"
"    operacio „=~‟ la ĉeno en la dekstra parto rolas kiel regulesprimo\n"
"    por kongruectestado.\n"
"\n"
"    En la operacioj && kaj || la duaj subesprimoj ESP2 ne estas\n"
"    komputataj se ESP1 jam sufiĉas por determini la rezulton.\n"
"\n"
"    Elirstato:\n"
"    0 aŭ 1, laŭ la valoro de ESPRIMO."

# help var
# variables - Names and meanings of some shell variables
#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Nomoj kaj uzoj de komunaj ŝelvariabloj\n"
"\n"
"    BASH_VERSION Informo pri la versio de ĉi tiu Baŝo\n"
"    CDPATH\tListo da dosierujoj (disigitaj per dupunkto) en\n"
"\t\tkiuj argumenta dosierujo de „cd‟ estu serĉata\n"
"    GLOBIGNORE\tListo da ŝablonoj (disigitaj per dupunkto) difinanta\n"
"\t\tdosiernomojn ignorendajn ĉe malvolvo de dosierindikoj\n"
"    HISTFILE\tNomo de la dosiero por via komandohistorio\n"
"    HISTFILESIZE  Maksimuma nombro de linioj konserveblaj en HISTFILE\n"
"    HISTSIZE\tMaksimuma nombro de linioj el komandohistorio\n"
"\t\tatingeblaj el plenumata ŝelo\n"
"    HOME\tPlena dosierindiko pri via hejma dosierujo\n"
"    HOSTNAME\tNomo de la rulanta komputilo\n"
"    HOSTTYPE\tTipo de la ĉefprocesoro rulanta ĉi tiun Baŝon\n"
"    IGNOREEOF\tDeterminas la konduton de la ŝelo kiam ĝi ricevas\n"
"\t\tdosierfinilon (^D, \\004) kiel nuran enigaĵon.  Se ĝi\n"
"\t\tekzistas kaj havas nombran valoron, tiam ĉi tiu\n"
"                indikas, kiom da sinsekvaj dosierfinilojn toleri\n"
"\t\tantaŭ ol la ŝelo finiĝu (defaŭlte, 10).  Sen tia\n"
"\t\tvaloro,  ^D  signifas finon de enigo\n"
"    MACHTYPE\tSignoĉeno priskribanta la komputsistemon rulantan\n"
"\t\tĉi tiun Baŝon\n"
"    MAILCHECK\tKiom ofte (post kiom da sekundoj) Baŝo kontrolu\n"
"\t\tricevon de nova retpoŝta mesaĝo\n"
"    MAILPATH\tListo da dosiernomoj (disigitaj per dupunkto) kiujn\n"
"\t\tBaŝo testu pri nova retpoŝtaĵo\n"
"    OSTYPE\tVersio de Unikso sur kiu ĉi tiu Baŝo ruliĝas\n"
"    PATH\tListo da dosierujoj (disigitaj per dupunkto) kie serĉi\n"
"\t\tkomandojn\n"
"    PROMPT_COMMAND  Komando plenumenda antaŭ ĉiu unuaranga invito\n"
"    PS1\t\tSignoĉeno de la unuaranga invito\n"
"    PS2\t\tSignoĉeno de la duaranga invito\n"
"    PWD\t\tPlena dosierindiko de la kuranta dosierujo\n"
"    SHELLOPTS\tListo da aktivaj ŝelaj opcioj (disigitaj per dupunktoj)\n"
"    TERM\tTipo de la uzata terminalo\n"
"    TIMEFORMAT\tFormato por eligi tempostatistikon per la komando „time‟\n"
"    auto_resume\tSe ne vakua, indikas ke komandan vorton sole aperanta\n"
"\t\ten linio la ŝelo unue serĉu en la listo de haltetintaj\n"
"\t\tlaboroj. Se trovita tie, la laboro iĝu dialoga.\n"
"\t\tLa valoro „exact‟ postulas ekzaktan kongruon de la\n"
"\t\tkomanda vorto kun la komando el la laborlisto. La valoro\n"
"\t\t„substring‟ indikas ke la komanda vorto kongruu kun\n"
"\t\tsubĉeno de la laboro. Ĉia alia valoro indikas ke la\n"
"\t\tkomando estu komenca parto de la labornomo\n"
"    histchars\tSignoj regantaj reuzon de komandohistorio kaj rapidan\n"
"\t\tanstataŭigon. Unue estas la reuziga signo, kutime „!‟.\n"
"\t\tDue estas la signo de „rapida anstataŭigo‟, kutime „^‟.\n"
"\t\tTrie estas la signo de „historia komentilo‟,\n"
"\t\tkutime „#‟\n"
"    HISTIGNORE\tListo da ŝablonoj (disigitaj per dupunkto) difinanta\n"
"\t\tkiujn komandojn konservi en la historilisto\n"

# pushd [-n] [+N | -N | dir]
# pushd [-n] [+N | -N | DOSIERUJO]
#: builtins.c:1822
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Surstakigu dosierujojn\n"
"\n"
"    Surstakigu dosierujon sur la stakon da dosierujoj, aŭ cikle ŝovu\n"
"    la stakon tiel, ke la nova stakpinto estu la kuranta dosierujo.\n"
"    Senargumente, permutu la du plej suprajn dosierujojn de la stako.\n"
"\n"
"    Opcio:\n"
"    -n\tNe ŝanĝu la kurantan dosierujon (ne plenumu cd) surstakigante\n"
"        dosierujon sur la stakon; do, nur la stakon ŝanĝu\n"
"\n"
"    Argumentoj:\n"
"    +N\tCikle ŝovu la stakon tiel ke la Nª dosierujo (nombrante de\n"
"    \tmaldekstre en la listo eligebla per „dirs‟, numerante de 0)\n"
"        iĝu la pinta\n"
"\n"
"    -N\tCikle ŝovu la stakon tiel ke la Nª dosierujo (nombrante de\n"
"    \tdekstre en la listo eligebla per „dirs‟, numerante de 0) iĝu\n"
"        la pinta\n"
"\n"
"    DOSIERUJO\n"
"\tsurstakigu la DOSIERUJOn kaj faru ĝin la nova kuranta\n"
"    \tdosierujo labora\n"
"\n"
"    Vi povas vidigi la stakon da dosierujoj per la komando „dirs‟.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa argumento aŭ se cd malsukcesas."

# popd [-n] [+N | -N]
#: builtins.c:1856
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Elstakigu dosierujojn\n"
"\n"
"    Elstakigu erojn el la stako da dosierujoj.  Senargumente, forigu\n"
"    la pintan dosierujon kaj iru (cd) en la novan pintan dosierujon.\n"
"\n"
"    Opcio:\n"
"    -n\tNe ŝanĝu (cd) la kurantan dosierujon demetante dosierujon el\n"
"        la stako; do, nur la stakon ŝanĝu\n"
"\n"
"    Argumentoj:\n"
"    +N\tForigu la N-an eron de maldekstre de la listo eligebla per\n"
"\t„dirs‟, numerante ekde 0.  Ekz-e: «popd +0» forigas la plej\n"
"\tmaldekstran dosierujon; «popd +1», ĝian najbaron\n"
"\n"
"    -N\tForigu la N-an eron de dekstre de la listo eligebla per\n"
"        „dirs‟, numerante ekde 0.  Ekz-e: «popd -0» forigas la lastan\n"
"\tdosierujon; «popd -1», la antaŭlastan\n"
"\n"
"    Vi povas vidigi la stakon da dosierujoj per la komando „dirs‟.\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa argumento aŭ se cd malsukcesas."

# dirs [-clpv] [+N] [-N]
#: builtins.c:1886
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Listigu dosierujstakon\n"
"\n"
"    Listigu la kurantan dosierujstakon. La dosierujoj trafas en la\n"
"    stakon per la komando „pushd‟ kaj estas forigeblaj per la komando\n"
"    „popd‟.\n"
"\n"
"    Opcioj:\n"
"    -c  viŝu la dosierujstakon forigante el ĝi ĉiujn erojn\n"
"    -l  ne uzu mallongan formon de dosierujnomoj relative al via hejma\n"
"        dosierujo\n"
"    -p  listigu dosierujstakon lokante po unu eron sur linio\n"
"    -v  listigu po unu eron de la dosierujstako en linio, metante\n"
"        antaŭ la dosierujnomo ĝian numeron en la stako \n"
"\n"
"    Argumentoj:\n"
"    +N\teligu la N-an eron (numerante de maldekstre kaj ekde 0) de la\n"
"        listo eligebla per senopcia „dirs‟\n"
"\n"
"    -N\teligu la N-an eron (numerante de dekstre kaj ekde 0) en la\n"
"        listo eligebla per senopcia „dirs‟\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio aŭ okazas eraro."

# shopt [-pqsu] [-o] [optname ...]
# shopt [-pqsu] [-o] [OPCINOMO ...]
#: builtins.c:1917
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Ŝaltu kaj malŝaltu ŝelajn opciojn\n"
"\n"
"    Ŝanĝu la staton de ĉiu el la OPCINOMOj. Sen opciaj argumentoj,\n"
"    listigu ĉiujn doniajn OPCINOMOjn -- aŭ ĉiujn ŝelajn opciojn se\n"
"    neniu OPCINOMO estas donita, -- indikante pri ĉiu el ili, ĉu ĝi\n"
"    estas ŝaltita.\n"
"\n"
"    Opcioj:\n"
"    -o  limigu OPCINOMOJn je tiuj difinitaj por uzo per «set -o»\n"
"    -p  eligu ĉiun ŝelan opcion indikante ĉu ĝi estas ŝaltita\n"
"    -q  silentigu eligon\n"
"    -s  ŝaltu (aktivigu) ĉiun el la OPCINOMOj\n"
"    -u  malŝaltu (malaktivigu) ĉiun el la OPCINOMOj\n"
"\n"
"    Elirstato:\n"
"    Sukceso, se OPCINOMO estas ŝaltita; malsukceso, se aperas misa\n"
"    opcio, aŭ se OPCINOMO estas malŝaltita."

# printf [-v var] format [arguments]
# printf [-v VAR] FORMATO [ARGUMENTOJ]
#: builtins.c:1938
#, fuzzy
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in "
"printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a "
"format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as "
"appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""
"Aranĝu kaj eligu ARGUMENTOJn laŭ FORMATO.\n"
"\n"
"    Opcio:\n"
"    -v VAR  eligu en ŝelvariablon VAR anstataŭ en la ĉefeligujon\n"
"\n"
"    FORMATO estas signoĉeno entenanta 3 tipojn da objektoj:\n"
"    ordinaraj signoj, simple kopiataj en la ĉefeligujon;\n"
"    eskapsekvencoj por signo, konvertataj kaj kopiataj en la ĉefeligujon; \n"
"    kaj formataj specifoj, ĉiu el kiuj kaŭzas eligon de vica argumento.\n"
"\n"
"    Aldone al la normaj specifiloj laŭ „printf(1)‟,  printf komprenas:\n"
"\n"
"      „%b‟ igas malvolvi deklivajn (\\) eskapsekvencojn en sia argumento;\n"
"      „%q‟ encitiligu la argumenton en formon taŭgan por ŝela re-enigo;\n"
"      „%(fmt)T‟ servas por eligi data-tempan signoĉenon kiel farus\n"
"                „strftime(3)‟ laŭ la formatoĉeno fmt.\n"
"\n"
"    La formato estas iteracie reuzata kiom necesas por konsumi ĉiujn\n"
"    argumentojn.  Se estas malpli da argumentoj ol la formato\n"
"    bezonas, la kromaj specifoj estas interpretataj tiel, kvazaŭ la\n"
"    mankantaj argumentoj estus nuloj aŭ vakuaj signoĉenoj (laŭokaze).\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio aŭ okazas eraro pri skribo aŭ\n"
"    valorizo."

# complete [-abcdefgjksuv] [-pr] [-DEI] [-o OPCIO] [-A AGO] [-G ŜABLONO]
#          [-W VORTLISTO]  [-F FUNKCIO] [-C KOMANDO] [-X FILTRILO]
#          [-P PREFIKSO] [-S SUFIKSO] [NOMO ...]
#: builtins.c:1974
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are "
"supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -"
"I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Difinu, kiel Readline kompletigu argumentojn.\n"
"\n"
"    Por ĉiu NOMO difinu, kiel la argumentoj estu kompletigotaj.  Se\n"
"    nenia opcio estas donita, eligu la aktualajn \n"
"    kompletigoregulojn en formo reuzebla por enigo en la ŝelon.\n"
"\n"
"    Opcioj:\n"
"    -p\teligu kompletigoregulojn en formo uzebla por enigo en la ŝelon\n"
"    -r\tforigu la kompletigoregulon por ĉiu NOMO, aŭ, se nenia NOMO\n"
"\testas donita, ĉiujn kompletigoregulojn\n"
"    -D  apliku la indikitajn kompletigojn kaj agojn Defaŭlte por la\n"
"        komandoj sen specifa kompletigo-difino\n"
"    -E  apliku la indikitajn kompletigojn kaj agojn al vakuaj (Empty)\n"
"        komandoj (la kompletigoj provotaj en vakua komandolinio)\n"
"    -I  apliku la kompletigojn kaj agojn al la unua (kutime, la\n"
"        komanda) vorto\n"
"\n"
"    Ĉe provo kompletigi la agoj aplikiĝas laŭ la ordo de majusklaj\n"
"    opcioj en la ĉi-supra listo. Se pluraj opcioj estas donitaj, la\n"
"    opcio „-D“ antaŭas la opcion „-E“, kaj ili ambaŭ antaŭas la\n"
"    opcion „-I“.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se misa opcio estas donita, aŭ eraro okazis."

# compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat]
# 	[-W wordlist] [-P prefix] [-S suffix] [-X filterpat]
# 	[-F function] [-C command] [word]
# compgen [-abcdefgjksuv] [-o OPCIO]  [-A AGO] [-G ŜABLONO]
# 	[-W VORTLISTO]  [-F FUNKCIO] [-C KOMANDO] [-X FILTRILO]
# 	[-P PREFIKSO] [-S SUFIKSO] [VORTO]
#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Montru la eblajn kompletigojn depende je la opcioj\n"
"\n"
"    Destinita por uzo en ŝelfunkcio generanta eblajn kompletigojn.  Se\n"
"    la eventuala argumento VORTO estas donita, generu ĝiajn kongruaĵojn.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio aŭ okazas eraro."

# compopt [-o|+o OPCIO] [-DE] [NOMO ...]
#: builtins.c:2019
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Ŝanĝu aŭ vidigu opciojn pri kompletigo\n"
"\n"
"    Ŝanĝu la kompletigajn opciojn por ĉiu NOMO, aŭ - se nenia NOMO\n"
"    estas indikita - la nune plenumatan kompletigon.  Se nenia OPCIO\n"
"    estas donita, eligu la kompletigajn opciojn por ĉiu NOMO aŭ la\n"
"    kurantan kompletigan regularon.\n"
"\n"
"    Opcioj:\n"
"    -o OPCIO  Ŝaltu kompletigan OPCIOn por ĉiu NOMO\n"
"    -D        Ŝanĝu opciojn por la Defaŭlta komandokompletigo\n"
"    -E        Ŝanĝu opciojn por la vakua (Empty) komandokompletigo\n"
"    -I        Ŝanĝu la kompletigajn opciojn por la unua vorto.\n"
"\n"
"    Uzante «+o» anstataŭ «-o» oni malŝaltas la indikitan OPCIOn.\n"
"\n"
"    Argumentoj:\n"
"    Ĉiu NOMO indikas komandon, por kiu kompletiga regulo devas esti\n"
"    jam difinita per la primitivaĵo „complete‟.  Se nenia NOMO estas\n"
"    donita, tiam la komandon compopt devas voki funkcio generanta, kaj\n"
"    ĝuste la opcioj por ĉi tiu nune plenumata generilo de kompletigoj\n"
"    estu ŝanĝitaj.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio, aŭ por NOMO mankas difino de\n"
"    kompletiga regulo."

# mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback]
# 	[-c quantum] [array]
# mapfile [-n NOMBRILO] [-O ORIGINO] [-s NOMBRILO] [-t] [-u DN] [-C RETROVOKO]
# 	[-c KVANTO] [TABELO] 
#: builtins.c:2050
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable "
"ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable "
"MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard "
"input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly "
"or\n"
"    not an indexed array."
msgstr ""
"Legu liniojn el la ĉefenigujo en tabelvariablon\n"
"\n"
"    Legu liniojn el la ĉefenigujo en la entjerindican variablon\n"
"    TABELO, aŭ el la dosiernumero DN, se ĉeestas la opcio „-u‟.\n"
"    Defaŭlte TABELO estas la variablo MAPFILE.\n"
"\n"
"    Opcioj:\n"
"    -d DISIG    Por fini liniojn uzu ne la linifinilon, sed DISIG\n"
"    -n KIOM     Kopiu maksimume KIOMon da linioj.  Se KIOM\n"
"                estas 0, kopiu ĉiujn liniojn\n"
"    -O ORIGINO  Komencu valorizi la TABELOn ekde la indekso ORIGINO.\n"
"                La defaŭlta origino estas 0.\n"
"    -s KIOM     Ignoru KIOMon da unuaj linioj\n"
"    -t          Forigu la vostan DISIG el ĉiu legita linio (defaŭlte\n"
"                la linifinilon)\n"
"    -u DN       Legu per la dosiernunero DN anstataŭ el la ĉefenigujo\n"
"    -C RETROVOKO  Plenumu RETROVOKOn post ĉiu KVANTO da legitaj linioj\n"
"    -c KVANTO\tPo kiom da linioj legi inter sinsekvaj RETROVOKOj\n"
"\n"
"    Argumento:\n"
"    TABELO\tNomo de tabelvariablo uzota por la legotaj datumoj\n"
"\n"
"    Se „-C‟ aperas sen „-c‟, la defaŭlta kvanto estas 5000.  Ĉe\n"
"    komputo de RETROVOKO ĉi tiu ricevas la indicon de la sekva\n"
"    valorizota tabelano kaj la en ĝin skribotan linion kiel kromajn\n"
"    argumentojn.\n"
"\n"
"    Se mankas malimplica ORIGINO, mapfile viŝos la TABELOn antaŭ\n"
"    valorizi ĝin.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio aŭ TABELO estas nurlega aŭ\n"
"    ĝi ne estas entjerindica tabelo."

# readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback]
# 	  [-c quantum] [array]
#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Legu liniojn el dosiero en tabelvariablon.\n"
"\n"
"    Sinonimo de „mapfile‟."

#, c-format
#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: Misa asocitabela ŝlosilo"
