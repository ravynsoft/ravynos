# GNU Bourne Again SHell.
# Copyright (C) 2002 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Ruslan Batdalov <linnando@tolkien.ru>, 2002.
# Pavlo Marianov <acid@jack.kiev.ua>, 2014, 2018, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 5.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2021-02-17 11:04+0200\n"
"Last-Translator: Pavlo Marianov <acid@jack.kiev.ua>\n"
"Language-Team: Russian <gnu@d07.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Poedit 2.2.1\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "неправильный индекс массива"

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: удаляется атрибут nameref"

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: не удаётся преобразовать индекс в ассоциативный массив"

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: не удаётся присвоить значение нечисловому индексу"

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr ""
"%s: %s: необходимо использовать индекс при назначении ассоциативному массиву"

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: не удаётся создать файл: %s"

#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: не удаётся найти раскладку для команды"

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: первый непробельный символ не является «\"»"

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "нет закрывающего «%c» в %s"

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: отсутствует разделитель-двоеточие"

#: bashline.c:4733
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "«%s»: не удаётся отменить привязку в keymap команды"

#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "расширение скобки: не удаётся выделить память для %s"

#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "расширение скобки: не удалось выделить память для %u элементов"

#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "расширение скобки: не удалось выделить память для «%s»"

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "«%s»: недопустимый псевдоним"

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "редактирование строки не включено"

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "«%s»: недопустимое название раскладки"

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: не удаётся прочитать файл: %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "«%s»: неизвестное название функции"

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s не привязан ни к какой клавише.\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s можно вызвать через "

#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "«%s»: не удаётся отменить привязку"

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "счётчик циклов"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "имеет значение только для циклов «for», «while» или «until»"

#: builtins/caller.def:136
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Возвращает контекст вызова текущей подпрограммы.\n"
"    \n"
"    Если выражение не указано, возвращает «$line $filename».\n"
"    Если выражение указано, возвращает «$line $subroutine $filename».\n"
"    Эти дополнительные данные можно использовать для трассировки\n"
"    стека.\n"
"    \n"
"    Значение выражения означает количество кадров, которое нужно\n"
"    вызвать для возврата к текущему кадру. Первый кадр имеет номер 0.\n"
"    "

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "Не задана переменная HOME"

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "слишком много аргументов"

#: builtins/cd.def:342
msgid "null directory"
msgstr "нулевой каталог"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "Не задана переменная OLDPWD"

#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "строка %d: "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "предупреждение: "

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s: использование: "

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: для параметра требуется аргумент"

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: требуется числовой аргумент"

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s: не найден"

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s: недопустимый параметр"

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s: недопустимое название параметра"

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "«%s»: это недопустимый идентификатор"

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "недопустимое восьмеричное число"

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "недопустимое шестнадцатеричное число"

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "недопустимое число"

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: недопустимое указание сигнала"

#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "«%s»: это не идентификатор процесса и не допустимый указатель задания"

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s: переменная только для чтения"

#: builtins/common.c:273
#, fuzzy, c-format
msgid "%s: cannot assign"
msgstr "%s: не удаётся выполнить сброс"

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s за пределами диапазона"

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "аргумент"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s за пределами диапазона"

#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s: нет такого задания"

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s: нет управления заданиями"

#: builtins/common.c:301
msgid "no job control"
msgstr "нет управления заданиями"

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s: ограниченный режим"

#: builtins/common.c:313
msgid "restricted"
msgstr "ограниченный режим"

#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: это не не встроенная команда bash"

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "ошибка записи: %s"

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "ошибка назначения атрибутов терминала: %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "ошибка получения атрибутов терминала: %s"

#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: ошибка определения текущего каталога: %s: %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: неоднозначный указатель задания"

#: builtins/common.c:971
msgid "help not available in this version"
msgstr "справка отсутствует в этой версии"

#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: не удаётся выполнить сброс: %s доступен только для чтения"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s: не удаётся выполнить сброс"

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s: недопустимое название действия"

#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s: нет определения завершения"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "предупреждение: параметр -F может работать не так, как ожидается"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "предупреждение: параметр -C может работать не так, как ожидается"

#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "сейчас не выполняет функцию завершения"

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "можно использовать только внутри функции"

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "«-f» нельзя использовать для создания функций"

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s: значение функции можно только считать"

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: ссылочная переменная не может быть массивом"

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: переменные nameref, ссылающиеся сами на себя, не допускаются"

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr "%s: круговая ссылка на имя"

#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "«%s»: недопустимое название переменной для ссылки на имя"

#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: переменные массива нельзя уничтожить таким образом"

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: не удаётся преобразовать ассоциативный массив в индексированный"

#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: присвоение составного массива в кавычках устарело"

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "динамическая загрузка недоступна"

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "не удаётся открыть общий объект %s: %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "не удаётся найти %s в общем объекте %s: %s"

#: builtins/enable.def:422
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: динамически встроенная команда уже загружена"

#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "загрузка функции %s завершилась ошибкой (%d): не загружена"

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: не загружается динамически"

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: не удаётся удалить: %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s: это каталог"

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s: это не обычный файл"

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s: файл слишком велик"

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: не удаётся запустить бинарный файл"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: не удаётся запустить: %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "выход\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "не командный процессор login: используйте «exit»"

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Есть остановленные задания.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Есть выполняемые задания.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "команда не найдена"

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr "указание журнала команд"

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: не удаётся открыть временный файл: %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "текущий"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "задание %d запущено без возможности управления"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: недопустимый параметр — %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: для параметра требуется аргумент — %c\n"

#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "хэширование отключено"

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: таблица хэшей пустая\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "вызовы\tкоманда\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Команды, соответствующие ключевому слову «"
msgstr[1] "Команды, соответствующие ключевым словам «"
msgstr[2] "Команды, соответствующие ключевым словам «"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"нет разделов справки, соответствующих «%s».  Попробуйте ввести «help help» "
"или «man -k %s» или «info %s»."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: не удаётся открыть файл: %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Показанные ниже команды определены внутри командного процессора.  Чтобы "
"вывести полный список, введите «help».\n"
"Чтобы вывести справку по функции «name», введите «help name».\n"
"Чтобы вывести справку по командному процессору, введите «info bash».\n"
"Чтобы вывести справку по командам, которые отсутствуют в этом списке, "
"введите «man -k» или «info».\n"
"\n"
"Звёздочка (*) рядом с названием команды означает, что эта команда "
"отключена.\n"
"\n"

#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "нельзя использовать больше одного параметра -anrw"

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "положение журнала команд"

#: builtins/history.def:338
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: недопустимая метка времени"

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: не удалось расширить журнал команд"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: ошибка inlib"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "с параметром «-x» нельзя указывать другие параметры"

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: аргументами должны быть идентификаторы процессов или заданий"

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Неизвестная ошибка"

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "ожидается выражение"

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: это не индексированный массив"

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: недопустимое указание дескриптора файла"

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: invalid недопустимый дескриптор файла: %s"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s: недопустимое число строк"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: недопустимое начало массива"

#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: недопустимый квант обратного вызова"

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "пустое имя переменной массива"

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr "требуется поддержка переменных массива"

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "«%s»: отсутствует символ форматирования"

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "«%c»: недопустимое указание формата времени"

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "«%c»: недопустимый символ форматирования"

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "предупреждение: %s: %s"

#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr "ошибка анализа формата: %s"

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "отсутствует шестнадцатеричная цифра для \\x"

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "отсутствует цифра Юникода для \\%c"

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "отсутствует другой каталог"

#: builtins/pushd.def:360
#, c-format
msgid "%s: invalid argument"
msgstr "%s: недопустимый аргумент"

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "<отсутствует текущий каталог>"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "стек каталогов пуст"

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "индекс стека каталогов"

#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Выводит список запомненных на данный момент каталогов.  Каталоги\n"
"    помещаются в список командой «pushd». Для очистки\n"
"    списка используется команда «popd».\n"
"    \n"
"    Параметры:\n"
"      -c\tочистить стек каталогов, удалив из него все элементы\n"
"      -l\tне выводить каталоги, начинающиеся с тильды (~),\n"
"    \tкоторая означает домашний каталог\n"
"      -p\tпоказать стек по одному каталогу в строке\n"
"      -v\tпоказать стек по одному каталогу в строке\n"
"    \tи с номером в стеке\n"
"    \n"
"    Аргументы:\n"
"      +N\tпоказать N-ю запись слева в списке каталогов,\n"
"    \tпоказанного при вызове без параметров, начиная с нуля.\n"
"    \n"
"      -N\tпоказать N-ю запись справа в списке каталогов,\n"
"\tпоказанного при вызове без параметров, начиная с нуля."

#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Добавляет каталог в начало стека каталогов или выполняет\n"
"    ротацию стека, помещая в начало стека текущий рабочий\n"
"    каталог.  Если аргументы не указаны, меняет местами два первых "
"каталога.\n"
"    \n"
"    Параметры:\n"
"      -n\tпредотвращает обычное изменение каталога при добавлении\n"
"    \tкаталогов в стек, чтобы действия выполнялись только над стеком.\n"
"    \n"
"    Аргументы:\n"
"      +N\tвыполняет ротацию стека, чтобы N-й каталог (слева\n"
"    \tв списке, показанного командой «dirs», начиная с нуля)\n"
"    \tстал первым в стеке.\n"
"    \n"
"      -N\tвыполняет ротацию стека, чтобы N-й каталог (справа\n"
"    \tв списке, показанного командой «dirs», начиная с нуля)\n"
"    \tстал первым в стеке.\n"
"    \n"
"      каталог\tдобавляет каталог в начало стека каталогов, делая его\n"
"    \tновым текущим каталогом.\n"
"    \n"
"    Встроенная команда dirs показывает стек каталогов."

#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Удаляет записи из стека каталогов.  Если аргументы не указаны,\n"
"    удаляет первый каталог из стека и назначает новый первый каталог.\n"
"    \n"
"    Параметры:\n"
"      -n\tпредотвращает обычное изменение каталога при удалении\n"
"    \tкаталогов из стека, чтобы действия выполнялись только над стеком.\n"
"    \n"
"    Аргументы:\n"
"      +N\tудаляет N-ю слева запись в списке каталогов,\n"
"    \tпоказанного командой «dirs», начиная с нуля.  Например, «popd +0»\n"
"    \tудаляет первый каталог, а «popd +1» — второй каталог.\n"
"    \n"
"      -N\tудаляет N-ю справа запись в списке каталогов,\n"
"    \tпоказанного командой «dirs», начиная с нуля.  Например, «popd -0»\n"
"    \tудаляет последний каталог, а «popd -1» — предпоследний каталог.\n"
"    \n"
"    Встроенная команда dirs показывает стек каталогов."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: недопустимое указание тайм-аута"

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "ошибка чтения: %d: %s"

#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr "возврат можно выполнить только из функции или исходного скрипта"

#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr "нельзя одновременно сбросить функцию и переменную"

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s: это не переменная массива"

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s: это не функция"

#: builtins/setattr.def:194
#, c-format
msgid "%s: cannot export"
msgstr "%s: не удаётся экспортировать"

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "счётчик смещений"

#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "нельзя одновременно задать и сбросить параметры командного процессора"

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: недопустимое название параметра командного процессора"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "требуется аргумент с именем файла"

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s: файл не найден"

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "не удаётся приостановить"

#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "не удаётся приостановить командный процессор login"

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s — это псевдонимом для «%s»\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s — это ключевое слово командного процессора\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s — это функция\n"

#: builtins/type.def:299
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s — это специальная встроенная команда bash\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s — это встроенная команда bash\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "%s является %s\n"

#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "для %s вычислен хэш (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: недопустимый аргумент ограничения"

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "«%c»: недопустимая команда"

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: не удаётся получить ограничение: %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "ограничение"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: не удаётся изменить ограничение: %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "восьмеричное число"

#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "«%c»: недопустимый оператор символьного режима"

#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "«%c»: недопустимый знак символьного режима"

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " строка "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "последняя команда: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Прерывание..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr "ИНФО: "

#: error.c:310
#, fuzzy, c-format
msgid "DEBUG warning: "
msgstr "предупреждение: "

#: error.c:488
msgid "unknown command error"
msgstr "неизвестная ошибка команды"

#: error.c:489
msgid "bad command type"
msgstr "неверный тип команды"

#: error.c:490
msgid "bad connector"
msgstr "неверный соединитель"

#: error.c:491
msgid "bad jump"
msgstr "ошибка перехода"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s: не заданы границы переменной"

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aпревышено время ожидания ввода: auto-logout\n"

#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "не удаётся перенаправить стандартный ввод из /dev/null: %s"

#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: «%c»: недопустимый символ форматирования"

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: coproc [%d:%s] всё ещё существует"

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "ошибка конвейера"

#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: достигнут максимальный уровень вложенности eval (%d)"

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: достигнут максимальный уровень вложенности source (%d)"

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: достигнут максимальный уровень вложенности функций (%d)"

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr ""
"%s: ограниченный режим: в названиях команд нельзя использовать косую черту "
"«/»"

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s: команда не найдена"

#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5975
#, fuzzy, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: не удаётся запустить бинарный файл"

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: неверный интерпретатор"

#: execute_cmd.c:6037
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: не удаётся запустить бинарный файл: %s"

#: execute_cmd.c:6123
#, c-format
msgid "`%s': is a special builtin"
msgstr "«%s»: это специальная встроенная команда"

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "не удаётся скопировать файловый дескриптор %d в %d"

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "слишком много вложенных выражений"

#: expr.c:291
msgid "recursion stack underflow"
msgstr "отрицательное переполнение стека вложенных выражений"

#: expr.c:478
msgid "syntax error in expression"
msgstr "синтаксическая ошибка в выражении"

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "значение можно присвоить только переменной"

#: expr.c:531
msgid "syntax error in variable assignment"
msgstr "синтаксическая ошибка в назначении переменной"

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "деление на 0"

#: expr.c:593
msgid "bug: bad expassign token"
msgstr "ошибка: недопустимый маркер присвоения выражения"

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "в условном выражении должен быть символ «:»"

#: expr.c:973
msgid "exponent less than 0"
msgstr "экспонента меньше нуля"

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr ""
"после предварительного инкремента или декремента ожидается идентификатор "

#: expr.c:1057
msgid "missing `)'"
msgstr "отсутствует символ «)»"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "синтаксическая ошибка: ожидается операнд"

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "ошибка синтаксиса: недопустимый математический оператор"

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (неверный маркер «%s»)"

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "недопустимое математическое основание"

#: expr.c:1587
msgid "invalid integer constant"
msgstr "недопустимая целочисленная константа"

#: expr.c:1603
msgid "value too great for base"
msgstr "слишком большое значение для основания"

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s: ошибка выражения\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: нет доступа к родительским каталогам"

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "не удаётся сбросить режим nodelay для файлового дескриптора %d"

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr ""
"не удаётся выделить новый дескриптор для входных данных bash из файлового "
"дескриптора %d"

#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: у нового файлового дескриптора %d уже есть буфер"

#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp pipe"

#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "идентификатор дочернего процесса %d принадлежит запущенному заданию %d"

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "удаление остановленного задания %d с группой процесса %ld"

#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr ""
"add_process: процесс с идентификатором %5ld (%s) помечен как всё ещё активный"

#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: нет процесса с таким идентификатором"

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "Сигнал %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Завершён"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Остановлен"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Остановлен (%s)"

#: jobs.c:1881
msgid "Running"
msgstr "Запущен"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Завершён (%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Выход %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "Состояние неизвестно"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(образ памяти сброшен на диск) "

#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (рабочий каталог: %s)"

#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "дочерний setpgid (%ld к %ld)"

#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr ""
"wait: процесс %ld не является дочерним процессом этого командного процессора"

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: нет записей процесса %ld"

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: задание %d остановлено"

#: jobs.c:3551
#, c-format
msgid "%s: no current jobs"
msgstr "%s: нет текущих заданий"

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s: выполнение задания прервано"

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: задание %d уже выполняется в фоновом режиме"

#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr ""
"waitchld: включается WNOHANG, чтобы предотвратить появление неопределённого "
"блока"

#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s: строка %d: "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr " (образ памяти сброшен на диск)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(рабочий каталог: %s)\n"

#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: ошибка вызова getpgrp "

#: jobs.c:4434
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: нельзя управлять заданиями в фоновом режиме"

#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: дисциплина строки"

#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "не удаётся задать группу процесса терминала (%d)"

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "этот командный процессор не может управлять заданиями"

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: ошибка утверждения: %s\n"

#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\\r\n"
"malloc: %s:%d: утверждение не удалось\\r\n"

#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "неизвестно"

#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "malloc: блок в списке свободных затёрт"

#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "free: вызван с аргументом уже освобождённого блока"

#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "free: вызван с аргументом невыделенного блока"

#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr ""
"free: обнаружено отрицательное переполнение; mh_nbytes байт за пределами "
"диапазона"

#: lib/malloc/malloc.c:1007
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: обнаружено отрицательное переполнение; magic8 повреждён"

#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "free: размеры начального и конечного блока отличаются"

#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "realloc: вызван с аргументом невыделенного блока"

#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr ""
"realloc: обнаружено отрицательное переполнение; mh_nbytes байт за пределами "
"диапазона"

#: lib/malloc/malloc.c:1197
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: обнаружено отрицательное переполнение; magic8 повреждён"

#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: размеры начального и конечного блока отличаются"

#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: таблица выделения заполнена записями FIND_ALLOC?\n"

#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p уже есть в таблице как выделенный?\n"

#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p уже есть в таблице как свободный?\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "недопустимое основание"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: узел неизвестен"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: недопустимая служба"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: недопустимое указание сетевого пути"

#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "сетевые операции не поддерживаются"

#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: не удаётся изменить язык (%s)"

#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: не удаётся изменить язык (%s): %s"

#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: не удаётся изменить язык (%s)"

#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: не удаётся изменить язык (%s): %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Для вас есть почта в $_"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Для вас есть почта в $_"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Сообщения в %s были прочитаны\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "синтаксическая ошибка: требуется математическое выражение"

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "синтаксическая ошибка: ожидается «;»"

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "синтаксическая ошибка: «((%s))»"

#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: недопустимый тип инструкции %d"

#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr ""
"блок here-document в строке %d разделён знаком конца файла (ожидался «%s»)"

#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr ""
"make_redirection: инструкция перенаправления «%d» вышла за пределы диапазона"

#: parse.y:2428
#, c-format
msgid ""
"shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line "
"truncated"
msgstr ""
"shell_getc: shell_input_line_size (%zu) превысил SIZE_MAX (%lu): строка "
"обрезана"

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr "достигнуто максимальное число переменных here-document"

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "неожиданный конец файла во время поиска «%c»"

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "неожиданный конец файла во время поиска «]]»"

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "синтаксическая ошибка в условном выражении: неожиданный маркер «%s»"

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "синтаксическая ошибка в условном выражении"

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "неожиданный маркер «%s», ожидался «)»"

#: parse.y:4543
msgid "expected `)'"
msgstr "ожидается символ «)»"

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "неожиданный аргумент «%s» для условного унарного оператора"

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr "неожиданный аргумент для условного унарного оператора"

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "неожиданный маркер «%s», ожидается условный бинарный оператор"

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr "ожидается условный бинарный оператор"

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "неожиданный аргумент «%s» для условного бинарного оператора"

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr "неожиданный аргумент для условного бинарного оператора"

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "неожиданный маркер «%c» в условной команде"

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "неожиданный маркер «%s» в условной команде"

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "неожиданный маркер %d в условной команде"

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "синтаксическая ошибка рядом с неожиданным маркером «%s»"

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "синтаксическая ошибка рядом с «%s»"

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "синтаксическая ошибка: неожиданный конец файла"

#: parse.y:6151
msgid "syntax error"
msgstr "синтаксическая ошибка"

#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Для выхода из командного процессора используйте «%s».\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "неожиданный конец файла во время поиска «)»"

#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: функция «%s» не найдена"

#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: возможен бесконечный цикл повторов"

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULL COMPSPEC"

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: неверный соединитель «%d»"

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: недопустимый идентификатор файла"

#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: пустой указатель на файл"

#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != fileno xtrace fp (%d)"

#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: «%c»: недопустимый символ форматирования"

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "файловый дескриптор за пределами диапазона"

#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: неоднозначное перенаправление"

#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: не удаётся перезаписать существующий файл"

#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: ограниченный режим: не удаётся перенаправить вывод"

#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "не удаётся создать временный файл для блока here-document: %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: не удаётся присвоить файловый дескриптор переменной"

#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port не поддерживается без сети"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "ошибка перенаправления: не удаётся создать копию файлового дескриптора"

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "не удалось найти /tmp; создайте этот каталог"

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "/tmp должен быть допустимым названием каталога"

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr "режим печати игнорируется в интерактивных командных процессорах"

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: недопустимый параметр"

#: shell.c:1343
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "не удаётся установить UID %d: эффективный UID %d"

#: shell.c:1354
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "не удаётся установить GID %d: эффективный GID %d"

#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr "не удаётся запустить отладчик: режим отладки отключён"

#: shell.c:1658
#, c-format
msgid "%s: Is a directory"
msgstr "%s: это каталог"

#: shell.c:1907
msgid "I have no name!"
msgstr "Не удаётся определить название"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, версия %s-(%s)\n"

#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Использование:\t%s [длинные параметры GNU] [параметры] ...\n"
"\t\t%s [длинные параметры GNU] [параметры] файл_скрипта ...\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "Длинные параметры GNU:\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Параметры командного процессора:\n"

#: shell.c:2069
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr ""
"\t-irsD или -c команда или -O короткие_параметры\t\t(только при запуске)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s или -o параметр\n"

#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr ""
"Для получения дополнительных сведений о параметрах командного процессора "
"введите «%s -c \"help set\"».\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Для получения дополнительных сведений о встроенных командах введите «%s -c "
"help».\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Для отправки сообщений об ошибках используйте команду «bashbug».\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "Домашняя страница bash: <http://www.gnu.org/software/bash>\n"

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr ""
"Общая справка по использованию программ GNU: <http://www.gnu.org/gethelp/>\n"

#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: недопустимая операция"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Фиктивный сигнал"

#: siglist.c:51
msgid "Hangup"
msgstr "Отбой"

#: siglist.c:55
msgid "Interrupt"
msgstr "Прерывание"

#: siglist.c:59
msgid "Quit"
msgstr "Выход"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Недопустимая инструкция"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Трасса/ловушка BPT"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Инструкция ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Инструкция EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Исключение при обработке чисел с плавающей точкой"

#: siglist.c:87
msgid "Killed"
msgstr "Убит"

#: siglist.c:91
msgid "Bus error"
msgstr "Ошибка шины"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Ошибка сегментации"

#: siglist.c:99
msgid "Bad system call"
msgstr "Неверный системный вызов"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Конвейер не работает"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Сигнал часов"

#: siglist.c:111
msgid "Terminated"
msgstr "Прерван"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Срочное событие ввода/вывода"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Остановлен (сигналом)"

#: siglist.c:127
msgid "Continue"
msgstr "Продолжение"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Смерть или остановка дочернего процесса"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Остановлен (ввод с tty)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Остановлен (вывод на tty)"

#: siglist.c:147
msgid "I/O ready"
msgstr "Готов к вводу/выводу"

#: siglist.c:151
msgid "CPU limit"
msgstr "Ограничение ЦП"

#: siglist.c:155
msgid "File limit"
msgstr "Ограничение величины файла"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Сигнал часов (виртуальный)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Сигнал часов (профиль)"

#: siglist.c:167
msgid "Window changed"
msgstr "Окно изменено"

#: siglist.c:171
msgid "Record lock"
msgstr "Запись блокирована"

#: siglist.c:175
msgid "User signal 1"
msgstr "Сигнал пользователя 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Сигнал пользователя 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "Ожидание входных данных HFT"

#: siglist.c:187
msgid "power failure imminent"
msgstr "неизбежна ошибка питания"

#: siglist.c:191
msgid "system crash imminent"
msgstr "неизбежно падение системы"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "процесс переносится на другой ЦП"

#: siglist.c:199
msgid "programming error"
msgstr "программная ошибка"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "Установлен режим монитора HFT"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "Выход из режима монитора HFT"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "Последовательность звуков HFT завершена"

#: siglist.c:215
msgid "Information request"
msgstr "Информационный запрос"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Неизвестный номер сигнала %d"

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "неверная подстановка: нет закрывающей «%s» в %s"

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: не удаётся присвоить список элементу массива"

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "не удаётся создать конвейер для подстановки процесса"

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "не удаётся создать дочерний процесс для подстановки"

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "не удаётся открыть именованный конвейер %s для чтения"

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "не удаётся открыть именованный конвейер %s для записи"

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr ""
"не удаётся скопировать именованный конвейер %s  в файловый дескриптор %d"

#: subst.c:6370
msgid "command substitution: ignored null byte in input"
msgstr "подстановка команды: во входных данных проигнорирован нулевой байт"

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "не удаётся создать конвейер для подстановки команды"

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "не удаётся создать дочерний процесс для подстановки команды"

#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr ""
"command_substitute: не удаётся скопировать конвейер в файловый дескриптор 1"

#: subst.c:7082 subst.c:10252
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: недопустимое название переменной для ссылки на имя"

#: subst.c:7178 subst.c:7196 subst.c:7369
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: недопустимое непрямое раскрытие"

#: subst.c:7212 subst.c:7377
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: недопустимое имя переменной"

#: subst.c:7478
#, c-format
msgid "%s: parameter not set"
msgstr "%s: параметр не задан"

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: параметр не задан или пустой"

#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: заданное подстрокой выражение меньше нуля"

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s: недопустимая подстановка"

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: такое присвоение невозможно"

#: subst.c:10111
msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr ""
"в будущих версиях командный процессор оценка будет выполняться как "
"математическая подстановка"

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "неверная подстановка: нет закрывающей «`» в %s"

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "нет совпадений: %s"

#: test.c:147
msgid "argument expected"
msgstr "ожидается аргумент"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: ожидается целочисленное выражение"

#: test.c:265
msgid "`)' expected"
msgstr "ожидается символ «)»"

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "ожидается символ «)», обнаружено %s"

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: ожидается бинарный оператор"

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: ожидается унарный оператор"

#: test.c:896
msgid "missing `]'"
msgstr "отсутствует символ «]»"

#: test.c:914
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "синтаксическая ошибка: неожиданный «%s»"

#: trap.c:220
msgid "invalid signal number"
msgstr "недопустимый номер сигнала"

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr ""
"обработка ловушек: достигнут максимальный уровень вложенности обработки "
"ловушек (%d)"

#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: неверное значение в trap_list[%d]: %p"

#: trap.c:416
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""
"run_pending_traps: обработчик сигнала — SIG_DFL; повторная отправка %d (%s) "
"самому себе"

#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: неверный сигнал %d"

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "ошибка импорта определения функции для «%s»"

#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "слишком высокий уровень командного процессора (%d); сбрасывается до 1"

#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: в текущей области отсутствует контекст функции"

#: variables.c:2661
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: переменной не может быть присвоено значение"

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr ""

#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: целое числе присваивается ссылке на имя"

#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: в текущей области отсутствует контекст функции"

#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "%s имеет пустую exportstr"

#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "недопустимый символ %d в exportstr для %s"

#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "отсутствует «=» в exportstr для %s"

#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""
"pop_var_context: заголовок shell_variables не является контекстом функции"

#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: отсутствует контекст global_variables"

#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr ""
"pop_scope: заголовок shell_variables не является областью временного "
"окружения"

#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: не удаётся открыть как ФАЙЛ"

#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: недопустимое значение для дескриптора файла трассировки"

#: variables.c:6450
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: значение совместимости за пределами диапазона"

#: version.c:46 version2.c:46
#, fuzzy
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "© Free Software Foundation, Inc, 2020."

#: version.c:47 version2.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"Лицензия GPLv3+: GNU GPL версии 3 или более поздней <http://gnu.org/licenses/"
"gpl.html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, версия %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr ""
"Это свободное программное обеспечение. Вы можете изменять и распространять "
"его."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "НИКАКАЯ ГАРАНТИЯ не предоставляется в пределах, допускаемых законом."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: не удаётся выделить %lu байт (выделено %lu байт)"

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: не удаётся выделить %lu байт"

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: не удаётся выделить %lu байт (выделено %lu байт)"

#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: не удаётся выделить %lu байт"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [имя[=значение] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] имя [имя ...]"

#: builtins.c:53
msgid ""
"bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpvsPSVX] [-m раскладка] [-f файл] [-q имя] [-u name] [-r "
"послед_клавиш] [-x послед_клавиш:команда_shell] [послед_клавиш:фнкц_readline "
"или команда_readline]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [встр_команда [аргумент ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [выражение]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [каталог]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] команда [аргумент ...]"

#: builtins.c:78
#, fuzzy
msgid ""
"declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] "
"[name ...]"
msgstr "declare [-aAfFgiIlnrtux] [-p] [имя[=значение] ...]"

#: builtins.c:80
#, fuzzy
msgid ""
"typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] "
"[name ...]"
msgstr "typeset [-aAfFgiIlnrtux] [-p] имя[=значение] ..."

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [параметр] имя[=значение] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [аргумент ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [аргумент ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f файл] [имя ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [аргумент ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts строка_параметров имя [аргумент ...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a имя] [команда [аргумент ...]] [перенаправление ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr ""
"fc [-e редактор] [-lnr] [первая] [последняя] или fc -s [шаблон=замена] "
"[команда]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [задание]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [задание ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p путь] [-dt] [имя ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [шаблон ...]"

#: builtins.c:123
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d смещение] [n] или history -anrw [файл] или history -ps "
"аргумент [аргумент...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [задание ...] или jobs -x команда [аргументы]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [задание ... | pid ...]"

#: builtins.c:134
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s назв_сигнала | -n номер_сигнала | -назв_сигнала] ид_процесса | "
"назв_задания] ... или kill -l [назв_сигнала]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let аргумент [аргумент ...]"

#: builtins.c:138
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a массив] [-d разделитель] [-i текст] [-n число_символов] [-N "
"число_символов] [-p приглашение] [-t тайм-аут] [-u fd] [имя ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
#, fuzzy
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCHP] [-o параметр] [--] [аргумент ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [имя ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [имя[=значение ...] или export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [имя[=значение] ...] или readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source файл [аргументы]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". файл [аргументы]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [выражение]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ аргумент... ]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[аргумент] сигнал ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] имя [имя ...]"

#: builtins.c:171
#, fuzzy
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPT] [ограничение]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [режим]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p переменная] [идентификатор ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [идентификатор ...]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for ИМЯ [in СЛОВА... ;] do КОМАНДЫ; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( выраж1; выраж2; выраж3 )); do КОМАНДЫ; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select ИМЯ [in СЛОВА ... ;] do КОМАНДЫ; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] конвейер"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case СЛОВО in [ШАБЛОН [| ШАБЛОН]...) КОМАНДЫ ;;]... esac"

#: builtins.c:194
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if КОМАНДЫ; then КОМАНДЫ; [ elif КОМАНДЫ; then КОМАНДЫ; ]... [ else "
"КОМАНДЫ; ] fi"

#: builtins.c:196
#, fuzzy
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while КОМАНДЫ; do КОМАНДЫ; done"

#: builtins.c:198
#, fuzzy
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until КОМАНДЫ; do КОМАНДЫ; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [ИМЯ] команда [перенаправления]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function ИМЯ { КОМАНДЫ ; } или ИМЯ () { КОМАНДЫ ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ КОМАНДЫ ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "задание [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( выражение ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ выражение ]]"

#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr ""
"переменные — имена и значения некоторых переменных командного процессора"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | каталог]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [параметр ...]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v переменная] формат [аргументы]"

#: builtins.c:231
msgid ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-"
"W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o параметр] [-A действие] [-G "
"глоб_шаблон] [-W список_слов] [-F функция] [-C команда] [-X фильтр_шабл] [-P "
"префикс] [-S суффикс] [имя ...]"

#: builtins.c:235
msgid ""
"compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-"
"F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o параметр] [-A действие] [-G глоб_шабл] [-W "
"список_слов] [-F функция] [-C команда] [-X фильтр_шабл] [-P префикс] [-S "
"суффикс] [слово]"

#: builtins.c:239
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o параметр] [-DEI] [имя ...]"

#: builtins.c:242
msgid ""
"mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"mapfile [-d разделитель] [-n число] [-O начало] [-s число] [-t] [-u fd] [-C "
"callback] [-c quantum] [массив]"

#: builtins.c:244
msgid ""
"readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"readarray [-d разделитель] [-n число] [-O начало] [-s число] [-t] [-u fd] [-"
"C callback] [-c quantum] [массив]"

#: builtins.c:256
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"Определение или отображение псевдонимов.\n"
"    \n"
"    Если не указать аргументы, alias выводит список псевдонимов\n"
"    в виде «alias имя=значение» на стандартный вывод.\n"
"    \n"
"    В противном случае каждому имени, для которого указано значение,\n"
"    назначается псевдоним. Если значение в конце содержит пробел,\n"
"    следующее слово будет проверяться на замену псевдонима при его\n"
"    развёртывании.\n"
"    \n"
"    Параметры:\n"
"      -p\tвыводит все определённые псевдонимы\n"
"    \n"
"    Состояние выхода:\n"
"    alias возвращает истину, если для указанного имени был задан\n"
"    псевдоним."

#: builtins.c:278
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Удаляет все имена из списка определённых псевдонимов.\n"
"    \n"
"    Параметры:\n"
"      -a\tудаляет все псевдонимы\n"
"    \n"
"    Возвращает успех, если имя связано с существующим псевдонимом."

#: builtins.c:291
#, fuzzy
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated "
"commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Определение привязок клавиш и переменных readline.\n"
"    \n"
"    Привязывает последовательность клавиш функции readline или макросу\n"
"    или задаёт переменную readline.  Синтаксис аргументов без параметров "
"аналогичен\n"
"    синтаксису файла ~/.inputrc, но всё должно передаваться в одном "
"аргументе,\n"
"    например bind '\"\\C-x\\C-r\": перечитать-init-файл'.\n"
"    \n"
"    Параметры:\n"
"      -m  раскладка      использовать указанную раскладку во время "
"выполнения\n"
"                         данной команды.  Допустимые раскладки: emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command и vi-insert.\n"
"      -l                 вывести названия функций\n"
"      -P                 вывести названия функций и их привязки\n"
"      -p                 вывести функции и их привязки в формате\n"
"                         для повторного использования\n"
"      -S                 вывести список последовательностей клавиш, которые\n"
"                   вызывают макросы, и их значения\n"
"      -s                 вывести список последовательностей клавиш, которые\n"
"                   вызывают макросы, и их значения\n"
"                         в формате для повторного использования\n"
"      -V                 вывести названия переменных и их значения\n"
"      -v                 вывести имена переменных и их значения\n"
"                         в формате для повторного использования\n"
"      -q  имя_функции\t вывести клавиши, вызывающие указанную функцию\n"
"      -u  имя_функции    отвязать все клавиши, привязанные к указанной "
"функции\n"
"      -r  посл-клавиш    удалить привязку для последовательности клавиш\n"
"      -f  файл           прочитать привязки из файла\n"
"      -x  посл-клавиш:кмнд-shell выполнить команду bash, если введена\n"
"    \t\t\t\tпоследовательность клавиш\n"
"      -X\t\t     вывести последовательности клавиш, привязанные с помощью -"
"x, и связанные команды\n"
"                         в формате для повторного использования\n"
"    \n"
"    Состояние выхода:\n"
"    bind возвращает 0, если был указан допустимый параметр или не возникла "
"ошибка."

#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Прерывание цикла for, while или until.\n"
"    \n"
"    Прерывает цикл for, while или until.  Если указано N, прерывает N "
"вложенных\n"
"    циклов.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 0, если N не больше или равно 1."

#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Возобновление цикла for, while или until.\n"
"    \n"
"    Возобновляет следующую итерацию вложенного цикла for, while или until.\n"
"    Если указано N, возобновляет N-й вложенный цикл.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 0, если N не больше или равно 1."

#: builtins.c:354
#, fuzzy
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Выполнение встроенных команд.\n"
"    \n"
"    Выполняет встроенную команду bash с аргументами\n"
"    без поиска команды.  Это полезно, если нужно переопределить встроенную "
"команду\n"
"    как функцию командного процессора, в этой функции нужно выполнить "
"встроенную команду.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние выхода встроенной команды или ложь, если указанная "
"команда bash\n"
"    не является встроенной."

#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Возвращает контекст вызова текущей подпрограммы.\n"
"    \n"
"    Если выражение не указано, возвращает «$line $filename».  Если выражение "
"указано, возвращает\n"
"    «$line $subroutine $filename». Эти дополнительные данные можно\n"
"    использовать для трассировки стека.\n"
"    \n"
"    Значение выражения означает количество кадров, которое нужно вызвать\n"
"    для возврата к текущему кадру. Первый кадр имеет номер 0.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 0, если командный процессор не выполняет функцию, или "
"выражение\n"
"    является допустимым."

#: builtins.c:387
#, fuzzy
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname "
"component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully "
"when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Смена рабочего каталога командного процессора.\n"
"    \n"
"    Изменяет текущий каталог на указанный каталог.  Каталог по умолчанию "
"хранится в\n"
"    переменной $HOME командного процессора.\n"
"    \n"
"    Переменная $CDPATH определяет путь поиска каталога, содержащего\n"
"    указанный каталог.  Альтернативные каталоги в $CDPATH разделяются "
"двоеточием (:).\n"
"    Пустое название каталога соответствует текущему каталогу.  Если каталог "
"начинается\n"
"    с косой черты (/), переменная $CDPATH не используется.\n"
"    \n"
"    Если каталог не найден и задан параметр «cdable_vars»,\n"
"    слово считается названием переменной.  Если эта переменная содержит "
"значение,\n"
"    оно используется для каталога.\n"
"    \n"
"    Параметры:\n"
"        -L\tпереходить по символьным ссылкам: ссылки раскрываются \n"
"    \tв каталоге после обработки экземпляров «..»\n"
"        -P\tиспользовать физическую структуру каталогов без перехода\n"
"    \tпо символьным ссылкам: ссылки раскрываются в каталоге до\n"
"    \tобработки «..»\n"
"        -e\tесли указан параметр -P, и не удаётся определить текущий\n"
"    \tрабочий каталог, команда завершается с ненулевым состоянием\n"
"        -@  на системах, которые это поддерживают, представляет файл с "
"расширенными\n"
"            атрибутами как каталог, содержащий атрибуты файла\n"
"    \n"
"    По умолчанию выполняется переход по символьным ссылкам (как при указании "
"параметра «-L»).\n"
"    «..» обрабатывается путём удаления первого компонента пути до косой "
"черты\n"
"    или из начала каталога.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 0, если каталог был изменён, и если $PWD был успешно "
"установлен\n"
"    при использовании параметра -P. В противном случае возвращается "
"ненулевое состояние."

#: builtins.c:425
#, fuzzy
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Вывод названия текущего рабочего каталога.\n"
"    \n"
"    Параметры:\n"
"      -L\tпоказать значение $PWD, если переменная указывает на\n"
"    \tтекущий рабочий каталог\n"
"      -P\tпоказать название физического каталога без символьных ссылок\n"
"    \n"
"    По умолчанию pwd работает, как если бы «-L» не был указан.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 0, если был указан допустимый параметр или можно прочитать\n"
"    текущий каталог."

#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Пустая команда.\n"
"    \n"
"    Команда не выполняет никаких действий и ни на что не влияет.\n"
"    \n"
"    Состояние выхода:\n"
"    Всегда возвращает успех."

#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Возвращает результат успешного выполнения.\n"
"    \n"
"    Состояние выхода:\n"
"    Всегда возвращает успех."

#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Возвращает результат неудачного выполнения.\n"
"    \n"
"    Состояние выхода:\n"
"    Всегда возвращает ошибку."

#: builtins.c:471
#, fuzzy
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Выполнение простой команды или вывод информации о командах.\n"
"    \n"
"    Выполняет команду с аргументами без поиска функции командного "
"процессора\n"
"    или выводит информацию об указанных командах.  Можно использовать для "
"вызова команд\n"
"    с диска, когда функция с таким именем уже существует.\n"
"    \n"
"    Параметры:\n"
"      -p\tиспользовать значение по умолчанию для $PATH, чтобы "
"гарантированно\n"
"    \tнайти все стандартные команды\n"
"      -v\tвывести описание команды аналогично встроенной команде «type»\n"
"      -V\tвывести более подробное описание каждой команды\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние выхода КОМАНДЫ или ошибку, если КОМАНДА не найдена."

#: builtins.c:490
#, fuzzy
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Указание значений переменных и атрибутов.\n"
"    \n"
"    Объявление переменных и назначение им атрибутов.  Если имена не "
"указаны,\n"
"    выводит атрибуты и значения всех переменных.\n"
"    \n"
"    Параметры:\n"
"      -f\tограничить действие или вывести имена функций и их определения\n"
"      -F\tвывести только имена функций (а также номер строки\n"
"    \tв исходном файле при отладке)\n"
"      -g\tсоздать глобальные переменные при использовании в функции "
"командного процессора; в противном случае\n"
"    \tигнорируется\n"
"      -p\tвывести атрибуты и значения каждого имени\n"
"    \n"
"    Параметры, задающие атрибуты:\n"
"      -a\tсделать имена индексированными массивами (если поддерживается)\n"
"      -A\tсделать имена ассоциативными массивами (если поддерживается)\n"
"      -i\tназначить именам атрибут «integer»\n"
"      -l\tперевести имена в нижний регистр при назначении\n"
"      -n\tсделать имя ссылкой на переменную с именем, соответствующим её "
"значению\n"
"      -r\tотключить запись в имена\n"
"      -t\tназначить именам атрибут «trace»\n"
"      -l\tперевести имена в верхний регистр при назначении\n"
"      -x\tэкспортировать имена\n"
"    \n"
"    Знак «+» вместо «-» отключает указанный атрибут.\n"
"    \n"
"    Переменные с атрибутом «integer» содержат математическое выражение (см.\n"
"    команду «let»), которое рассчитывается при назначении значения "
"переменной.\n"
"    \n"
"    При использовании в функции «declare» делает имена локальными как при "
"использовании\n"
"    данной команды.  Параметр «-g» отключает это поведение.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла\n"
"    ошибка присвоения."

#: builtins.c:532
#, fuzzy
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Указание значений переменных и атрибутов.\n"
"    \n"
"    Устарел.  См. «help declare»."

#: builtins.c:540
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Определение локальных переменных.\n"
"    \n"
"    Создаёт локальную переменную с указанным именем и присваивает ей "
"указанное значение.  Параметром может быть\n"
"    любой параметр, принимаемый командой «declare».\n"
"    \n"
"    Локальные переменные можно использовать только внутри функции. Они "
"видны\n"
"    только той функции, в которой они определены, и её дочерним функциям.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр, не возникла\n"
"    ошибка присвоения переменной или командный процессор не выполняет "
"функцию."

#: builtins.c:557
#, fuzzy
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by "
"a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value "
"HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal "
"value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Вывод аргументов на стандартный вывод.\n"
"    \n"
"    Выводит аргументы, разделённые пробелом, добавляя в конце символ новой "
"строки,\n"
"    на стандартный вывод.\n"
"    \n"
"    Параметры:\n"
"      -n\tне добавлять символ новой строки\n"
"      -e\tвключить интерпретацию символов, экранированных обратной косой "
"чертой\n"
"      -E\tявно отключить интерпретацию символов, экранированных обратной "
"косой чертой\n"
"    \n"
"    echo интерпретирует следующие символы, экранированные обратной косой "
"чертой:\n"
"      \\a\tоповещение (звуковой сигнал)\n"
"      \\b\tbackspace\n"
"      \\c\tотключение дальнейшего вывода\n"
"      \\e\tсимвол escape\n"
"      \\E\tсимвол escape\n"
"      \\f\tпрогон страницы\n"
"      \\n\tновая строка\n"
"      \\r\tвозврат каретки\n"
"      \\t\tгоризонтальная табуляция\n"
"      \\v\tвертикальная табуляция\n"
"      \\\\\tобратная косая черта\n"
"      \\0nnn\tсимвол с ASCII-кодом NNN (восьмеричным)  NNN может быть "
"длиной\n"
"    \tот 0 до 3 восьмеричных цифр\n"
"      \\xHH\tвосьмиразрядный символ, значение которого — HH "
"(шестнадцатеричное)  HH\n"
"    \tможет быть одной или двумя шестнадцатеричными цифрами\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если не произошла ошибка записи."

#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Вывод аргументов на стандартный вывод.\n"
"    \n"
"    Выводит аргументы на стандартный вывод, добавляя в конце символ новой "
"строки.\n"
"    \n"
"    Параметры:\n"
"      -n\tне добавлять символ новой строки\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если не произошла ошибка записи."

#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Включение и отключение встроенных команд командного процессора.\n"
"    \n"
"    Включает и отключает команды, встроенные в командный процессор.  "
"Отключение позволит\n"
"    выполнить команду с диска, название которой совпадает с названием "
"встроенной команды,\n"
"    без указания полного пути к ней.\n"
"    \n"
"    Параметры:\n"
"      -a\tпоказать список встроенных команд и их состояние\n"
"      -n\tотключить все указанные имена или вывести список отключённых "
"команд\n"
"      -p\tпоказать список встроенных команд\n"
"      -s\tпоказать только названия встроенных команд «special» Posix\n"
"    \n"
"    Параметры, управляющие динамической загрузкой:\n"
"      -f\tзагрузить встроенную указанную команду из указанного файла\n"
"      -d\tудалить встроенную функцию, загруженную с параметром -f\n"
"    \n"
"    Без указания параметров включаются все указанные команды.\n"
"    \n"
"    Чтобы использовать команду «test», найденную в переменной $PATH,\n"
"    а не встроенную в командный процессор, введите «enable -n test».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если указанное имя не является встроенной командой или "
"не произошла ошибка."

#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Выполнение аргументов как команды командного процессора.\n"
"    \n"
"    Объединяет аргументы в одну строку, результат передаётся\n"
"    в командный процессор с выполнением полученных команд.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние выхода команды или успех, если команда пустая."

#: builtins.c:652
#, fuzzy
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Анализ аргументов параметра.\n"
"    \n"
"    getopts используется процедурами командного процессора для анализа\n"
"    позиционных параметров.\n"
"    \n"
"    «строка_параметров» содержит буквы распознаваемых параметров. Если "
"после\n"
"    буквы идёт двоеточие, считается, что у параметра есть аргумент,\n"
"    который должен быть отделён пробелом.\n"
"    \n"
"    При каждом своём вызове getopts поместит следующий параметр в "
"переменную\n"
"    $имя, проинициализировав это имя, если оно не существует,\n"
"    и проиндексирует следующий обрабатываемый аргумент в переменной\n"
"    $OPTIND.  Переменная $OPTIND инициализируется при каждом вызове\n"
"    командного процессора или скрипта.  Когда для параметра нужен аргумент,\n"
"    getopts помещает этот аргумент в переменную $OPTARG.\n"
"    \n"
"    getopts сообщает об ошибках двумя способами.  Если первый символ\n"
"    в «строке_параметров» является двоеточием, getopts включает режим "
"молчания.  В этом\n"
"    режиме сообщения об ошибках не выводятся.  Если указан неверный\n"
"    параметр, getopts помещает символ параметра в переменную $OPTARG.  Если\n"
"    обязательный аргумент не найден, getopts помещает «:» в «имя»\n"
"    и задаёт для $OPTARG символ найденного параметра.  Если getopts не в "
"режиме\n"
"    молчания, и был указан неверный параметр, getopts помещает «?»\n"
"    в НАЗВАНИЕ и удаляет переменную OPTARG.  Если обязательный аргумент не "
"найден, в НАЗВАНИЕ\n"
"    помещается «?», переменная OPTARG удаляется и выводится диагностическое\n"
"    сообщение.\n"
"    \n"
"    Если переменная OPTERR имеет значение 0, getopts отключает\n"
"    вывод сообщений об ошибках, даже если первый символ переменной\n"
"    OPTSTRING не является двоеточием.  По умолчанию переменная OPTERR имеет "
"значение 1.\n"
"    \n"
"    Getopts обычно анализирует позиционные параметры ($0–$9), но если\n"
"    задано больше аргументов, анализируются последние.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если найден параметр. Возвращает ошибку, если "
"достигнут\n"
"    конец параметров или возникла ошибка."

#: builtins.c:694
#, fuzzy
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""
"Замена командного процессора указанной командой.\n"
"    \n"
"    Выполняет команду, заменяя текущий командный процессор указанной "
"программой.\n"
"    Указанные аргументы становятся аргументами для команды.  Если команда не "
"указана,\n"
"    все перенаправления будет выполняться в текущем командном процессоре.\n"
"    \n"
"    Параметры:\n"
"      -a имя\t\tпередать имя как нулевой аргумент в команду\n"
"      -c\t\tвыполнить команду с пустым окружением\n"
"      -l\t\tпоместить тире в нулевой аргумент для команды\n"
"    \n"
"    Если команду не удаётся выполнить, неинтерактивный командный процессор\n"
"    закроется (если только на задан «execfail»).\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если команда не была найдена или не возникла ошибка "
"перенаправления."

#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Выход из командного процессора.\n"
"    \n"
"    Закрывает командный процессор с состоянием N. Если N не указан,\n"
"    состоянием выхода будет состояние последней выполненной команды."

#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""
"Выход из командного процессора login.\n"
"    \n"
"    Закрывает командный процессор login с состоянием выхода N. Возвращает\n"
"    ошибку, если выполняется не в командном процессоре login."

#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""
"Отображение или выполнение команд из журнала.\n"
"    \n"
"    fc выводит список команд из журнала или позволяет изменить и повторно "
"выполнить их.\n"
"    Аргументы «первая» и «последняя» могут быть числами, определяющими "
"диапазон.\n"
"    Аргумент «первая» также может быть строкой, которая означает\n"
"    последнюю команду, начинающуюся с этой строки.\n"
"    \n"
"    Параметры:\n"
"      -e редактор\tуказать редактор  По умолчанию используется $FCEDIT, \n"
"    \t\tзатем следует $EDITOR, а затем — vi\n"
"      -l \tпоказать строки вместо редактирования\n"
"      -n\tне показывать номера строк в списке\n"
"      -r\tинвертировать порядок строк (новые в начале)\n"
"    \n"
"    При запуске в формате «fc -s [шаблон=замена ...] [команда]» команда\n"
"    выполняется повторно после замены старая=новая.\n"
"    \n"
"    Полезный псевдоним для команды — r='fc -s'. Так если ввести «r cc»,\n"
"    будет выполнена последняя команда, начинающаяся с «cc», а если ввести "
"«r»,\n"
"    будет выполнена последняя команда.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех или состояние выполненной команды. В случае ошибки "
"возвращает ненулевое состояние."

#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Перевод задания в интерактивный режим.\n"
"    \n"
"    Переводит указанное задание в интерактивный режим, делая\n"
"    его текущим заданием.  Если задание не указано, используется\n"
"    текущее задание.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние команды, переведённой в интерактивный режим, или "
"ошибку, если возникла ошибка."

#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Перевод заданий в фоновый режим.\n"
"    \n"
"    Переводит указанные задания в фоновый режим, как если бы\n"
"    они были запущены с «&».  Если задание не указано, используются данные\n"
"    текущего задания.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если не включено управление заданиями или не произошла "
"ошибка."

#: builtins.c:793
#, fuzzy
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Запоминание или отображение местоположений программ.\n"
"    \n"
"    Определяет и запоминает полный путь для всех указанных команд.  Если\n"
"    аргументы не указаны, выводит информацию о запомненных командах.\n"
"    \n"
"    Параметры:\n"
"      -d\t\tзабыть запомненные местоположения всех указанных команд\n"
"      -l\t\tотобразить данные в формате для повторного использования\n"
"      -p путь\t\tиспользовать указанный путь как полный путь к команде\n"
"      -r\t\tзабыть все запомненные местоположения\n"
"      -t\t\tвывести запомненные местоположение всех команд,\n"
"    \t\tуказав перед каждым из них соответствующее имя команды,\n"
"    \t\tесли указано несколько команд.\n"
"    Аргументы:\n"
"      ИМЯ\t\tвсе команды ищутся в $PATH и добавляются в список\n"
"    \t\tзапомненных команд.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если команда была найдена или был указан допустимый "
"параметр."

#: builtins.c:818
#, fuzzy
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""
"Вывод информации о встроенных командах.\n"
"    \n"
"    Показывает краткую справку о встроенных командах.  Если указан\n"
"    шаблон, выводит подробную справку по всем командам, удовлетворяющим "
"шаблону.\n"
"    В противном случае выводится список разделов справки.\n"
"    \n"
"    Параметры:\n"
"      -d\tпоказать краткое описание каждого раздела\n"
"      -m\tпоказать справку по использованию в формате man\n"
"      -s\tпоказать только краткую справку по использованию для каждого\n"
"    \tраздела, соответствующего шаблону\n"
"    \n"
"    Аргументы:\n"
"      ШАБЛОН\tшаблон, определяющий раздел справки\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был найден шаблон или был указан допустимый "
"параметр."

#: builtins.c:842
#, fuzzy
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Отображение или изменение журнала команд.\n"
"    \n"
"    Выводит журнал команд с номерами строк и звёздочками (*) перед всеми\n"
"    изменёнными записями.  С аргументом N показываются только последние N "
"записей.\n"
"    \n"
"    Параметры:\n"
"      -c\tочистить журнал, удалив из него все записи\n"
"      -d смещение\tудалить запись журнала по указанному смещению\n"
"    \n"
"      -a\tдобавить журнал текущего сеанса в файл журнала\n"
"      -n\tпрочитать все записи, которые ещё не были прочитаны из файла "
"журнала\n"
"      -r\tпрочитать файл журнала и добавить его содержимое\n"
"    \tв журнал\n"
"      -w\tзаписать текущий журнал в файл журнала\n"
"    \tи добавить записи в журнал\n"
"    \n"
"      -p\tдобавить в журнал указанные аргументы и показать результат,\n"
"    \tне сохраняя его в журнал\n"
"      -s\tдобавить аргументы в журнал как одну запись\n"
"    \n"
"    Если указан файл, он используется как файл журнала.  В противном случае\n"
"    если $HISTFILE содержит значение, используется этот файл, иначе — файл "
"~/.bash_history.\n"
"    \n"
"    Если переменная $HISTTIMEFORMAT задана и не является пустой, её "
"значение\n"
"    используется как строка форматирования для strftime(3) для вывода метки\n"
"    времени для каждой показанной записи журнала.  В противном случае метки "
"времени не будут показаны.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла "
"ошибка."

#: builtins.c:879
#, fuzzy
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Отображение состояния заданий.\n"
"    \n"
"    Выводит список активных заданий.  Если указан номер задания, выводится "
"только это задание.\n"
"    Если не указать параметры, будет показано состояние всех активных "
"заданий.\n"
"    \n"
"    Параметры:\n"
"      -l\tпоказать идентификаторы процессов в дополнение к обычной "
"информации\n"
"      -n\tпоказать только те процессы, у которых изменилось состояние\n"
"    \tс момента после последнего уведомления\n"
"      -p\tпоказать только идентификаторы процессов\n"
"      -r\tпоказать только запущенные задания\n"
"      -s\tпоказать только остановленные задания\n"
"    \n"
"    Если указан параметр -x, команда выполняется после замены всех номеров\n"
"    заданий, указанных в аргументах, на идентификатор процесса\n"
"    лидера группы процессов задания.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла "
"ошибка.\n"
"    Если указан параметр -x, возвращает состояние выхода команды."

#: builtins.c:906
#, fuzzy
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Удаление заданий в текущем командном процессоре.\n"
"    \n"
"    Удаляет все указанные задания из списка активных заданий.  Если\n"
"    задание не указано, удаляется текущее задание.\n"
"    \n"
"    Параметры:\n"
"      -a\tудалить все задания, если не указано конкретное задание\n"
"      -h\tпометить все задания, чтобы им не отправлялся сигнал SIGHUP,\n"
"    \tесли командный процессор получает сигнал SIGHUP\n"
"      -r\tудалить только активные задания\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или задание."

#: builtins.c:925
#, fuzzy
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Отправка сигнала заданию.\n"
"    \n"
"    Отправляет процессам или заданиям сигнал с указанным названием\n"
"    или номером. Если номер или название сигнала\n"
"    не указаны, отправляется сигнал SIGTERM.\n"
"    \n"
"    Параметры:\n"
"      -s сигнал\tназвание сигнала\n"
"      -n сигнал\tномер сигнала\n"
"      -l\t\tпоказывает названия сигналов; если после аргументов указано «-"
"l»,\n"
"    \tони считаются номерами сигналов, для которых необходимо показать "
"названия\n"
"    \n"
"    kill — это встроенная команда, предназначенная для двух задач: "
"использовать\n"
"    номера заданий вместо номеров процессов и убивать процессы\n"
"    при достижении предельного числа процессов.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла "
"ошибка."

#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Расчёт математических выражений.\n"
"    \n"
"    Выполняет расчёт всех аргументов в математическом выражении.  Расчёт "
"выполняется\n"
"    для целых чисел фиксированной ширины с без проверки на переполнение.\n"
"    Однако деление на 0 перехватывается и выдаётся ошибка.  Указанные ниже "
"операторы объединены\n"
"    в группы с одинаковым приоритетом.  Группы перечислены\n"
"    в порядке уменьшения приоритета.\n"
"    \n"
"    \tid++, id--\tпоследующее увеличение и уменьшение переменной\n"
"    \t++id, --id\tпредварительное увеличение и уменьшение переменной\n"
"    \t-, +\t\tунарный минус и плюс\n"
"    \t!, ~\t\tлогическое и побитовое отрицание\n"
"    \t**\t\tвозведение в степень\n"
"    \t*, /, %\t\tумножение, деление, остаток\n"
"    \t+, -\t\tсложение, вычитание\n"
"    \t<<, >>\t\tбитовые сдвиги влево или вправо\n"
"    \t<=, >=, <, >\tсравнение\n"
"    \t==, !=\t\tравенство, неравенство\n"
"    \t&\t\tпобитовое И\n"
"    \t^\t\tпобитовое исключающее ИЛИ\n"
"    \t|\t\tпобитовое ИЛИ\n"
"    \t&&\t\tлогическое И\n"
"    \t||\t\tлогические ИЛИ\n"
"    \tвыражение ? выражение : выражение\n"
"    \t\t\tусловный оператор\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tприсвоение\n"
"    \n"
"    в качестве операндов можно использовать переменные командного "
"процессора.  Название переменной\n"
"    заменяется её значением (приводится к целому числу фиксированной "
"ширины)\n"
"    в выражении.  У переменной не должен быть включён атрибут integer,\n"
"    чтобы её можно было использовать в выражении.\n"
"    \n"
"    Операторы вычисляются в порядке старшинства.  Вложенные выражения в\n"
"    скобках вычисляются первыми и могут переопределить указанные\n"
"    выше правила старшинства.\n"
"    \n"
"    Состояние выхода:\n"
"    Если последний АРГУМЕНТ имеет значение 0, let возвращает 1. В противном "
"случае let возвращает 0."

#: builtins.c:994
#, fuzzy
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters. By default, the backslash character escapes delimiter "
"characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, "
"unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out\n"
"    (in which case it's greater than 128), a variable assignment error "
"occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Чтение строки со стандартного ввода и разделение её на поля.\n"
"    \n"
"    Читает одну строку со стандартного ввода или из файлового дескриптора,\n"
"    если указан параметр -u.  Строка разделяется на поля по словам.\n"
"    Первое слово присваивается первому указанному имени, второе слово — "
"второму\n"
"    имени и так далее.\n"
"    Оставшиеся слова присваиваются последнему указанному имени.  В качестве "
"разделителей слов используются только символы\n"
"    из переменной $IFS.\n"
"    \n"
"    Если имена не указаны, прочитанная строка сохраняется в переменной "
"$REPLY.\n"
"    \n"
"    Параметры:\n"
"      -a массив\tпоследовательно присвоить прочитанные слова указателям\n"
"    \t\tмассива, начиная с нуля\n"
"      -d разделитель\tпродолжить до первого разделителя,\n"
"    \t\tа не до символа новой строки\n"
"      -e\t\tс помощью readline получить строку в интерактивном командном "
"процессоре\n"
"      -i текст\t\tиспользовать текст в качестве исходного для readline\n"
"      -n число_знаков\tвыполнить возврат после прочтения числа знаков, а не "
"ждать\n"
"    \t\tсимвола новой строки; учитывать разделитель, если до него было "
"прочитано\n"
"    \t\tменьше указанного числа знаков\n"
"      -N число_знаков\tвыполнить возврат только после прочтения указанного "
"числа знаков,\n"
"    \t\tесли только не был получен конец строки или не истекло время "
"ожидания, игнорируя все разделители\n"
"      -p приглашение\tпоказать приглашение без символа новой строки в конце\n"
"    \t\tперед тем как читать\n"
"      -r\t\tне выполнять экранирование символами косой черты\n"
"      -s\t\tне показывать данные, полученные из терминала\n"
"      -t тайм-аут\tпрекратить ожидание и вывести ошибку, если полная "
"входная\n"
"    \t\tстрока не была прочитана за указанное число секунд  В переменной "
"$TMOUT хранится\n"
"    \t\tзначение тайм-аута по умолчанию.  Время ожидания\n"
"    \t\tможет быть дробным числом.  Если тайм-аут равен 0, read немедленно "
"выполняет возврат,\n"
"    \t\tне пытаясь прочитать никакие данные. Успех возвращается,\n"
"    \t\tтолько если входные данные доступны по указанному файловому "
"дескриптору.   \n"
"    \t\tСостояние выхода больше 128, если время ожидания было превышено.\n"
"      -u fd\t\tчитать из файлового дескриптора, а не со стандартного входа\n"
"    \n"
"    Состояние выхода:\n"
"    Состояние выхода будет нулевым, если не был встречен конец файла, не "
"истекло время ожидания\n"
"    (в этом случае состояние выхода будет больше 128), не возникла ошибка "
"присвоения переменной\n"
"    или не был указан недопустимый файловый дескриптор как аргумент для -u."

#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Возврат из функции командного процессора.\n"
"    \n"
"    Выполняет выход из функции или исходного скрипта со значением возврата,\n"
"    указанным как N. Если N не указан, используется состояние возврата\n"
"    последней команды, выполненной в функции или скрипте.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает N или ошибку, если командный процессор не выполняет функцию "
"или скрипт."

#: builtins.c:1055
#, fuzzy
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell "
"functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Присвоение или удаление значений параметров командного процессора и "
"позиционных параметров.\n"
"    \n"
"    Изменяет значение атрибутов командного процессора и позиционных "
"параметров или\n"
"    выводит названия и значения переменных командного процессора.\n"
"    \n"
"    Параметры:\n"
"      -a  пометить переменные, которые были изменены или созданы для "
"экспорта\n"
"      -b  немедленно уведомить о завершении задания\n"
"      -e  немедленно выйти, если команда выполняет выход с ненулевым "
"состоянием\n"
"      -f  отключить генерацию имён файлов (подстановка)\n"
"      -h  запомнить расположение команд, как они выглядели ранее\n"
"      -k  поместить в окружение для команды все аргументы присвоения,\n"
"          а не только те, что были указаны перед командой\n"
"      -m  включено управление заданиями\n"
"      -n  прочитать команды, но не выполнять их\n"
"      -o название-параметра\n"
"          Задаёт переменную, соответствующую названию параметра:\n"
"              allexport    эквивалент -a\n"
"              braceexpand  эквивалент -B\n"
"              emacs        использовать стиль emacs для редактирования "
"строк\n"
"              errexit      эквивалент -e\n"
"              errtrace     эквивалент -E\n"
"              functrace    эквивалент -T\n"
"              hashall      эквивалент -h\n"
"              histexpand   эквивалент -H\n"
"              history      включить журнал команд\n"
"              ignoreeof    не закрывать командный процессор после получения "
"конца файла\n"
"              interactive-comments\n"
"                           разрешить показ комментариев в интерактивных "
"командах\n"
"              keyword      эквивалент -k\n"
"              monitor      эквивалент -m\n"
"              noclobber    эквивалент -C\n"
"              noexec       эквивалент -n\n"
"              noglob       эквивалент -f\n"
"              nolog        допускается, но игнорируется\n"
"              notify       эквивалент -b\n"
"              nounset      эквивалент -u\n"
"              onecmd       эквивалент -t\n"
"              physical     эквивалент -P\n"
"              pipefail     возвращаемое значение конвейера является "
"состоянием\n"
"                           последней команды, завершившейся с ненулевым "
"состоянием,\n"
"                           или нулём, если не было команды, завершившейся с "
"ненулевым состоянием\n"
"              posix        изменить поведение bash там, где операции\n"
"                           по умолчанию отличаются от стандарта Posix, "
"чтобы\n"
"                           соответствовать этому стандарту\n"
"              privileged   эквивалент -p\n"
"              verbose      эквивалент -v\n"
"              vi           использовать стиль vi для редактирования строк\n"
"              xtrace       эквивалент -x\n"
"      -p  Включён, когда реальный и эффективный идентификаторы пользователя "
"не совпадают.\n"
"          Отключает обработку файла $ENV и импорт функций командного\n"
"          процессора.  Если отключить этот параметр, эффективные UID и GID\n"
"          будут назначены реальным UID и GID.\n"
"      -t  Выйти после прочтения и выполнения одной команды.\n"
"      -u  Считать незаданные переменные ошибкой при замене.\n"
"      -v  Выводить входные строки на экран после их чтения.\n"
"      -x  Выводить команды и их аргументы во время их выполнения.\n"
"      -B  Командный процессор развернёт скобки.\n"
"      -C  Если задано, запретить перезапись существующих обычных файлов\n"
"          вследствие перенаправления вывода.\n"
"      -E  Если задано, ловушка ERR наследуется функциями командного "
"процессора.\n"
"      -H  Включить замену журнала с использованием !.  По умолчанию этот "
"флаг\n"
"          установлен, если командный процессор интерактивный.\n"
"      -P  Если задано, не разрешать символьные ссылки при выполнении "
"команд,\n"
"          таких как cd, которые изменяют текущий каталог.\n"
"      -T  Если задано, ловушка DEBUG наследуется функциями командного "
"процессора.\n"
"      --  Назначить все оставшиеся аргументы позиционным параметрам.\n"
"          Если аргументов не осталось, позиционные параметры\n"
"          удаляются.\n"
"      -   Назначить все оставшиеся аргументы позиционным параметрам.\n"
"          Параметры -x и -v выключены.\n"
"    \n"
"    Если вместо - указать +, флаги будут выключены.   \n"
"    Флаги также можно использовать до вызова командного процессора.  "
"Текущий\n"
"    набор флагов можно просмотреть в $-.  Оставшиеся n аргументов являются "
"позиционными\n"
"    параметрами и назначаются в порядке $1, $2, .. $n.  Если\n"
"    аргументы не указаны, выводятся все переменные командного процессора.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр."

#: builtins.c:1140
#, fuzzy
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Удаление значений и атрибутов переменных и функций командного процессора.\n"
"    \n"
"    Для каждого названия удаляет соответствующую переменную или функцию.\n"
"    \n"
"    Параметры:\n"
"      -f\tсчитать каждое указанное имя функцией командного процессора\n"
"      -v\tсчитать каждое указанное имя переменной командного процессора\n"
"      -n\tсчитать каждое указанное имя ссылкой на название и удалить саму "
"переменную,\n"
"    \tа не переменную, на которую указывает ссылка\n"
"    \n"
"    Если параметры не указаны, unset сначала пытается удалить переменную. "
"Если это не удаётся,\n"
"    пытается удалить функцию.\n"
"    \n"
"    Некоторые переменные нельзя удалить. См. также «readonly».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или указанное имя "
"доступно для записи."

#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Установка атрибута экспорта для переменных командного процессора.\n"
"    \n"
"    Помечает все имена для автоматического экспорта в среду для\n"
"    последующих выполняемых команд.  Если указано значение, оно "
"присваивается перед экспортом.\n"
"    \n"
"    Параметры:\n"
"      -f\tиспользовать функции командного процессора\n"
"      -n\tудалить свойство экспорта изо всех имён\n"
"      -p\tвывести список всех экспортированных переменных и функций\n"
"    \n"
"    Аргумент «--» отключает дальнейшую обработку параметров.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или имя."

#: builtins.c:1181
#, fuzzy
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Запрет изменения переменных командного процессора.\n"
"    \n"
"    Делает каждое имя доступным только чтения. Значения этих имён нельзя\n"
"    будет изменить в будущем.  Если указано значение, присваивает это "
"значение\n"
"    перед тем, как сделать его доступным только для чтения.\n"
"    \n"
"    Параметры:\n"
"      -a\tссылаться на переменные индексированного массива\n"
"      -A\tссылаться на переменные ассоциативного массива\n"
"      -f\tиспользовать функции командного процессора\n"
"      -p\tвывести список всех переменных или функций, доступных только для "
"чтения,\n"
"            в зависимости от того, указан ли параметр -f\n"
"    \n"
"    Аргумент «--» отключает дальнейшую обработку параметров.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или имя."

#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Сдвиг позиционных параметров.\n"
"    \n"
"    Переименовывает позиционные параметры $N+1,$N+2,.. в $1,$2,..\n"
"    Если N не указан, считается, что указано 1.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если N положительный или меньше $#."

#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Выполнение команд из файла в текущем командном процессоре.\n"
"    \n"
"    Читает и выполняет команды из указанного файла в текущем командном "
"процессоре.   \n"
"    Файла ищется в каталогах, указанных в переменной $PATH.\n"
"    Если указаны аргументы, они становятся позиционными параметрами\n"
"    при выполнении файла.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды из файла. Возвращает "
"ошибку,\n"
"    если файл не удаётся прочитать."

#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Приостановка работы командного процессора.\n"
"    \n"
"    Приостанавливает работу текущего командного процессора до получения "
"сигнала SIGCONT.\n"
"    Работу командных процессоров login можно приостановить только в "
"принудительном режиме.\n"
"    \n"
"    Параметры:\n"
"      -f\tпринудительно приостановить работу, даже если командный "
"процессор — login\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если не включено управление заданиями или не произошла "
"ошибка."

#: builtins.c:1262
#, fuzzy
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Расчёт условного выражения.\n"
"    \n"
"    Возвращает состояние 0 (истина) или 1 (ложь) после\n"
"    расчёта выражения.  Выражения могут быть унарными или бинарными.  "
"Унарные\n"
"    выражения часто используются для определения состояния файла.  Также\n"
"    доступны стоковые операторы и операторы сравнения чисел.\n"
"    \n"
"    Поведение команды test зависит от количества аргументов.  Полное\n"
"    описание см. в странице руководства bash.\n"
"    \n"
"    Операторы работы с файлами:\n"
"    \n"
"      -a ФАЙЛ        Истина, если файл существует.\n"
"      -b ФАЙЛ        Истина, если файл представляет блочное устройство.\n"
"      -c ФАЙЛ        Истина, если файл представляет символьное устройство.\n"
"      -d ФАЙЛ        Истина, если файл является каталогом.\n"
"      -e ФАЙЛ        Истина, если файл существует.\n"
"      -f ФАЙЛ        Истина, если файл существует и является обычным "
"файлом.\n"
"      -g ФАЙЛ        Истина, если для файла установлен бит SGID.\n"
"      -h ФАЙЛ        Истина, если файл является символьной ссылкой.\n"
"      -L ФАЙЛ        Истина, если файл является символьной ссылкой.\n"
"      -k ФАЙЛ        Истина, если для файла установлен sticky-бит.\n"
"      -p ФАЙЛ        Истина, если файл является именованным конвейером.\n"
"      -r ФАЙЛ        Истина, если вы можете прочитать файл.\n"
"      -s ФАЙЛ        Истина, если файл существует и не является пустым.\n"
"      -S ФАЙЛ        Истина, если файл является сокетом.\n"
"      -t ФД          Истина, если файловый дескриптор ФД открыт в "
"терминале.\n"
"      -u ФАЙЛ        Истина, если для файла установлен бит SUID.\n"
"      -w ФАЙЛ        Истина, если вы можете выполнить запись в файл.\n"
"      -x ФАЙЛ        Истина, если вы можете выполнить файл.\n"
"      -O ФАЙЛ        Истина, если вы являетесь эффективным владельцем "
"файла.\n"
"      -G ФАЙЛ        Истина, если ваша группа является эффективным "
"владельцем файла.\n"
"      -N ФАЙЛ        Истина, если файл был изменён после последнего чтения.\n"
"    \n"
"      ФАЙЛ1 -nt ФАЙЛ2  Истина, если файл1 новее файла2 (согласно\n"
"                       дате изменения).\n"
"    \n"
"      ФАЙЛ1 -ot ФАЙЛ2  Истина, если файл1 старее файла2.\n"
"    \n"
"      ФАЙЛ1 -ef ФАЙЛ2  Истина, если файл1 является жёсткой ссылкой на "
"файл2.\n"
"    \n"
"    Строковые операторы:\n"
"    \n"
"      -z СТРОКА      Истина, если строка является пустой.\n"
"    \n"
"      -n СТРОКА\n"
"         СТРОКА      Истина, если строка не является пустой.\n"
"    \n"
"      СТРОКА1 = СТРОКА2\n"
"                     Истина, если строки совпадают.\n"
"      СТРОКА1 != СТРОКА2\n"
"                     Истина, если строки не совпадают.\n"
"      СТРОКА1 < СТРОКА2\n"
"                     Истина, если СТРОКА1 сортируется до СТРОКИ2 "
"лексикографически.\n"
"      СТРОКА1 > СТРОКА2\n"
"                     Истина, если СТРОКА1 сортируется после СТРОКИ2 "
"лексикографически.\n"
"    \n"
"    Остальные операторы:\n"
"    \n"
"      -o ПАРАМЕТР    Истина, если параметр командного процессора включён.\n"
"      -v ПЕР\t Истина, если переменная командного процессора задана\n"
"      -R ПЕР\t Истина, если переменная командного процессора задана и "
"является именованной ссылкой.\n"
"      ! ВЫРАЖ        Истина, если выражение возвращает ложь.\n"
"      ВЫРАЖ1 -a ВЫРАЖ2 Истина, если оба выражения возвращают истину.\n"
"      ВЫРАЖ1 -o ВЫРАЖ2 Истина, если хотя бы одно из выражений возвращает "
"истину.\n"
"    \n"
"      арг1 ОП арг2   Математические проверки.  ОП может быть одним из "
"следующих: -eq, -ne,\n"
"                     -lt, -le, -gt или -ge.\n"
"    \n"
"    Математические бинарные операторы возвращают истину, если АРГУМЕНТ1 "
"равен, не равен,\n"
"    меньше, меньше или равен либо больше или равен\n"
"    АРГУМЕНТУ2.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если выражение истинно, или ошибку, если выражение "
"ложно\n"
"    или указан недопустимый аргумент."

#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Расчёт условного выражения.\n"
"    \n"
"    Это синоним встроенной команды test, но последним аргументом должна\n"
"    быть скобка «]», соответствующая открывающей «[»."

#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Отображение времени процесса.\n"
"    \n"
"    Показывает объединённые значения времени пользователя и системы для "
"командного\n"
"    процессора и всех его дочерних процессов.\n"
"    \n"
"    Состояние выхода:\n"
"    Всегда возвращает успех."

#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  "
"If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or "
"a\n"
"    script run by the . or source builtins finishes executing.  A "
"SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause "
"the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""
"Захват сигналов и других событий.\n"
"    \n"
"    Определяет и активирует обработчики, которые будут выполняться, когда\n"
"    командный процессор получает сигналы или при других условиях.\n"
"    \n"
"    Аргумент — это команда, которая считывается и выполняется, когда\n"
"    командный процессор получает указанные сигнал(ы).  Если аргумент "
"отсутствует (и указан один сигнал)\n"
"    или указано «-», для всех указанных сигналов восстанавливаются\n"
"    исходные значения.  Если аргумент — пустая строка, все указанные сигналы "
"игнорируются\n"
"    командным процессором и вызываемыми им командами.\n"
"    \n"
"    Если сигнал — EXIT (0), аргумент выполняется при выходе из командного "
"процессора.  Если\n"
"    сигнал — DEBUG, аргумент выполняется перед каждой простой командой.  "
"Если\n"
"    сигнал — RETURN, аргумент выполняется каждый раз, когда функция\n"
"    или скрипт выполняется в . или исходные встроенные команды завершают "
"свою работу.  Сигнал\n"
"    ERR означает выполнение аргумента каждый раз, когда ошибка команды "
"приведёт\n"
"    к выходу из командного процессора, когда включён параметр -e.\n"
"    \n"
"    Если аргументы не указаны, trap выводит список команд, связанных\n"
"    с каждом сигналом.\n"
"    \n"
"    Параметры:\n"
"      -l\tпоказать названия сигналов и их номера\n"
"      -p\tпоказать команды trap, связанные с каждым сигналом\n"
"    \n"
"    Идентификатор сигнала — это название сигнала в <signal.h> или номер "
"сигнала.\n"
"    Названия сигналов не зависят от регистра, а префикс SIG не является "
"обязательным.   \n"
"    Сигнал можно отправить в командный процессор командой «kill -signal $"
"$».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый сигнал или параметр."

#: builtins.c:1401
#, fuzzy
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""
"Вывод информации о типе команды.\n"
"    \n"
"    Для каждого указанного имени показывает, как оно будет интерпретировано "
"при\n"
"    использовании в качестве названия команды.\n"
"    \n"
"    Параметры:\n"
"      -a\tпоказать все местоположения, где есть исполняемый файл с указанным "
"именем,\n"
"    \tвключая псевдонимы, встроенные команды и функции, а также при условии\n"
"    \tчто не используется параметр «-p»\n"
"      -f\tне искать функции командного процессора\n"
"      -P\tпринудительно искать в $PATH все указанные имена, даже если это "
"псевдоним,\n"
"    \tвстроенная команда или функция, и возвращать название файла на диске,\n"
"    \tкоторый будет запущен\n"
"      -p\tвозвращает название файла на диске, который будет запущен,\n"
"    \tили ничего, если «type -t имя» не возвращает «file».\n"
"      -t\tвывести одно из слов «alias», «keyword»,\n"
"    \t«function», «builtin», «file» или «», если указанное имя является, "
"соответственно,\n"
"    \tпсевдонимом, зарезервированным словом, функцией, встроенной командой\n"
"    \tкомандного процессора, файлом на диске или имя не было найдено\n"
"    \n"
"    Аргументы:\n"
"      ИМЯ\tназвание интерпретируемой команды\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если все указанные имена были найдены, или ошибку в "
"противном случае."

#: builtins.c:1432
#, fuzzy
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Изменение ограничений ресурсов командного процессора.\n"
"    \n"
"    Позволяет контролировать ресурсы, доступные командному процессору и "
"создаваемым\n"
"    им  процессам, в системах, где возможен такой контроль.\n"
"    \n"
"    Параметры:\n"
"      -S\tиспользовать «мягкое» ограничение ресурсов\n"
"      -H\tиспользовать «жёсткое» ограничение ресурсов\n"
"      -a\tпоказать все текущие ограничения\n"
"      -b\tразмер буфера сокета\n"
"      -c\tмаксимальный размер создаваемых core-файлов\n"
"      -d\tмаксимальный размер сегмента данных процесса\n"
"      -e\tмаксимальный приоритет планирования («nice»)\n"
"      -f\tмаксимальный размер файлов, записываемых командным процессором и "
"его дочерними процессами\n"
"      -i\tмаксимальное число ожидающих сигналов\n"
"      -l\tмаксимальный объём, который процесс может заблокировать в памяти\n"
"      -m\tмаксимальный объём резидентной памяти\n"
"      -n\tмаксимальное число открытых файловых дескрипторов\n"
"      -p\tразмер буфера конвейера\n"
"      -q\tмаксимальное число байт в очередях сообщений POSIX\n"
"      -r\tмаксимальный приоритет планирования в реальном времени\n"
"      -s\tмаксимальный размер стека\n"
"      -t\tмаксимальный объём процессорного времени в секундах\n"
"      -u\tмаксимальное количество пользовательских процессов\n"
"      -v\tобъём виртуальной памяти\n"
"      -x\tмаксимальное число блокировок файлов\n"
"      -T    максимальное количество потоков\n"
"    \n"
"    Не все параметры доступны на всех платформах.\n"
"    \n"
"    Если указано ограничение, оно является новым значением для указанного "
"ресурса.\n"
"    Специальные значения «soft», «hard» и «unlimited» означают,\n"
"    соответственно, текущее мягкое ограничение, текущее жёсткое ограничение "
"и отсутствие ограничения.\n"
"    В противном случае выводится текущее значение указанного ресурса.  Если\n"
"    параметр не указан, подразумевается использование параметра -f.\n"
"    \n"
"    Значения задаются с шагом 1024 байт, кроме параметра -t с шагом в "
"секундах,\n"
"    параметра -p с шагом 512 байт и параметра -u, представляющего\n"
"    количество процессов.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла "
"ошибка."

#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Отображение или указание маски режима для файлов.\n"
"    \n"
"    Задаёт маску РЕЖИМ для файлов, создаваемых пользователем.  Если РЕЖИМ не "
"указан,\n"
"    выводит текущее значение маски.\n"
"    \n"
"    Если РЕЖИМ начинается с цифры, он интерпретируется как восьмеричное "
"число.\n"
"    В противном случае он считается символьной строкой как для команды "
"chmod(1).\n"
"    \n"
"    Параметры:\n"
"      -p\tесли РЕЖИМ не указан, вывести маску, пригодную для повторного "
"использования\n"
"      -S\tвывести маску в символьном виде, в противном случае выводится "
"восьмеричное число\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый РЕЖИМ или параметр."

#: builtins.c:1503
#, fuzzy
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or "
"a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of "
"IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns "
"its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, "
"before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Ожидание завершения задания и возврат состояния выхода.\n"
"    \n"
"    Ожидает завершения всех процессов, заданных идентификаторами\n"
"    (идентификатор процесса или номер задания), и возвращает их состояние "
"выхода.  Если идентификатор\n"
"    не указан, ожидает завершения всех активных дочерних процессов\n"
"    и возвращает нулевое состояние выхода.  Если идентификатор не является "
"номером задания, ожидает завершения\n"
"    всех процессов в конвейере данного задания.\n"
"    \n"
"    Если указан параметр -n, ожидает завершения следующего задания\n"
"    возвращает его состояние выхода.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последнего идентификатора. Возвращает ошибку, если\n"
"    указан недопустимый идентификатор или параметр."

#: builtins.c:1534
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination "
"status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an "
"invalid\n"
"    option is given."
msgstr ""
"Ожидание завершения процесса и возврат состояния выхода.\n"
"    \n"
"    Ожидает завершения всех процессов, заданных идентификаторами (PID), и "
"возвращает их состояние выхода.\n"
"    Если идентификатор процесса не указан, ожидает завершения всех активных\n"
"    дочерних процессов и возвращает нулевое состояние выхода.  PID должен "
"быть идентификатором процесса.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последнего идентификатора. Возвращает ошибку, если\n"
"    указан недопустимый идентификатор или параметр."

#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выполнение команд для всех элементов списка.\n"
"    \n"
"    Цикл «for» выполняет последовательность команд для каждого элемента\n"
"    списка.  Если операнд «in СЛОВА ...;» отсутствует, подразумевается\n"
"    операнд «in \"$@\"».  Каждому элементу в списке СЛОВА присваивается ИМЯ "
"и для него\n"
"    выполняются КОМАНДЫ.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Математические операции в циклах.\n"
"    \n"
"    Эквивалентно\n"
"    \t(( ВЫРАЖ1))\n"
"    \twhile (( ВЫРАЖ2 )); do\n"
"    \t\tКОМАНДЫ\n"
"    \t\t(( ВЫРАЖ3 ))\n"
"    \tdone\n"
"    ВЫРАЖ1, ВЫРАЖ2 и ВЫРАЖ3 — это математические выражения.  Если любое из "
"выражений\n"
"    не указано, считается, что оно возвращает 1.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выбор слов из списка и выполнение команд.\n"
"    \n"
"    СЛОВА разворачиваются, формируя список слов.   \n"
"    Набор развёрнутых слов выводится в поток ошибок с номерами\n"
"    в начале строк.  Если операнд «in СЛОВА ...;» отсутствует, "
"подразумевается\n"
"    операнд «in \"$@\"».  Затем выводится приглашение $PS3 и со стандартного "
"ввода\n"
"    считывается строка.  Если строка состоит из номера,\n"
"    соответствующего одному из показанных слов, этому слову\n"
"    присваивается указанное имя.  Если строка пустая, будут повторно "
"показаны указанные слова\n"
"    и приглашение.  Если прочитан символ конца файла, команда завершает свою "
"работу.  Если прочитаны\n"
"    любые другие значения, указанному имени присваивается пустое значение.  "
"Прочитанная строка\n"
"    сохраняется в переменную $REPLY.  Команды выполняются после каждой "
"выборки,\n"
"    пока не будет выполнена команда прерывания.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Вывод времени, потраченного на выполнение конвейера.\n"
"    \n"
"    Выполняет конвейер и выводит значения реального времени, "
"пользовательского времени\n"
"    и системного времени ЦП, потраченного на выполнения конвейера.\n"
"    \n"
"    Параметры:\n"
"      -p\tпоказать значения времени в формате Posix\n"
"    \n"
"    Для форматирования выходных данных используется значение переменной "
"$TIMEFORMAT.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращаемое состояние соответствует состоянию выхода конвейера."

#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выполнение команд согласно шаблону.\n"
"    \n"
"    Выполняет команды, когда слово соответствует шаблону.   \n"
"    Для разделения шаблонов используется знак «|».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выполнение команд в зависимости от условий.\n"
"    \n"
"    Сначала выполняется список «if КОМАНДЫ».  Если состояние выхода "
"нулевое,\n"
"    выполняется список «then КОМАНДЫ».  В противном случае выполняется по "
"очереди\n"
"    все списки «elif КОМАНДЫ», и если их состояние выхода будет нулевым,\n"
"    выполнится список «then КОМАНДЫ», и команда if завершится.  В противном "
"случае\n"
"    выполнится список «else КОМАНДЫ», если он указан.  Состояние выхода "
"всей\n"
"    конструкции соответствует состоянию выхода последней выполненной команды "
"или будет нулевым,\n"
"    если ни одна проверка условия не возвратила истину.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1648
#, fuzzy
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выполнение команд до тех пор, пока проверка условия возвращает истину.\n"
"    \n"
"    Разворачивает и выполняет команды до тех пор, пока последняя команда в\n"
"    командах «while» завершается с нулевым состоянием.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1660
#, fuzzy
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выполнение команд до тех пор, пока проверка условия не возвращает истину.\n"
"    \n"
"    Разворачивает и выполняет команды до тех пор, пока последняя команда в\n"
"    командах «until» завершается с ненулевым состоянием.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1672
#, fuzzy
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Создание дополнительного процесса с указанным именем.\n"
"    \n"
"    Выполняет команду асинхронно, когда стандартный вывод и стандартный\n"
"    вход команды подключены через конвейер к дескрипторам файлов, которые "
"назначены\n"
"    указателям 0 и 1 массива переменных ИМЯ в активном командном "
"процессоре.\n"
"    Имя по умолчанию — «COPROC».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние выхода команды."

#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Определение функции командного процессора.\n"
"    \n"
"    Создаёт функцию командного процессора с указанным именем.  При запуске в "
"качестве простой команды\n"
"    ИМЯ выполняет КОМАНДЫ в контексте вызывающего их командного процессора.  "
"При вызове ИМЕНИ\n"
"    аргументы передаются в функцию как $1...$n, а функция получает\n"
"    название $FUNCNAME.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если переменная ИМЯ доступно для записи."

#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Группировка команд.\n"
"    \n"
"    Выполняет набор команд, объединённых в группу.  Это единственный способ "
"перенаправления\n"
"    всего набора команд.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Возобновление работы задания в интерактивном режиме.\n"
"    \n"
"    Аналогично аргументу JOB_SPEC для команды «fg».  Возобновляет\n"
"    работу остановленного или фонового задания.  Через JOB_SPEC можно задать "
"название\n"
"    или номер задания.  Если после номера задания указать «&», задание будет "
"переведено\n"
"    в фоновый режим, как если бы идентификатор задания был указан как\n"
"    аргумент для команды «bg».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние возобновлённого задания."

#: builtins.c:1727
#, fuzzy
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Расчёт арифметического выражения.\n"
"    \n"
"    Выражение рассчитывается по правилам для математических\n"
"    выражений.  Аналогично «let выражение».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 1, если выражение равно 0, в противном случае возвращает 0."

#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Выполнение условной команды.\n"
"    \n"
"    Возвращает состояние 0 или 1 в зависимости от результата расчёта\n"
"    условного выражения.  Выражения составляются из тех же примитивов, "
"которые используются\n"
"    во встроенной команде «test». Их можно объединить с помощью следующих "
"операторов:\n"
"    \n"
"      ( выражение )\tВозвращает значение выражения\n"
"      ! выражение\tВозвращает истину, если выражение ложно, в противном "
"случае возвращает ложь\n"
"      ВЫРАЖ1 && ВЫРАЖ2\tВозвращает истину, если оба выражения истинны, в "
"противном случае возвращает ложь\n"
"      ВЫРАЖ1 || ВЫРАЖ2\tВозвращает истину, если хотя бы одно из выражений "
"истинно, в противном случае возвращает ложь\n"
"    \n"
"    Если используются операторы «==» и «!=», строка справа от\n"
"    оператора используется как шаблон, и выполняется сопоставление по "
"шаблону.\n"
"    Если используется оператор «=~», строка справа от оператора\n"
"    оценивается как регулярное выражение.\n"
"    \n"
"    Операторы && и || не рассчитывают ВЫРАЖ2, если ВЫРАЖ1 достаточно для\n"
"    определения значения выражения.\n"
"    \n"
"    Состояние выхода:\n"
"    0 или 1 в зависимости от значения выражения."

#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Стандартные имена переменных командного процессора и их использование.\n"
"    \n"
"    BASH_VERSION\tНомер версии bash.\n"
"    CDPATH\t\tСписок каталогов, разделённых двоеточиями, для поиска\n"
"    \t\tв них каталогов, указанных как аргументы для «cd».\n"
"    GLOBIGNORE\tСписок шаблонов, разделённых двоеточиями и описывающих имена "
"файлов,\n"
"    \t\tкоторые будут игнорироваться при развёртывании пути.\n"
"    HISTFILE\t\tИмя файла, в котором хранится журнал команд.\n"
"    HISTFILESIZE\tЧисло строк в файле журнала.\n"
"    HISTSIZE\t\tЧисло строк журнала, к которым может\n"
"    \t\tполучить доступ командный процессор.\n"
"    HOME\t\tПолный путь к вашему домашнему каталогу.\n"
"    HOSTNAME\t\tИмя данной системы.\n"
"    HOSTTYPE\t\tТип процессора, на котором работает данная версия bash.\n"
"    IGNOREEOF\tУправляет действием командного процессора при получении "
"символа\n"
"    \t\tсимвола конца файла в качестве единственных входных данных.  Если "
"задано, тогда значение\n"
"    \t\tявляется числом символов EOF, которые могут быть\n"
"    \t\tпрочитаны подряд в пустой строке, после чего командный процессор "
"будет закрыт\n"
"    \t\t(по умолчанию — 10).  Если не задано, EOF означает конец входных "
"данных.\n"
"    MACHTYPE\t\tСтрока с описанием текущей системы, в которой запущен bash.\n"
"    MAILCHECK\tКак часто (в секундах) bash проверяет наличие новой почты.\n"
"    MAILPATH\t\tСписок имён файлов, разделённых двоеточиями, в которых bash\n"
"    \t\tищет почту.\n"
"    OSTYPE\t\tВерсия Unix, в которой запущена данная версия bash.\n"
"    PATH\t\tСписок каталогов, разделённых двоеточиями, для поиска\n"
"    \t\tвыполняемых команд.\n"
"    PROMPT_COMMAND\tКоманда, выполняемая перед выводом каждого\n"
"    \t\tосновного приглашения.\n"
"    PS1\t\tОсновная строка приглашения.\n"
"    PS2\t\tДополнительная строка приглашения.\n"
"    PWD\t\tПолный путь до текущего каталога.\n"
"    SHELLOPTS\tСписок включённых параметров командного процессора, "
"разделённых двоеточиями.\n"
"    TERM\t\tНазвание текущего типа терминала.\n"
"    TIMEFORMAT\tФормат вывода данных о времени, показываемых\n"
"    \t\tкомандой time.\n"
"    auto_resume\tНепустое значение означает слово в строке запуска команды,\n"
"    \t\tкоторое сначала ищется в списке\n"
"    \t\tостановленных заданий.  Если команда найдена, задание переводится в "
"интерактивный режим.\n"
"    \t\tЗначение «exact» означает, что слово команды должно\n"
"    \t\tточно совпадать с командой в списке остановленных заданий.   \n"
"    \t\tЗначение «substring» означает, что слово команды\n"
"    \t\tдолжно быть частью строки задания.  Все другие значения означают,\n"
"    \t\tчто команда должна быть префиксом остановленного задания.\n"
"    histchars\tСимволы, управляющие расширением журнала\n"
"    \t\tи быстрой подстановкой.  Первый символ означает\n"
"    \t\tподстановку журнала. Обычно это «!».  Второй символ\n"
"    \t\tозначает «быструю подстановку». Обычно это «^».   \n"
"    \t\tТретий символ означает примечание журнала. Обычно это «#».\n"
"    HISTIGNORE\tСписок шаблонов, разделённых двоеточиями и описывающих "
"команды,\n"
"    \t\tкоторые должны быть сохранены в журнале.\n"

#: builtins.c:1822
#, fuzzy
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Добавление каталогов в стек.\n"
"    \n"
"    Добавляет каталог в начало стека каталогов или выполняет\n"
"    ротацию стека, помещая в начало стека текущий рабочий\n"
"    каталог.  Если аргументы не указаны, меняет местами два первых "
"каталога.\n"
"    \n"
"    Параметры:\n"
"      -n\tпредотвращает обычное изменение каталога при добавлении\n"
"    \tкаталогов в стек, чтобы действия выполнялись только над стеком.\n"
"    \n"
"    Аргументы:\n"
"      +N\tвыполняет ротацию стека, чтобы N-й каталог (слева\n"
"    \tв списке, показанного командой «dirs», начиная с нуля)\n"
"    \tстал первым в стеке.\n"
"    \n"
"      -N\tвыполняет ротацию стека, чтобы N-й каталог (справа\n"
"    \tв списке, показанного командой «dirs», начиная с нуля)\n"
"    \tстал первым в стеке.\n"
"    \n"
"      каталог\tдобавляет каталог в начало стека каталогов, делая его\n"
"    \tновым текущим каталогом.\n"
"    \n"
"    Встроенная команда dirs показывает стек каталогов.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или удалось\n"
"    перейти в каталог."

#: builtins.c:1856
#, fuzzy
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Удаление каталогов из стека.\n"
"    \n"
"    Удаляет записи из стека каталогов.  Если аргументы не указаны,\n"
"    удаляет первый каталог из стека и назначает новый первый каталог.\n"
"    \n"
"    Параметры:\n"
"      -n\tпредотвращает обычное изменение каталога при удалении\n"
"    \tкаталогов из стека, чтобы действия выполнялись только над стеком.\n"
"    \n"
"    Аргументы:\n"
"      +N\tудаляет N-ю слева запись в списке каталогов,\n"
"    \tпоказанного командой «dirs», начиная с нуля.  Например, «popd +0»\n"
"    \tудаляет первый каталог, а «popd +1» — второй каталог.\n"
"    \n"
"      -N\tудаляет N-ю справа запись в списке каталогов,\n"
"    \tпоказанного командой «dirs», начиная с нуля.  Например, «popd -0»\n"
"    \tудаляет последний каталог, а «popd -1» — предпоследний каталог.\n"
"    \n"
"    Встроенная команда dirs показывает стек каталогов.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или удалось\n"
"    перейти в каталог."

#: builtins.c:1886
#, fuzzy
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Отображение стека каталогов.\n"
"    \n"
"    Выводит список запомненных на данный момент каталогов.  Каталоги\n"
"    помещаются в список командой «pushd». Для очистки\n"
"    списка используется команда «popd».\n"
"    \n"
"    Параметры:\n"
"      -c\tочистить стек каталогов, удалив из него все элементы\n"
"      -l\tне выводить каталоги, начинающиеся с тильды (~),\n"
"    \tкоторая означает домашний каталог\n"
"      -p\tпоказать стек по одному каталогу в строке\n"
"      -v\tпоказать стек по одному каталогу в строке\n"
"    \tи с номером в стеке\n"
"    \n"
"    Аргументы:\n"
"      +N\tпоказать N-ю запись слева в списке каталогов,\n"
"    \tпоказанного при вызове без параметров, начиная с нуля.\n"
"    \n"
"      -N\tпоказать N-ю справа в списке каталогов запись,\n"
"    \tпоказанного при вызове без параметров, начиная с нуля.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла "
"ошибка."

#: builtins.c:1917
#, fuzzy
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Установка и удаление параметров командного процессора.\n"
"    \n"
"    Изменяет настройки указанных параметров командного процессора.  Если не "
"указать\n"
"    аргумент с параметром, выводит все параметры командного процессора, "
"показывая\n"
"    какой из них установлен, а какой нет.\n"
"    \n"
"    Параметры:\n"
"      -o\tограничиться до параметров, которые заданы с помощью «set -o»\n"
"      -p\tпоказать все параметры командного процессора и их состояние\n"
"      -q\tничего не выводить\n"
"      -s\tвключить (set) все указанные параметры\n"
"      -u\tотключить (unset) все указанные параметры\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если указанный параметр включён. Возвращает ошибку,\n"
"    если был указан недопустимый параметр или параметр отключён."

#: builtins.c:1938
#, fuzzy
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in "
"printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a "
"format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as "
"appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""
"Форматирует и выводит аргументы согласно указанному формату.\n"
"    \n"
"    Параметры:\n"
"      -v перем\tвыводить в указанную переменную bash, а не\n"
"    \t\tна стандартный вывод\n"
"    \n"
"    ФОРМАТ — это символьная строка, содержащая три типа объектов: простые\n"
"    символы, которые копируются на стандартный вывод, экранирующие\n"
"    последовательности, которые преобразовываются и копируются на "
"стандартный\n"
"    вывод, и спецификации, которые активируют вывод следующего успешного\n"
"    аргумента.\n"
"    \n"
"    В дополнение к стандартным спецификациям формата, описанным в "
"printf(1),\n"
"    printf интерпретирует:\n"
"    \n"
"      %b\tразвёртывание экранирующих последовательностей с обратной косой "
"чертой в соответствующий аргумент;\n"
"      %q\tзаключение аргумента в кавычки, чтобы его можно было повторно "
"использовать в качестве входных данных для командного процессора;\n"
"      %(fmt)T вывод строки дата-время, полученной после использования FMT в "
"качестве\n"
"            строки форматирования для strftime(3)\n"
"    \n"
"    Если необходимо задействовать все аргументы, формат используется "
"повторно.  Если\n"
"    аргументов меньше, чем требуется для форматирования, дополнительные\n"
"    спецификации форматирования интерпретируются как содержащие нулевое\n"
"    или пустое значение.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла "
"ошибка\n"
"    записи или присвоения."

#: builtins.c:1974
#, fuzzy
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are "
"supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -"
"I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Определение количества аргументов, завершаемых функцией readline.\n"
"    \n"
"    Для каждого имени нужно указать количество завершаемых аргументов.  Если "
"параметры\n"
"    не указаны, выводятся существующие спецификации завершения формате\n"
"    для повторного использования.\n"
"    \n"
"    Параметры:\n"
"      -p\tвывести существующие спецификации завершения в формате для "
"повторного использования\n"
"      -r\tудалить спецификации завершения для каждого имени или,\n"
"    \tесли имена не указаны, все спецификации\n"
"      -D\tприменить завершения и действия как стандартные для команд,\n"
"    \tдля которых не определены завершения\n"
"      -E\tприменить завершения и действия к «пустым» командам —\n"
"    \tзавершение применяется к пустой строке\n"
"    \n"
"    Когда применяется завершение, действия выполняются в алфавитном порядке\n"
"    перечисленных выше параметров.  Параметр -D имеет более\n"
"    высокий приоритет, чем -E.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла "
"ошибка."

#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Вывод возможных завершений в зависимости от параметров.\n"
"    \n"
"    compgen предназначен для использования в функциях bash, генерирующих\n"
"    возможные завершения.  Если указан необязательный аргумент слово, "
"выполняет\n"
"    сопоставление со сгенерированным словом.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла "
"ошибка."

#: builtins.c:2019
#, fuzzy
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Изменение или вывод параметров завершения.\n"
"    \n"
"    Изменяет параметры завершения для каждого имени или, если имена\n"
"    не указаны, для текущего завершения.  Если параметры не указаны, "
"выводит\n"
"    параметры завершения для каждого имени или текущую спецификацию "
"завершения.\n"
"    \n"
"    Параметры:\n"
"    \t-o параметр\tзадать параметр завершения для каждого имени\n"
"    \t-D\t\tизменить параметры для завершения команды «по умолчанию»\n"
"    \t-E\t\tизменить параметры для завершения «пустой» команды\n"
"    \n"
"    Использование «+o» вместо «-o» отключает указанный параметр.\n"
"    \n"
"    Аргументы:\n"
"    \n"
"    Каждое имя ссылается на команду, для которой уже должна быть определена\n"
"    спецификация завершения с помощью встроенной команды «complete».  Если "
"имена\n"
"    не указаны, функция, которая сейчас генерирует завершения, должна "
"вызвать\n"
"    compopt, и должны измениться параметры для текущего\n"
"    генератора завершения.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или для имени\n"
"    определена спецификация завершения."

#: builtins.c:2050
#, fuzzy
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable "
"ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable "
"MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard "
"input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly "
"or\n"
"    not an indexed array."
msgstr ""
"Чтение строк со стандартного ввода в переменную индексированного массива.\n"
"    \n"
"    Читает строки со стандартного ввода в переменную указанного "
"индексированного массива\n"
"    или из указанного файлового дескриптора, если указан параметр -u.  "
"Переменная $MAPFILE\n"
"    является массивом по умолчанию.\n"
"    \n"
"    Параметры:\n"
"      -n число\tкопировать указанное число строк  Если число равно 0, "
"копируются все строки.\n"
"      -O начало\tначать присвоение массиву, начиная с заданного указателя  "
"По умолчанию указатель равен 0.\n"
"      -s число \tотбросить указанное число первых строк\n"
"      -t\t\tудалить завершающие переводы строки изо всех прочитанных строк\n"
"      -u fd\t\tчитать строки из файлового дескриптора, а не со стандартного "
"входа\n"
"      -C callback\tоценивать callback при чтении каждой строки quantum\n"
"      -c quantum\tчисло строк, читаемых от каждого вызова до callback\n"
"    \n"
"    Аргументы:\n"
"      МАССИВ\t\tназвание переменной массива, используемой для данных файла.\n"
"    \n"
"    Если параметр -C указан без -c, quantum по умолчанию равен 5000.  Когда\n"
"    оценивается callback, он предоставляет указатель на следующий "
"присваиваемый\n"
"    элемента массива и на строку, присваиваемую этому элементу,\n"
"    в качестве дополнительных аргументов.\n"
"    \n"
"    Если явно не указано начало, mapfile очистит массив до\n"
"    операции присвоения.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или массив "
"доступен для записи\n"
"    и является индексированным."

#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Чтение строк из файла в переменную массива.\n"
"    \n"
"    Синоним команды «mapfile»."

#, c-format
#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: недопустимый ключ ассоциативного массива"

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns "
#~ msgstr ""
#~ "Возвращает контекст вызова текущей подпрограммы.\n"
#~ "    \n"
#~ "    Без EXPR выполняет возврат "

#~ msgid "add_process: process %5ld (%s) in the_pipeline"
#~ msgstr "add_process: процесс %5ld (%s) в the_pipeline"

#~ msgid "Unknown Signal #"
#~ msgstr "Неизвестный номер сигнала"

#~ msgid "Copyright (C) 2016 Free Software Foundation, Inc."
#~ msgstr "© Free Software Foundation, Inc, 2016."

#~ msgid ":"
#~ msgstr ":"

#~ msgid "true"
#~ msgstr "true"

#~ msgid "false"
#~ msgstr "false"

#~ msgid "times"
#~ msgstr "times"

#~ msgid "Missing `}'"
#~ msgstr "Пропущен символ `}'"

#~ msgid "brace_expand> "
#~ msgstr "brace_expand> "

#~ msgid "Attempt to free unknown command type `%d'.\n"
#~ msgstr ""
#~ "Попытка освободить память структуры команды неизвестного типа `%d'.\n"

#~ msgid "Report this to %s\n"
#~ msgstr "Сообщите об этом по адресу %s\n"

#~ msgid "Stopping myself..."
#~ msgstr "Прекращение работы..."

#~ msgid "Tell %s to fix this someday.\n"
#~ msgstr "Скажите %s, чтобы он исправил это.\n"

#~ msgid "execute_command: bad command type `%d'"
#~ msgstr "execute_command: неверный тип команды '%d'"

#~ msgid "real\t"
#~ msgstr "реальное\t"

#~ msgid "user\t"
#~ msgstr "пользователя\t"

#~ msgid "sys\t"
#~ msgstr "системное\t"

#~ msgid ""
#~ "real\t0m0.00s\n"
#~ "user\t0m0.00s\n"
#~ "sys\t0m0.00s\n"
#~ msgstr ""
#~ "реальное\t0m0.00s\n"
#~ "пользователя\t0m0.00s\n"
#~ "системное\t0m0.00s\n"

#~ msgid "cannot duplicate fd %d to fd 1: %s"
#~ msgstr "невозможно скопировать файловый дескриптор %d в 1: %s"

#~ msgid "%s: output redirection restricted"
#~ msgstr "%s: перенаправление вывода запрещено (ограниченный режим)"

#~ msgid "Out of memory!"
#~ msgstr "Недостаточно памяти!"

#~ msgid "You have already added item `%s'\n"
#~ msgstr "Элемент `%s' уже добавлен\n"

#~ msgid "You have entered %d (%d) items.  The distribution is:\n"
#~ msgstr "Создано %d (%d) элементов. Распределение:\n"

#~ msgid "slot %3d: "
#~ msgstr "слот %3d: "

#~ msgid "<unknown>"
#~ msgstr "<неизв>"

#~ msgid "%s: bg background job?"
#~ msgstr "%s: задача уже фоновая"

#~ msgid ""
#~ "Redirection instruction from yyparse () '%d' is\n"
#~ "out of range in make_redirection ()."
#~ msgstr ""
#~ "Инструкция перенаправления yyparse () `%d'\n"
#~ "не может быть обработана make_redirection ()."

#~ msgid "clean_simple_command () got a command with type %d."
#~ msgstr "функции clean_simple_command () передана команда типа %d."

#~ msgid "got errno %d while waiting for %d"
#~ msgstr "ошибка %d при ожидании %d"

#~ msgid "syntax error near unexpected token `%c'"
#~ msgstr "синтаксическая ошибка около неожиданной лексемы `%c'"

#~ msgid "print_command: bad command type `%d'"
#~ msgstr "print_command: неверный тип команды `%d'"

#~ msgid "cprintf: bad `%%' argument (%c)"
#~ msgstr "cprintf: неверный спецификатор после `%%' (%c)"

#~ msgid "option `%s' requires an argument"
#~ msgstr "параметр `%s' должен использоваться с аргументом"

#~ msgid "%s: unrecognized option"
#~ msgstr "%s: неизвестный параметр"

#~ msgid "`-c' requires an argument"
#~ msgstr "`-c' должен использоваться с аргументом"

#~ msgid "%s: cannot execute directories"
#~ msgstr "%s: каталоги не могут запускаться как исполняемые файлы"

#~ msgid "Bad code in sig.c: sigprocmask"
#~ msgstr "Неверный код в sig.c: sigprocmask"

#~ msgid "can't make pipes for process substitution: %s"
#~ msgstr "невозможно создать каналы для подстановки: %s"

#~ msgid "reading"
#~ msgstr "чтения"

#~ msgid "writing"
#~ msgstr "записи"

#~ msgid "process substitution"
#~ msgstr "подстановка процессов"

#~ msgid "command substitution"
#~ msgstr "подстановка команд"

#~ msgid "Can't reopen pipe to command substitution (fd %d): %s"
#~ msgstr ""
#~ "Невозможно вновь открыть канал для подстановки команд (файловый "
#~ "дексриптор %d): %s"

#~ msgid "$%c: unbound variable"
#~ msgstr "$%c: не заданы границы"

#~ msgid "%s: bad arithmetic substitution"
#~ msgstr "%s: неверная арифметическая подстановка"

#~ msgid "-%s: binary operator expected"
#~ msgstr "-%s: ожидается бинарная операция"

#~ msgid "%s[%s: bad subscript"
#~ msgstr "%s[%s: неверный индекс"

#~ msgid "[%s: bad subscript"
#~ msgstr "[%s: неверный индекс"

#~ msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr ""
#~ "xmalloc: невозможно заново выделить %lu байтов (выделено %lu байтов)"

#~ msgid "digits occur in two different argv-elements.\n"
#~ msgstr "цифры встречаются в двух разных элементах argv.\n"

#~ msgid "option %c\n"
#~ msgstr "параметр %c\n"

#~ msgid "option a\n"
#~ msgstr "параметр a\n"

#~ msgid "option b\n"
#~ msgstr "параметр b\n"

#~ msgid "option c with value `%s'\n"
#~ msgstr "параметр c со значением `%s'\n"

#~ msgid "?? sh_getopt returned character code 0%o ??\n"
#~ msgstr "?? sh_getopt вернула код символа 0%o ??\n"

#~ msgid "non-option ARGV-elements: "
#~ msgstr "элементы ARGV, не являющиеся параметрами: "

#~ msgid "%s: Unknown flag %s.\n"
#~ msgstr "%s: Неизвестный флаг %s.\n"

#~ msgid "Unknown directive `%s'"
#~ msgstr "Неизвестная директива `%s'"

#~ msgid "%s must be inside of a $BUILTIN block"
#~ msgstr "%s должно быть внутри блока $BUILTIN"

#~ msgid "%s found before $END"
#~ msgstr "%s обнаружено раньше $END"

#~ msgid "%s already has a function (%s)"
#~ msgstr "В %s уже есть функция (%s)"

#~ msgid "%s already had a docname (%s)"
#~ msgstr "В %s уже есть название документации (%s)"

#~ msgid "%s already has short documentation (%s)"
#~ msgstr "В %s уже есть короткая документация (%s)"

#~ msgid "%s already has a %s definition"
#~ msgstr "В %s уже есть определение %s"

#~ msgid "mkbuiltins: Out of virtual memory!\n"
#~ msgstr "mkbuiltins: Не хватает виртуальной памяти!\n"

#~ msgid "read [-r] [-p prompt] [-a array] [-e] [name ...]"
#~ msgstr "read [-r] [-p приглашение] [-a массив] [-e] [имя ...]"

#~ msgid "%[DIGITS | WORD] [&]"
#~ msgstr "%[ЦИФРЫ | СЛОВО] [&]"

#~ msgid "variables - Some variable names and meanings"
#~ msgstr "variables -- Имена и смысл некоторых переменных"

#~ msgid "`alias' with no arguments or with the -p option prints the list"
#~ msgstr "`alias' без аргументов или с параметром -p выводит на стандартный"

#~ msgid "of aliases in the form alias NAME=VALUE on standard output."
#~ msgstr "вывод список псевдокоманд в виде ИМЯ=ЗНАЧЕНИЕ. В противном"

#~ msgid "Otherwise, an alias is defined for each NAME whose VALUE is given."
#~ msgstr "случае, для каждого ИМЕНИ определяется псевдокоманда со ЗНАЧЕНИЕМ."

#~ msgid "A trailing space in VALUE causes the next word to be checked for"
#~ msgstr ""
#~ "Если на конце ЗНАЧЕНИЯ есть пробелы, при разворачивании псевдокоманды"

#~ msgid "alias substitution when the alias is expanded.  Alias returns"
#~ msgstr "следующее слово проверяется на подстановку псевдокоманд. Alias"

#~ msgid "true unless a NAME is given for which no alias has been defined."
#~ msgstr ""
#~ "возвращает true, если только не задано ИМЯ, для которого нет псевдокоманд."

#~ msgid ""
#~ "Remove NAMEs from the list of defined aliases.  If the -a option is given,"
#~ msgstr ""
#~ "Удаляет ИМЕНА из списка определённых псевдокоманд. Если задан параметр -a,"

#~ msgid "then remove all alias definitions."
#~ msgstr "удаляет все определения псевдокоманд."

#~ msgid "Bind a key sequence to a Readline function, or to a macro.  The"
#~ msgstr ""
#~ "Связывает последовательность клавиш с функцией Readline или с макросом."

#~ msgid "syntax is equivalent to that found in ~/.inputrc, but must be"
#~ msgstr "Синтаксис тот же, что и в ~/.inputrc, но должен передаваться"

#~ msgid ""
#~ "passed as a single argument: bind '\"\\C-x\\C-r\": re-read-init-file'."
#~ msgstr "одним аргументом: bind '\"\\C-x\\C-r\": re-read-init-file'."

#~ msgid "Arguments we accept:"
#~ msgstr "Принимаемые аргументы:"

#~ msgid ""
#~ "  -m  keymap         Use `keymap' as the keymap for the duration of this"
#~ msgstr ""
#~ "   -m раскладка      Использовать во время работы программы указанную"

#~ msgid "                     command.  Acceptable keymap names are emacs,"
#~ msgstr "                     раскладку.  Допустимые имена раскладок: emacs,"

#~ msgid ""
#~ "                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"
#~ msgstr ""
#~ "                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"

#~ msgid "                     vi-command, and vi-insert."
#~ msgstr "                     vi-command и vi-insert."

#~ msgid "  -l                 List names of functions."
#~ msgstr "  -l                 Вывести список имён функций."

#~ msgid "  -P                 List function names and bindings."
#~ msgstr "  -P                  Вывести список имён функций и связей."

#~ msgid ""
#~ "  -p                 List functions and bindings in a form that can be"
#~ msgstr "  -p                 Вывести список имён функций и связей в виде,"

#~ msgid "                     reused as input."
#~ msgstr "                     который можно использовать на входе."

#~ msgid "  -r  keyseq         Remove the binding for KEYSEQ."
#~ msgstr "  -r  послед_клавиш  Удалить связь для `послед_клавиш'."

#~ msgid "  -f  filename       Read key bindings from FILENAME."
#~ msgstr "  -f  имя_файла      Прочесть связи из файла."

#~ msgid ""
#~ "  -q  function-name  Query about which keys invoke the named function."
#~ msgstr ""
#~ "  -q  имя_функции    Запрос, какие клавиши вызовут указанную функцию."

#~ msgid "  -V                 List variable names and values"
#~ msgstr "  -V                 Вывести список имён и значений переменных."

#~ msgid ""
#~ "  -v                 List variable names and values in a form that can"
#~ msgstr ""
#~ "  -v                 Вывести список имён и значений переменных в виде,"

#~ msgid "                     be reused as input."
#~ msgstr "                     который можно использовать на входе"

#~ msgid ""
#~ "  -S                 List key sequences that invoke macros and their "
#~ "values"
#~ msgstr ""
#~ "  -S                 Вывести список последовательностей клавиш, "
#~ "вызывающих макросы и их значений."

#~ msgid ""
#~ "  -s                 List key sequences that invoke macros and their "
#~ "values in"
#~ msgstr ""
#~ "  -s                Вывести список последовательностей клавиш, вызывающих "
#~ "макросы"

#~ msgid "                     a form that can be reused as input."
#~ msgstr ""
#~ "                     и их значений в виде, который можно использовать на "
#~ "входе"

#~ msgid "Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,"
#~ msgstr "Выйти из цикла FOR, WHILE или UNTIL.  Если указано N,"

#~ msgid "break N levels."
#~ msgstr "выйти из N вложенных уровней."

#~ msgid "Resume the next iteration of the enclosing FOR, WHILE or UNTIL loop."
#~ msgstr "Перейти к следующей итерации цикла FOR, WHILE или UNTIL."

#~ msgid "If N is specified, resume at the N-th enclosing loop."
#~ msgstr "Если задано N, перейти к N-му обрамляющему циклу."

#~ msgid "Run a shell builtin.  This is useful when you wish to rename a"
#~ msgstr "Выполнить встроенную команду оболочки.  Это полезно, если вы хотите"

#~ msgid "shell builtin to be a function, but need the functionality of the"
#~ msgstr "создать функцию с именем встроенной команды, но хотите сохранить"

#~ msgid "builtin within the function itself."
#~ msgstr "возможность использования команды из самой функции"

#~ msgid "Change the current directory to DIR.  The variable $HOME is the"
#~ msgstr "Изменить текущий каталог на заданный.  Переменная $HOME содержит"

#~ msgid "default DIR.  The variable $CDPATH defines the search path for"
#~ msgstr ""
#~ "каталог по умолчанию.  Переменная $CDPATH определяет путь, в котором"

#~ msgid "the directory containing DIR.  Alternative directory names in CDPATH"
#~ msgstr ""
#~ "ищется каталог, содержащий КАТАЛОГ.  Альтернативные каталоги в CDPATH"

#~ msgid "are separated by a colon (:).  A null directory name is the same as"
#~ msgstr ""
#~ "разделяются точкой с запятой (:).  Пустое имя каталога -- то же самое,"

#~ msgid "the current directory, i.e. `.'.  If DIR begins with a slash (/),"
#~ msgstr ""
#~ "что текущий каталог, т.е. `.'.  Если КАТАЛОГ начинается с дроби (/),"

#~ msgid "then $CDPATH is not used.  If the directory is not found, and the"
#~ msgstr ""
#~ "$CDPATh не используется.  Если каталог не найден, и установлен параметр"

#~ msgid "shell option `cdable_vars' is set, then try the word as a variable"
#~ msgstr ""
#~ "оболочки `cdable_vars', делается попытка интерпретировать это слово как "
#~ "имя"

#~ msgid "name.  If that variable has a value, then cd to the value of that"
#~ msgstr ""
#~ "переменной.  Если эта переменная имеет значение, каталог меняется на это"

#~ msgid ""
#~ "variable.  The -P option says to use the physical directory structure"
#~ msgstr ""
#~ "значение.  Параметр -P указывает использовать физическую структуру "
#~ "каталогов,"

#~ msgid ""
#~ "instead of following symbolic links; the -L option forces symbolic links"
#~ msgstr ""
#~ "а не следовать символчиеским ссылкам, параметр -L заставляет следовать"

#~ msgid "to be followed."
#~ msgstr "символическим ссылкам."

#~ msgid "Print the current working directory.  With the -P option, pwd prints"
#~ msgstr ""
#~ "Вывести имя текущего рабочего каталога.  С параметром -P pwd выводит"

#~ msgid "the physical directory, without any symbolic links; the -L option"
#~ msgstr ""
#~ "физический каталог, без символических ссылок, параметр -L заставляет"

#~ msgid "makes pwd follow symbolic links."
#~ msgstr "pwd следовать символическим ссылкам."

#~ msgid ""
#~ "Runs COMMAND with ARGS ignoring shell functions.  If you have a shell"
#~ msgstr ""
#~ "Выполняет КОМАНДУ с АРГУМЕНТАМИ, игнорируя функции оболочки. Если у вас "
#~ "есть"

#~ msgid "function called `ls', and you wish to call the command `ls', you can"
#~ msgstr ""
#~ "функция оболочки `ls', а вы хотите вызвать команду `ls', можно "
#~ "использовать"

#~ msgid ""
#~ "say \"command ls\".  If the -p option is given, a default value is used"
#~ msgstr ""
#~ "\"command ls\".  Если задан параметр -p, используется значение $PATH"

#~ msgid ""
#~ "for PATH that is guaranteed to find all of the standard utilities.  If"
#~ msgstr "по умолчанию, что гарантирует отыскание стандартных утилит.  Если"

#~ msgid ""
#~ "the -V or -v option is given, a string is printed describing COMMAND."
#~ msgstr "задан параметр -V или -v, выводится строка, описывающая КОМАНДУ."

#~ msgid "The -V option produces a more verbose description."
#~ msgstr "Параметр -V создаёт более подробное описание."

#~ msgid "Declare variables and/or give them attributes.  If no NAMEs are"
#~ msgstr ""
#~ "Объявляет переменные и/или придаёт им атрибуты.  Если не заданы ИМЕНА,"

#~ msgid "given, then display the values of variables instead.  The -p option"
#~ msgstr "выводит вместо этого значения переменных.  Параметр -p выведет"

#~ msgid "will display the attributes and values of each NAME."
#~ msgstr "атрибуты и значения каждого ИМЕНИ."

#~ msgid "The flags are:"
#~ msgstr "Флаги:"

#~ msgid "  -a\tto make NAMEs arrays (if supported)"
#~ msgstr "  -a\tсчитать ИМЕНА массивами (если поддерживаются)"

#~ msgid "  -f\tto select from among function names only"
#~ msgstr "  -f\tискать только среди имён функций"

#~ msgid "  -F\tto display function names without definitions"
#~ msgstr "  -F\tпоказать имена функций без определений"

#~ msgid "  -r\tto make NAMEs readonly"
#~ msgstr "  -r\tсделать ИМЕНА переменными только для чтения"

#~ msgid "  -x\tto make NAMEs export"
#~ msgstr "  -x\tпозволить экспорт ИМЁН"

#~ msgid "  -i\tto make NAMEs have the `integer' attribute set"
#~ msgstr "  -i\tпридать ИМЕНАМ набор атрибутов `integer' (целочисленный)"

#~ msgid "Variables with the integer attribute have arithmetic evaluation (see"
#~ msgstr "Для переменных с атрибутом `integer' арифметические вычисления (см."

#~ msgid "`let') done when the variable is assigned to."
#~ msgstr "`let') выполняются при присвоении переменной значения."

#~ msgid "When displaying values of variables, -f displays a function's name"
#~ msgstr "При выводе значений переменных -f выводит имя и определение"

#~ msgid "and definition.  The -F option restricts the display to function"
#~ msgstr "функции.  Параметр -F ограничивает вывод именем"

#~ msgid "name only."
#~ msgstr "функции."

#~ msgid ""
#~ "Using `+' instead of `-' turns off the given attribute instead.  When"
#~ msgstr "Использование `+' вместо `-' выключает заданный атрибут.  При"

#~ msgid "used in a function, makes NAMEs local, as with the `local' command."
#~ msgstr ""
#~ "использовании в функции делает ИМЕНа локальными, как команда `local'."

#~ msgid "Obsolete.  See `declare'."
#~ msgstr "Устарела.  См. `declare'."

#~ msgid "Create a local variable called NAME, and give it VALUE.  LOCAL"
#~ msgstr "Создать локальную переменную ИМЯ и придать ей ЗНАЧЕНИЕ.  LOCAL"

#~ msgid "have a visible scope restricted to that function and its children."
#~ msgstr "область видимости ИМЕНИ этой функцией и её потомками."

#~ msgid "Output the ARGs.  If -n is specified, the trailing newline is"
#~ msgstr "Выводит АРГУМЕНТЫ.  Если задано -n, подавляется завершающий переход"

#~ msgid "suppressed.  If the -e option is given, interpretation of the"
#~ msgstr ""
#~ "на новую строку.  Если задан параметр -e, интерпретируются следующие"

#~ msgid "following backslash-escaped characters is turned on:"
#~ msgstr "экранированные символы:"

#~ msgid "\t\\a\talert (bell)"
#~ msgstr "\t\\a\tпредупреждение (звонок)"

#~ msgid "\t\\b\tbackspace"
#~ msgstr "\t\\b\tзабой (откат)"

#~ msgid "\t\\c\tsuppress trailing newline"
#~ msgstr "\t\\c\tподавить завершающий переход на новую строку"

#~ msgid "\t\\E\tescape character"
#~ msgstr "\t\\E\tэкранировать символ"

#~ msgid "\t\\f\tform feed"
#~ msgstr "\t\\f\tсдвиг на следующую строку"

#~ msgid "\t\\n\tnew line"
#~ msgstr "\t\\n\tновая строка"

#~ msgid "\t\\r\tcarriage return"
#~ msgstr "\t\\r\tвозврат каретки"

#~ msgid "\t\\t\thorizontal tab"
#~ msgstr "\t\\t\tгоризонтальная табуляция"

#~ msgid "\t\\v\tvertical tab"
#~ msgstr "\t\\v\tвертикальная табуляция"

#~ msgid "\t\\\\\tbackslash"
#~ msgstr "\t\\\\\tобратная косая черта"

#~ msgid "\t\\num\tthe character whose ASCII code is NUM (octal)."
#~ msgstr "\t\\число\tсимвол, восьмеричный ASCII-код которого равен ЧИСЛУ"

#~ msgid ""
#~ "You can explicitly turn off the interpretation of the above characters"
#~ msgstr "Вы можете явно выключить интерпретацию вышеприведённых символов"

#~ msgid "with the -E option."
#~ msgstr "параметром -E."

#~ msgid ""
#~ "Output the ARGs.  If -n is specified, the trailing newline is suppressed."
#~ msgstr ""
#~ "Выводит АРГУМЕНТЫ.  Если задано -n, подавляется завершающий переход на "
#~ "новую строку."

#~ msgid "Enable and disable builtin shell commands.  This allows"
#~ msgstr "Включает и блокирует встроенные команды оболочки.  Это позволяет"

#~ msgid "you to use a disk command which has the same name as a shell"
#~ msgstr "использовать внешние команды с теми же именами, что команды"

#~ msgid "builtin.  If -n is used, the NAMEs become disabled; otherwise"
#~ msgstr ""
#~ "оболочки.  При использовании -n ИМЕНА блокируются, в противном случае"

#~ msgid "NAMEs are enabled.  For example, to use the `test' found on your"
#~ msgstr ""
#~ "включаются.  Например, чтобы использовать файл `test', а не встроенную"

#~ msgid "path instead of the shell builtin version, type `enable -n test'."
#~ msgstr "в оболочку версию, введите enable -n test'.  На системах,"

#~ msgid "On systems supporting dynamic loading, the -f option may be used"
#~ msgstr "поддерживающих динамическую загрузку можно использовать параметр -f"

#~ msgid "to load new builtins from the shared object FILENAME.  The -d"
#~ msgstr ""
#~ "чтобы загрузить новые встроенные команды из разделяемого объекта ФАЙЛ."

#~ msgid "option will delete a builtin previously loaded with -f.  If no"
#~ msgstr "Параметр -d удаляет команды, загруженные -f.  Если имена, кроме"

#~ msgid "non-option names are given, or the -p option is supplied, a list"
#~ msgstr "как в параметрах, не заданы, или если задан параметр -p, выводится"

#~ msgid "of builtins is printed.  The -a option means to print every builtin"
#~ msgstr ""
#~ "список встроенных команд.  Параметр -a требует вывести все встроенные"

#~ msgid "with an indication of whether or not it is enabled.  The -s option"
#~ msgstr "команды с информацией, блокированы ли они.  Параметр -s выводит"

#~ msgid "restricts the output to the Posix.2 `special' builtins.  The -n"
#~ msgstr "только `специальные' команды Posix.2.  Параметр -n выводит список"

#~ msgid "option displays a list of all disabled builtins."
#~ msgstr "всех блокированных встроенных команд."

#~ msgid ""
#~ "Read ARGs as input to the shell and execute the resulting command(s)."
#~ msgstr ""
#~ "Читает АРГУМЕНТЫ как входной текст оболочки и выполняет полученные "
#~ "команды."

#~ msgid "Getopts is used by shell procedures to parse positional parameters."
#~ msgstr ""
#~ "Getopts используется процедурами оболочки для анализа параметров командной"

#~ msgid "OPTSTRING contains the option letters to be recognized; if a letter"
#~ msgstr "строки.  СТРОКА_ПАРАМЕТРОВ содержит буквы параметров, которые нужно"

#~ msgid "is followed by a colon, the option is expected to have an argument,"
#~ msgstr ""
#~ "распознать.  Если за буквой следует двоеточие, параметр должен иметь"

#~ msgid "which should be separated from it by white space."
#~ msgstr "аргумент, отделённый от него промежутком."

#~ msgid "Each time it is invoked, getopts will place the next option in the"
#~ msgstr "При каждом вызове getopts помещает следующий параметр в переменную"

#~ msgid "shell variable $name, initializing name if it does not exist, and"
#~ msgstr "оболочки $имя, инициализируя имя, если оно не существует, а индекс"

#~ msgid "the index of the next argument to be processed into the shell"
#~ msgstr "следующего аргумента в переменную оболочки OPTIND.  OPTIND"

#~ msgid "variable OPTIND.  OPTIND is initialized to 1 each time the shell or"
#~ msgstr ""
#~ "принимает значение 1 при каждом вызове оболочки или скрипта оболочки."

#~ msgid "a shell script is invoked.  When an option requires an argument,"
#~ msgstr "Если параметр требует аргумента, getopts помещает этот аргумент"

#~ msgid "getopts places that argument into the shell variable OPTARG."
#~ msgstr "в переменную оболочки OPTARG."

#~ msgid "getopts reports errors in one of two ways.  If the first character"
#~ msgstr ""
#~ "getopts сообщает об ошибках одним из двух способов. Если первый символ"

#~ msgid "of OPTSTRING is a colon, getopts uses silent error reporting.  In"
#~ msgstr ""
#~ "OPTSTRING -- двоеточие, getopts использует бесшумный способ.  В этом"

#~ msgid "this mode, no error messages are printed.  If an illegal option is"
#~ msgstr "случае сообщения об ошибках не выводятся.  Если найден недопустимый"

#~ msgid "seen, getopts places the option character found into OPTARG.  If a"
#~ msgstr ""
#~ "параметр, getopts помещает найденный символ в OPTARG.  Если не найден"

#~ msgid "required argument is not found, getopts places a ':' into NAME and"
#~ msgstr "требуемый аргумент, getopts помещает в ИМЯ ':', а в OPTARG --"

#~ msgid "sets OPTARG to the option character found.  If getopts is not in"
#~ msgstr "найденный символ.  Если getopts работает не в бесшумном режиме"

#~ msgid "silent mode, and an illegal option is seen, getopts places '?' into"
#~ msgstr "и обнаружен недопустимый параметр, getopts помещает в ИМЯ '?', и"

#~ msgid "NAME and unsets OPTARG.  If a required option is not found, a '?'"
#~ msgstr "сбрасывает OPTARG.  Если не найден требуемый параметр, в ИМЯ"

#~ msgid "is placed in NAME, OPTARG is unset, and a diagnostic message is"
#~ msgstr "помещается '?', OPTARG сбрасывается, и выводится диагностическое"

#~ msgid "printed."
#~ msgstr "сообщение."

#~ msgid "If the shell variable OPTERR has the value 0, getopts disables the"
#~ msgstr "Если переменная оболочки OPTERR имеет значение 0, getopts блокирует"

#~ msgid "printing of error messages, even if the first character of"
#~ msgstr "вывод сообщений об ошибках, даже если первый символ OPTSTRING"

#~ msgid "OPTSTRING is not a colon.  OPTERR has the value 1 by default."
#~ msgstr "не двоеточие.  По умолчанию OPTERR имеет значение 1."

#~ msgid "Getopts normally parses the positional parameters ($0 - $9), but if"
#~ msgstr "Getopts обычно разбирает позиционные параметры ($0 - $9), но если"

#~ msgid "more arguments are given, they are parsed instead."
#~ msgstr "заданы дополнительные аргументы, вместо этого разбираются они"

#~ msgid "Exec FILE, replacing this shell with the specified program."
#~ msgstr "Запустить ФАЙЛ, замещая эту копию оболочки указанной программой."

#~ msgid "If FILE is not specified, the redirections take effect in this"
#~ msgstr "Если ФАЙЛ не задан, могут быть переназначены файловые дескрипторы."

#~ msgid "shell.  If the first argument is `-l', then place a dash in the"
#~ msgstr "Если первый аргумент `-l', в начало нулевого аргумента, переданного"

#~ msgid "zeroth arg passed to FILE, as login does.  If the `-c' option"
#~ msgstr "ФАЙЛУ, добавляется `-', как при работе login.  Если задан параметр"

#~ msgid "is supplied, FILE is executed with a null environment.  The `-a'"
#~ msgstr "`-c', ФАЙЛ выполняется в пустой среде.  Параметр `-a' устанавливает"

#~ msgid "option means to make set argv[0] of the executed process to NAME."
#~ msgstr "argv[0] запущенного процесса в ИМЯ."

#~ msgid "If the file cannot be executed and the shell is not interactive,"
#~ msgstr "Если файл не может быть запущен, а оболочка не интерактивна,"

#~ msgid "then the shell exits, unless the variable \"no_exit_on_failed_exec\""
#~ msgstr ""
#~ "производится выход из оболочки, если только не установлена переменная"

#~ msgid "is set."
#~ msgstr "\"no_exit_on_failed_exec\""

#~ msgid "is that of the last command executed."
#~ msgstr "завершения будет таким же, как у последней выполненной команды."

#~ msgid ""
#~ "FIRST and LAST can be numbers specifying the range, or FIRST can be a"
#~ msgstr ""
#~ "ПЕРВАЯ и ПОСЛЕДНЯЯ могут быть числами, ограничивающими диапазон, или"

#~ msgid "string, which means the most recent command beginning with that"
#~ msgstr "же ПЕРВАЯ может быть строкой, означающей самую недавнюю команду,"

#~ msgid "string."
#~ msgstr "начинающуюся с этой строки."

#~ msgid ""
#~ "   -e ENAME selects which editor to use.  Default is FCEDIT, then EDITOR,"
#~ msgstr ""
#~ "   -e ИМЯ_РЕДАКТОРА выбирает используемый редактор.  По умолчанию FCEDIT,"

#~ msgid ""
#~ "      then the editor which corresponds to the current readline editing"
#~ msgstr "      затем EDITOR, затем редактор, соответствуюший текущему режиму"

#~ msgid "      mode, then vi."
#~ msgstr "      редактирования readline, затем vi."

#~ msgid "   -l means list lines instead of editing."
#~ msgstr "   -l вывести, а не редактировать строки."

#~ msgid "   -n means no line numbers listed."
#~ msgstr "   -n не выводить номера строк."

#~ msgid ""
#~ "   -r means reverse the order of the lines (making it newest listed "
#~ "first)."
#~ msgstr "   -r вывести строки в обратном порядке (в начале самые новые)."

#~ msgid "With the `fc -s [pat=rep ...] [command]' format, the command is"
#~ msgstr ""
#~ "В формате `fc -s [шаблон=замена] [команда]  команда выполняется заново"

#~ msgid "re-executed after the substitution OLD=NEW is performed."
#~ msgstr "после того, как произведена подстановка."

#~ msgid "A useful alias to use with this is r='fc -s', so that typing `r cc'"
#~ msgstr "Полезная псевдокоманда -- r='fc -s', так `r cc' выполняет последнюю"

#~ msgid "runs the last command beginning with `cc' and typing `r' re-executes"
#~ msgstr "команду, начинающуюся с `cc', а `r' заново выполняет последнюю"

#~ msgid "Place JOB_SPEC in the foreground, and make it the current job.  If"
#~ msgstr ""
#~ "Возвращает задачу с указанным номером из фонового режима и делает её"

#~ msgid "JOB_SPEC is not present, the shell's notion of the current job is"
#~ msgstr "текущей задачей. Если номер не задан, используется представление"

#~ msgid "used."
#~ msgstr "оболочки о текущей задаче."

#~ msgid "Place JOB_SPEC in the background, as if it had been started with"
#~ msgstr ""
#~ "Переводит задачу с указанным номером в фоновый режим, как если бы она"

#~ msgid "`&'.  If JOB_SPEC is not present, the shell's notion of the current"
#~ msgstr ""
#~ "была запущена с `&'.  Если номер не задан, используется представление"

#~ msgid "job is used."
#~ msgstr "оболочки о текущей задаче."

#~ msgid "For each NAME, the full pathname of the command is determined and"
#~ msgstr "Для каждого ИМЕНИ определяются и запоминаются полные пути команды."

#~ msgid "remembered.  If the -p option is supplied, PATHNAME is used as the"
#~ msgstr "Если задан параметр -p, в качестве пути используется заданный, а"

#~ msgid "full pathname of NAME, and no path search is performed.  The -r"
#~ msgstr "поиск не выполняется.  Параметр -r заставляет оболочку очистить"

#~ msgid "option causes the shell to forget all remembered locations.  If no"
#~ msgstr "список положений в памяти.  Если аргументы не заданы, выводится"

#~ msgid ""
#~ "arguments are given, information about remembered commands is displayed."
#~ msgstr "информация о запомненных командах."

#~ msgid "Display helpful information about builtin commands.  If PATTERN is"
#~ msgstr ""
#~ "Вывести полезную информацию о встроенных командах.  Если задан ШАБЛОН,"

#~ msgid "specified, gives detailed help on all commands matching PATTERN,"
#~ msgstr ""
#~ "вывести подробную справку по всем командам, соответствующим ШАБЛОНУ,"

#~ msgid "otherwise a list of the builtins is printed."
#~ msgstr "в противном случае вывести список встроенных команд."

#~ msgid "Display the history list with line numbers.  Lines listed with"
#~ msgstr "Вывести историю команд в виде списка с номерами строк.  Изменённые"

#~ msgid "with a `*' have been modified.  Argument of N says to list only"
#~ msgstr ""
#~ "строки помечаются символом `*'.  Аргумент N указывает выводить только"

#~ msgid "the last N lines.  The -c option causes the history list to be"
#~ msgstr "последние N строк.  Параметр -c очищает историю команд, удаляя"

#~ msgid ""
#~ "cleared by deleting all of the entries.  The `-w' option writes out the"
#~ msgstr "все строки.  Параметр `-w' записывает текущую историю в указанный"

#~ msgid ""
#~ "current history to the history file;  `-r' means to read the file and"
#~ msgstr "файл; `-r' читает такой файл и дополняет его содержимым историю"

#~ msgid "append the contents to the history list instead.  `-a' means"
#~ msgstr "команд.  `-a' добавляет историю этой сессии к файлу истории"

#~ msgid "to append history lines from this session to the history file."
#~ msgstr "команд.  Аргумент `-n' читает из файла истории все строки, не"

#~ msgid "Argument `-n' means to read all history lines not already read"
#~ msgstr "прочитанные ранее, и добавляет их к истории.  Если задан ФАЙЛ,"

#~ msgid "from the history file and append them to the history list.  If"
#~ msgstr "в качестве файла истории команд используется он, иначе, если"

#~ msgid "FILENAME is given, then that is used as the history file else"
#~ msgstr "переменной $HISTFILE присвоено значение, используется оно, иначе"

#~ msgid "if $HISTFILE has a value, that is used, else ~/.bash_history."
#~ msgstr "используется ~/.bash_history.  Если задан параметр -s, АРГУМЕНТЫ,"

#~ msgid "If the -s option is supplied, the non-option ARGs are appended to"
#~ msgstr "являющиеся параметрами, добавляются к истории как один элемент."

#~ msgid "the history list as a single entry.  The -p option means to perform"
#~ msgstr "Параметр -p выполняет развёртывание каждого АРГУМЕНТА и выводит"

#~ msgid ""
#~ "history expansion on each ARG and display the result, without storing"
#~ msgstr "результат, не сохраняя ничего в списке истории команд."

#~ msgid "anything in the history list."
#~ msgstr " "

#~ msgid "Lists the active jobs.  The -l option lists process id's in addition"
#~ msgstr "Выводит список активных задач.  Параметр -l выводит, кроме того,"

#~ msgid "to the normal information; the -p option lists process id's only."
#~ msgstr "идентификаторы процессов: параметр -p выодит только идентификаторы."

#~ msgid ""
#~ "If -n is given, only processes that have changed status since the last"
#~ msgstr "Если задано -n, выводятся только процессы, статус которых изменился"

#~ msgid ""
#~ "notification are printed.  JOBSPEC restricts output to that job.  The"
#~ msgstr ""
#~ "со времени последнего уведомления.  Если задан номер задачи, выводится"

#~ msgid "-r and -s options restrict output to running and stopped jobs only,"
#~ msgstr "только она.  Параметры -r и -s выводит только работающие или только"

#~ msgid "respectively.  Without options, the status of all active jobs is"
#~ msgstr ""
#~ "остановленные задачи соответственно.  Без параметров выодится статус"

#~ msgid ""
#~ "printed.  If -x is given, COMMAND is run after all job specifications"
#~ msgstr ""
#~ "всех активных задач.  Если задано -x, в КОМАНДЕ вместо всех АРГУМЕНТОВ"

#~ msgid ""
#~ "that appear in ARGS have been replaced with the process ID of that job's"
#~ msgstr "(номеров задач) подставляется идентификатор лидера соответствующей"

#~ msgid "process group leader."
#~ msgstr "группы процессов, и КОМАНДА выполняется."

#~ msgid "Removes each JOBSPEC argument from the table of active jobs."
#~ msgstr ""
#~ "Удаляет все задачи, заданные спецификациями в аргументе, из таблицы задач."

#~ msgid "Send the processes named by PID (or JOB) the signal SIGSPEC.  If"
#~ msgstr ""
#~ "Посылает указанным процессам (заданным PID или спецификацией) сигнал"

#~ msgid ""
#~ "SIGSPEC is not present, then SIGTERM is assumed.  An argument of `-l'"
#~ msgstr "SIGSPEC. Если отсутствует SIGSPEC, посылается SIGTERM. Аргументом"

#~ msgid "lists the signal names; if arguments follow `-l' they are assumed to"
#~ msgstr ""
#~ "параметра `-l' служит список сигналов. Если он присутствует, выводятся"

#~ msgid "be signal numbers for which names should be listed.  Kill is a shell"
#~ msgstr ""
#~ "названия сигналов с этими номерами. Kill является встроенной командой"

#~ msgid "builtin for two reasons: it allows job IDs to be used instead of"
#~ msgstr "оболочки по двум причинам: она позволяет использовать номера задач,"

#~ msgid "process IDs, and, if you have reached the limit on processes that"
#~ msgstr "а не процессов, и если вы исчерпаете лимит созданных процессов,"

#~ msgid ""
#~ "you can create, you don't have to start a process to kill another one."
#~ msgstr "вы не сможете запустить новый процесс, уничтожающий один из старых."

#~ msgid "Each ARG is an arithmetic expression to be evaluated.  Evaluation"
#~ msgstr "Каждый аргумент рассматривается как арифметическое выражение."

#~ msgid "is done in long integers with no check for overflow, though division"
#~ msgstr ""
#~ "Вычисление производится над длинными целыми без контроля переполнения,"

#~ msgid "by 0 is trapped and flagged as an error.  The following list of"
#~ msgstr "хотя деление на ноль отслеживается и считается ошибкой. Операции в"

#~ msgid "operators is grouped into levels of equal-precedence operators."
#~ msgstr "следующем списке сгруппированы по уровням равного приоритета."

#~ msgid "The levels are listed in order of decreasing precedence."
#~ msgstr "Уровни перечислены в порядке уменьшения приоритета."

#~ msgid "\t-, +\t\tunary minus, plus"
#~ msgstr "\t-, +\t\tунарный минус, унарный плюс"

#~ msgid "\t!, ~\t\tlogical and bitwise negation"
#~ msgstr "\t!, ~\t\tлогическое и побитовое отрицание"

#~ msgid "\t*, /, %\t\tmultiplication, division, remainder"
#~ msgstr "\t*, /, %\t\tумножение, деление, взятие остатка"

#~ msgid "\t+, -\t\taddition, subtraction"
#~ msgstr "\t+, -\t\tсложение, вычитание"

#~ msgid "\t<<, >>\t\tleft and right bitwise shifts"
#~ msgstr "\t<<, >>\t\tлевый и правый побитовый сдвиг"

#~ msgid "\t<=, >=, <, >\tcomparison"
#~ msgstr "\t<=, >=, <, >\tсравнение"

#~ msgid "\t==, !=\t\tequality, inequality"
#~ msgstr "\t==, !=\t\tравенство, неравенство"

#~ msgid "\t&\t\tbitwise AND"
#~ msgstr "\t&\t\tпобитовое И"

#~ msgid "\t^\t\tbitwise XOR"
#~ msgstr "\t^\t\tпобитовое ИСКЛЮЧАЮЩЕЕ ИЛИ"

#~ msgid "\t|\t\tbitwise OR"
#~ msgstr "\t|\t\tпобитовое ИЛИ"

#~ msgid "\t&&\t\tlogical AND"
#~ msgstr "\t&&\t\tлогическое И"

#~ msgid "\t||\t\tlogical OR"
#~ msgstr "\t||\t\tлогическое ИЛИ"

#~ msgid "\texpr ? expr : expr"
#~ msgstr "\texpt ? expr : expr"

#~ msgid "\t\t\tconditional expression"
#~ msgstr "\t\t\tусловное выражение"

#~ msgid "\t=, *=, /=, %=,"
#~ msgstr "\t=, *=, /=, %=,"

#~ msgid "\t+=, -=, <<=, >>=,"
#~ msgstr "\t+=, -=, <<=, >>=,"

#~ msgid "\t&=, ^=, |=\tassignment"
#~ msgstr "\t&=, ^=, |=\tприсваивание"

#~ msgid "is replaced by its value (coerced to a long integer) within"
#~ msgstr "переменной заменяется её значение (преобразованным в длинное"

#~ msgid "an expression.  The variable need not have its integer attribute"
#~ msgstr "целое). Для использования в выражении переменная не обязана иметь"

#~ msgid "turned on to be used in an expression."
#~ msgstr "установленный целочисленный атрибут."

#~ msgid "Operators are evaluated in order of precedence.  Sub-expressions in"
#~ msgstr "Операции обрабатываются в порядке приоритета. Подвыражения в"

#~ msgid "parentheses are evaluated first and may override the precedence"
#~ msgstr "скобках вычисляются вначале, что может не соответствовать правилам"

#~ msgid "rules above."
#~ msgstr "приоритета."

#~ msgid "If the last ARG evaluates to 0, let returns 1; 0 is returned"
#~ msgstr "Если вычисление последнего аргумента дало 0, let возвращает 1,"

#~ msgid "otherwise."
#~ msgstr "иначе 0."

#~ msgid "One line is read from the standard input, and the first word is"
#~ msgstr "Со стандартного ввода считывается одна строка, первое её слово"

#~ msgid ""
#~ "assigned to the first NAME, the second word to the second NAME, and so"
#~ msgstr "становится значением первого ИМЕНИ, второе -- второго ИМЕНИ и т.д."

#~ msgid ""
#~ "on, with leftover words assigned to the last NAME.  Only the characters"
#~ msgstr ""
#~ "Последнему ИМЕНИ присваивается весь остаток строки. Разделителями слов"

#~ msgid "found in $IFS are recognized as word delimiters.  The return code is"
#~ msgstr "считаются только символы, входящие в $IFS. Код возврата равен нулю,"

#~ msgid ""
#~ "zero, unless end-of-file is encountered.  If no NAMEs are supplied, the"
#~ msgstr "за исключением случая, если встретился конец файла. Если ИМЕНА не"

#~ msgid ""
#~ "line read is stored in the REPLY variable.  If the -r option is given,"
#~ msgstr ""
#~ "заданы, прочитанная строка помещается в переменную REPLY. Если задан"

#~ msgid "this signifies `raw' input, and backslash escaping is disabled.  If"
#~ msgstr ""
#~ "параметр -r, это означает `сырой' ввод, т.е. символ \\ не экранирует"

#~ msgid "the `-p' option is supplied, the string supplied as an argument is"
#~ msgstr ""
#~ "символы. Если задано `-p', перед чтением на вывод в качестве аргумента"

#~ msgid ""
#~ "output without a trailing newline before attempting to read.  If -a is"
#~ msgstr ""
#~ "подаётся заданная строка (без завершающего символа перевода строки)."

#~ msgid ""
#~ "supplied, the words read are assigned to sequential indices of ARRAY,"
#~ msgstr "Если задано -a, прочитанные слова становятся значениями элементов"

#~ msgid "starting at zero.  If -e is supplied and the shell is interactive,"
#~ msgstr ""
#~ "МАССИВА, начиная с нулевого. Если задано -c и оболочка интерактивна,"

#~ msgid "readline is used to obtain the line."
#~ msgstr "чтобы получить строку используется readline."

#~ msgid ""
#~ "Causes a function to exit with the return value specified by N.  If N"
#~ msgstr "Заставляет функцию завершить работу с кодом возврата, заданным N."

#~ msgid "is omitted, the return status is that of the last command."
#~ msgstr "Если N опущено, им становится код возврата последней команды."

#~ msgid "    -a  Mark variables which are modified or created for export."
#~ msgstr ""
#~ "    -a  Экспортировать переменные, которые изменялись или создавались."

#~ msgid "    -b  Notify of job termination immediately."
#~ msgstr "    -b  Немедленно выводить сообщения о завершении задач."

#~ msgid "    -e  Exit immediately if a command exits with a non-zero status."
#~ msgstr "    -e  Завершить работу, если команд возврата команды не равен 0."

#~ msgid "    -f  Disable file name generation (globbing)."
#~ msgstr "    -f  Прекратить расширение имён файлов (globbing)."

#~ msgid "    -h  Remember the location of commands as they are looked up."
#~ msgstr "    -h  Запоминать расположение обработанных команд."

#~ msgid ""
#~ "    -i  Force the shell to be an \"interactive\" one.  Interactive shells"
#~ msgstr "    -i  Сделать оболочку \"интерактивной\". Интерактивные оболочки"

#~ msgid "        always read `~/.bashrc' on startup."
#~ msgstr "        читают `~/.bashrc' при каждом запуске."

#~ msgid "    -k  All assignment arguments are placed in the environment for a"
#~ msgstr "    -k  В среду команды помещаются все аргументы присваивания,"

#~ msgid "        command, not just those that precede the command name."
#~ msgstr "        а не только предшествующие её имени."

#~ msgid "    -m  Job control is enabled."
#~ msgstr "    -m  Включить управление задачами."

#~ msgid "    -n  Read commands but do not execute them."
#~ msgstr "    -n  Считывать команды, но не выполнять их."

#~ msgid "    -o option-name"
#~ msgstr "    -o имя_параметра"

#~ msgid "        Set the variable corresponding to option-name:"
#~ msgstr "        Установить режим в соответствии с заданным именем:"

#~ msgid "            allexport    same as -a"
#~ msgstr "            allexport    то же, что -a"

#~ msgid "            braceexpand  same as -B"
#~ msgstr "            braceexpand  то же, что -B"

#~ msgid "            emacs        use an emacs-style line editing interface"
#~ msgstr ""
#~ "            emacs        использовать стиль редактирования строк emacs"

#~ msgid "            errexit      same as -e"
#~ msgstr "            errexit      то же, что -e"

#~ msgid "            hashall      same as -h"
#~ msgstr "            hashall      то же, что -h"

#~ msgid "            histexpand   same as -H"
#~ msgstr "            histexpand   то же, что -H"

#~ msgid "            ignoreeof    the shell will not exit upon reading EOF"
#~ msgstr "            ignoreeof    при чтении EOF оболочка не завершит работу"

#~ msgid "            interactive-comments"
#~ msgstr "            interactive-comments"

#~ msgid ""
#~ "                         allow comments to appear in interactive commands"
#~ msgstr ""
#~ "                        допускает комментарии в интерактивных командах"

#~ msgid "            keyword      same as -k"
#~ msgstr "            keyword      то же, что -k"

#~ msgid "            monitor      same as -m"
#~ msgstr "            monitor      то же, что -m"

#~ msgid "            noclobber    same as -C"
#~ msgstr "            noclobber    то же, что -C"

#~ msgid "            noexec       same as -n"
#~ msgstr "            noexec       то же, что -n"

#~ msgid "            noglob       same as -f"
#~ msgstr "            noglob       то же, что -f"

#~ msgid "            notify       save as -b"
#~ msgstr "            notify       то же, что -b"

#~ msgid "            nounset      same as -u"
#~ msgstr "            nounset      то же, что -u"

#~ msgid "            onecmd       same as -t"
#~ msgstr "            onecmd       то же, что -t"

#~ msgid "            physical     same as -P"
#~ msgstr "            physical     то же, что -P"

#~ msgid ""
#~ "            posix        change the behavior of bash where the default"
#~ msgstr "            posix        привести поведение bash, по умолчанию не"

#~ msgid ""
#~ "                         operation differs from the 1003.2 standard to"
#~ msgstr "                        соответствующее стандарту 1003.2, в"

#~ msgid "                         match the standard"
#~ msgstr "                        соответствие с ним"

#~ msgid "            privileged   same as -p"
#~ msgstr "            privileged   то же, что -p"

#~ msgid "            verbose      same as -v"
#~ msgstr "            verbose      то же, что -v"

#~ msgid "            vi           use a vi-style line editing interface"
#~ msgstr "            vi           использовать стиль редактирования строк vi"

#~ msgid "            xtrace       same as -x"
#~ msgstr "            xtrace       то же, что -x"

#~ msgid ""
#~ "    -p  Turned on whenever the real and effective user ids do not match."
#~ msgstr ""
#~ "    -p  Если реальный и эффективный uid не совпадают, включается всегда."

#~ msgid "        Disables processing of the $ENV file and importing of shell"
#~ msgstr "        Отключает обработку файла $ENV и импорт функций оболочки."

#~ msgid ""
#~ "        functions.  Turning this option off causes the effective uid and"
#~ msgstr ""
#~ "        При выключении этого параметра эффективные uid и gid становятся"

#~ msgid "        gid to be set to the real uid and gid."
#~ msgstr "        равными реальным."

#~ msgid "    -t  Exit after reading and executing one command."
#~ msgstr "    -t  Завершить работу после чтения и выполнения одной команды."

#~ msgid "    -u  Treat unset variables as an error when substituting."
#~ msgstr ""
#~ "    -u  При подстановке считать не установленные переменные ошибками."

#~ msgid "    -v  Print shell input lines as they are read."
#~ msgstr "    -v  Выводить прочитанные строки входного текста оболочки."

#~ msgid "    -x  Print commands and their arguments as they are executed."
#~ msgstr "    -x  Выводить по мере исполнения команд и их аргументы."

#~ msgid "    -B  the shell will perform brace expansion"
#~ msgstr "    -B  оболочка будет производить подстановку скобок"

#~ msgid "    -H  Enable ! style history substitution.  This flag is on"
#~ msgstr "    -H  Включить !-стиль подстановки истории. Включено"

#~ msgid "        by default."
#~ msgstr "        по умолчанию."

#~ msgid "    -C  If set, disallow existing regular files to be overwritten"
#~ msgstr "    -C  Если установлен, запретить перезапись существующих"

#~ msgid "        by redirection of output."
#~ msgstr "        обычных файлов при перенаправлении вывода."

#~ msgid "    -P  If set, do not follow symbolic links when executing commands"
#~ msgstr ""
#~ "    -P  Не следовать символическим ссылкам при выполнении таких команд,"

#~ msgid "        such as cd which change the current directory."
#~ msgstr "        как cd, т.е. изменяющих текущий каталог."

#~ msgid "Using + rather than - causes these flags to be turned off.  The"
#~ msgstr "Использование + вместо - отключает флаг. Эти флаги могут также"

#~ msgid "flags can also be used upon invocation of the shell.  The current"
#~ msgstr ""
#~ "использоваться при запуске оболочки. Текущий набор флагов содержится"

#~ msgid ""
#~ "set of flags may be found in $-.  The remaining n ARGs are positional"
#~ msgstr "в $-. Остальные n аргументов -- позиционные параметры, и им, по"

#~ msgid "parameters and are assigned, in order, to $1, $2, .. $n.  If no"
#~ msgstr "порядку, присваиваются значения $1, $2, ..., $n. Если аргументы"

#~ msgid "ARGs are given, all shell variables are printed."
#~ msgstr "не заданы, выводятся все переменные оболочки."

#~ msgid "For each NAME, remove the corresponding variable or function.  Given"
#~ msgstr "Для каждого ИМЕНИ удаляет соответствующую переменную или функцию."

#~ msgid "the `-v', unset will only act on variables.  Given the `-f' flag,"
#~ msgstr ""
#~ "Если задано -v, unset влияет только на переменные, если -f -- только"

#~ msgid "unset will only act on functions.  With neither flag, unset first"
#~ msgstr "на функции. Без флагов unset в первую очередь пытается удалить"

#~ msgid "tries to unset a variable, and if that fails, then tries to unset a"
#~ msgstr "переменную, если это не удаётся -- функцию. Некоторые переменные"

#~ msgid ""
#~ "function.  Some variables (such as PATH and IFS) cannot be unset; also"
#~ msgstr "(такие как PATH и IFS) не могут быть удалены. См."

#~ msgid "see readonly."
#~ msgstr "также readonly."

#~ msgid "NAMEs are marked for automatic export to the environment of"
#~ msgstr "ИМЕНА автоматически экспортируются в среду выполняемых"

#~ msgid "subsequently executed commands.  If the -f option is given,"
#~ msgstr "впоследствии команд. Если задан параметр -f, ИМЕНА"

#~ msgid "the NAMEs refer to functions.  If no NAMEs are given, or if `-p'"
#~ msgstr "обозначают функции. Если ИМЕНа не заданы, или если задано -p,"

#~ msgid "is given, a list of all names that are exported in this shell is"
#~ msgstr "выводится список всех имён, экспортированных в эту оболочку."

#~ msgid "printed.  An argument of `-n' says to remove the export property"
#~ msgstr "Аргумент -n указывает убрать заданные имена из списка"

#~ msgid "from subsequent NAMEs.  An argument of `--' disables further option"
#~ msgstr "экспортируемых.  Аргумент -- отключает дальнейшую обработку"

#~ msgid "processing."
#~ msgstr "параметров."

#~ msgid ""
#~ "The given NAMEs are marked readonly and the values of these NAMEs may"
#~ msgstr ""
#~ "Заданные ИМЕНА помечаются только для чтения, и значения этих ИМЁН не"

#~ msgid "not be changed by subsequent assignment.  If the -f option is given,"
#~ msgstr ""
#~ "могут изменяться в последующих присваиваниях. Если задан параметр -f,"

#~ msgid "then functions corresponding to the NAMEs are so marked.  If no"
#~ msgstr "так помечаются функции с соответствующими ИМЕНАМИ. Если аргументы"

#~ msgid ""
#~ "arguments are given, or if `-p' is given, a list of all readonly names"
#~ msgstr "не заданы, или если задано `-p', выводится список имён только для"

#~ msgid ""
#~ "is printed.  An argument of `-n' says to remove the readonly property"
#~ msgstr "чтения.  Аргумент `-n' указывает снять свойство `только для чтения'"

#~ msgid "from subsequent NAMEs.  The `-a' option means to treat each NAME as"
#~ msgstr "с указанных ИМЁН. Параметр `-a' заставляет рассматривать каждое ИМЯ"

#~ msgid "an array variable.  An argument of `--' disables further option"
#~ msgstr "как массив.  Аргумент `--' прекращает дальнейшую обработку"

#~ msgid ""
#~ "The positional parameters from $N+1 ... are renamed to $1 ...  If N is"
#~ msgstr ""
#~ "Позиционные параметры начиная с $N+1 переобозначаются как $1,... Если"

#~ msgid "not given, it is assumed to be 1."
#~ msgstr "N не задано, оно предполагается равным 1."

#~ msgid "Read and execute commands from FILENAME and return.  The pathnames"
#~ msgstr "Читает и выполняет команды из файла с заданным именем и завершает"

#~ msgid "in $PATH are used to find the directory containing FILENAME."
#~ msgstr "работу. Файл ищется в каталогах, перечисленных в $PATH."

#~ msgid "Suspend the execution of this shell until it receives a SIGCONT"
#~ msgstr "Приостанавливает работу оболочки до получения сигнала"

#~ msgid "signal.  The `-f' if specified says not to complain about this"
#~ msgstr "SIGCONT.  `-f', если задан, указывает приостановить работу, даже"

#~ msgid "being a login shell if it is; just suspend anyway."
#~ msgstr "если это оболочка сессии"

#~ msgid "Exits with a status of 0 (trueness) or 1 (falseness) depending on"
#~ msgstr "Завершает работу со статусом 0 (истина) или 1 (ложь) в зависимости"

#~ msgid "the evaluation of EXPR.  Expressions may be unary or binary.  Unary"
#~ msgstr "от значения ВЫРАЖЕНИЯ. Выражения могут быть унарными или бинарными."

#~ msgid "expressions are often used to examine the status of a file.  There"
#~ msgstr "Унарные выражения часто используются для проверки состояния файла."

#~ msgid "are string operators as well, and numeric comparison operators."
#~ msgstr "Допустимы операции как строкового, так и численного сравнения."

#~ msgid "File operators:"
#~ msgstr "Файловые операции:"

#~ msgid "    -b FILE        True if file is block special."
#~ msgstr "    -b ФАЙЛ        Истина, если файл -- специальный блочный файл."

#~ msgid "    -c FILE        True if file is character special."
#~ msgstr ""
#~ "    -c ФАЙл        Истина, если файл -- специальный символьный файл."

#~ msgid "    -d FILE        True if file is a directory."
#~ msgstr "    -d ФАЙЛ        Истина, если файл -- каталог."

#~ msgid "    -e FILE        True if file exists."
#~ msgstr "    -e ФАЙЛ        Истина, если файл существует."

#~ msgid "    -f FILE        True if file exists and is a regular file."
#~ msgstr ""
#~ "    -f ФАЙЛ        Истина, если файл существует и является обычным файлом."

#~ msgid "    -g FILE        True if file is set-group-id."
#~ msgstr "    -g ФАЙЛ        Истина, если у файла установлен атрибут SGID."

#~ msgid "    -h FILE        True if file is a symbolic link.  Use \"-L\"."
#~ msgstr ""
#~ "    -h ФАЙЛ        Истина, если файл -- символическая ссылка. Используйте "
#~ "\"-L\"."

#~ msgid "    -L FILE        True if file is a symbolic link."
#~ msgstr "    -L ФАЙЛ        Истина, если файл -- символическая ссылка."

#~ msgid "    -k FILE        True if file has its \"sticky\" bit set."
#~ msgstr ""
#~ "    -k ФАЙЛ        Истина, если у файла устанолвен \"бит привязчивости\"."

#~ msgid "    -p FILE        True if file is a named pipe."
#~ msgstr "    -p ФАЙЛ        Истина, если файл -- именованный канал."

#~ msgid "    -r FILE        True if file is readable by you."
#~ msgstr "    -r ФАЙЛ        Истина, если файл доступен вам для чтения."

#~ msgid "    -s FILE        True if file exists and is not empty."
#~ msgstr "    -s ФАЙЛ        Истина, если файл существует и не пуст."

#~ msgid "    -S FILE        True if file is a socket."
#~ msgstr "    -S ФАЙЛ        Истина, если файл -- сокет."

#~ msgid "    -t FD          True if FD is opened on a terminal."
#~ msgstr ""
#~ "    -t FD          Истина, если файл с дескриптором FD связан с "
#~ "терминалом."

#~ msgid "    -u FILE        True if the file is set-user-id."
#~ msgstr "    -u ФАЙЛ        Истина, если у файла установлен атрибут SUID."

#~ msgid "    -w FILE        True if the file is writable by you."
#~ msgstr "    -w ФАЙЛ        Истина, если файл доступен вам для записи"

#~ msgid "    -x FILE        True if the file is executable by you."
#~ msgstr "    -x ФАЙЛ        Истина, если файл доступен вам для выполнения."

#~ msgid "    -O FILE        True if the file is effectively owned by you."
#~ msgstr "    -O ФАЙЛ        Истина, если вы -- эффективный владелец файла."

#~ msgid ""
#~ "    -G FILE        True if the file is effectively owned by your group."
#~ msgstr ""
#~ "    -G ФАЙЛ        Истина, если ваша группа -- эффективная группа файла."

#~ msgid "  FILE1 -nt FILE2  True if file1 is newer than (according to"
#~ msgstr ""
#~ "  ФАЙЛ1 -nt ФАЙЛ2  Истина, если файл1 более новый (по дате последнего"

#~ msgid "                   modification date) file2."
#~ msgstr "                   изменения), чем файл2."

#~ msgid "  FILE1 -ot FILE2  True if file1 is older than file2."
#~ msgstr "  ФАЙЛ1 -ot ФАЙЛ2  Истина, если файл1 более старый, чем файл2."

#~ msgid "  FILE1 -ef FILE2  True if file1 is a hard link to file2."
#~ msgstr "  ФАЙЛ1 -ef ФАЙЛ2  Истина, если файл1 -- жёсткая ссылка на файл2."

#~ msgid "String operators:"
#~ msgstr "Строковые операции:"

#~ msgid "    -z STRING      True if string is empty."
#~ msgstr "    -z СТРОКА      Истина, если строка пуста."

#~ msgid "    -n STRING"
#~ msgstr "    -n СТРОКА"

#~ msgid "    STRING         True if string is not empty."
#~ msgstr "    СТРОКА         Истина, если стркоа не пуста."

#~ msgid "    STRING1 = STRING2"
#~ msgstr "    СТРОКА1 = СТРОКА2"

#~ msgid "                   True if the strings are equal."
#~ msgstr "                   Истина, если строки равны."

#~ msgid "    STRING1 != STRING2"
#~ msgstr "    СТРОКА1 != СТРОКА2"

#~ msgid "                   True if the strings are not equal."
#~ msgstr "                   Истина, если строки не равны."

#~ msgid "    STRING1 < STRING2"
#~ msgstr "    СТРОКА1 < СТРОКА2"

#~ msgid ""
#~ "                   True if STRING1 sorts before STRING2 lexicographically"
#~ msgstr ""
#~ "                   Истина, если СТРОКА1 лексикографически стоит раньше "
#~ "СТРОКИ2"

#~ msgid "    STRING1 > STRING2"
#~ msgstr "    СТРОКА1 > СТРОКА2"

#~ msgid ""
#~ "                   True if STRING1 sorts after STRING2 lexicographically"
#~ msgstr ""
#~ "                   Истина, если СТРОКА1 лексикографически стоит позже "
#~ "СТРОКИ2"

#~ msgid "Other operators:"
#~ msgstr "Прочие операции:"

#~ msgid "    ! EXPR         True if expr is false."
#~ msgstr "    ! ВЫРАЖЕНИЕ    Истина, если выражение ложно."

#~ msgid "    EXPR1 -a EXPR2 True if both expr1 AND expr2 are true."
#~ msgstr "    ВЫР1 -a ВЫР2   Истина, если истинны оба выражения."

#~ msgid "    EXPR1 -o EXPR2 True if either expr1 OR expr2 is true."
#~ msgstr "    ВЫР1 -o ВЫР2   Истина, если истинно хотя бы одно из выражений."

#~ msgid "    arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,"
#~ msgstr "    арг1 ОП арг2   Арифметическая проверка. ОП -- один из -eq, -ne,"

#~ msgid "                   -lt, -le, -gt, or -ge."
#~ msgstr "                   -lt, -le, -gt или -ge."

#~ msgid "Arithmetic binary operators return true if ARG1 is equal, not-equal,"
#~ msgstr ""
#~ "Бинарные арифметические операции возвращают истину, если АРГ1 равен,"

#~ msgid ""
#~ "less-than, less-than-or-equal, greater-than, or greater-than-or-equal"
#~ msgstr "не равен, меньше, меньше или равен, больше или больше или равен"

#~ msgid "than ARG2."
#~ msgstr "АРГ2."

#~ msgid "This is a synonym for the \"test\" builtin, but the last"
#~ msgstr "Это синоним встроенной команды \"test\", но последним аргументом"

#~ msgid "argument must be a literal `]', to match the opening `['."
#~ msgstr "должен быть литерал ']'. соответствующий открывающей `['."

#~ msgid "Print the accumulated user and system times for processes run from"
#~ msgstr "Вывести пользовательское и системное время работы процессов,"

#~ msgid "the shell."
#~ msgstr "запущенных из оболочки."

#~ msgid "The command ARG is to be read and executed when the shell receives"
#~ msgstr ""
#~ "Команда АРГ должна быть прочитана и выполнена при получении оболочкой"

#~ msgid "signal(s) SIGNAL_SPEC.  If ARG is absent all specified signals are"
#~ msgstr ""
#~ "указанного(ых) сигнала(ов). Если АРГ не задан, все указанные сигналы"

#~ msgid "reset to their original values.  If ARG is the null string each"
#~ msgstr ""
#~ "обрабатываются обработчиками по умолчанию. Если АРГ -- пустая строка,"

#~ msgid "SIGNAL_SPEC is ignored by the shell and by the commands it invokes."
#~ msgstr ""
#~ "все указанные сигналы будут игнорироваться оболочкой и вызываемыми ей"

#~ msgid "If SIGNAL_SPEC is EXIT (0) the command ARG is executed on exit from"
#~ msgstr "командами. Если задан сигнал EXIT (0), команда АРГ выполняется при"

#~ msgid "the shell.  If SIGNAL_SPEC is DEBUG, ARG is executed after every"
#~ msgstr ""
#~ "выходе из оболочки, если DEBUG, АРГ выполняется при выполнении каждой"

#~ msgid "command.  If ARG is `-p' then the trap commands associated with"
#~ msgstr "команды. Если АРГ -- `-p', выводятся команды, связанные с заданными"

#~ msgid "each SIGNAL_SPEC are displayed.  If no arguments are supplied or if"
#~ msgstr "сигналами. Если аргументы не заданы или если задано только `-p',"

#~ msgid "only `-p' is given, trap prints the list of commands associated with"
#~ msgstr "trap выводит список команд, связанных со всеми сигналами. Сигнал"

#~ msgid ""
#~ "each signal number.  SIGNAL_SPEC is either a signal name in <signal.h>"
#~ msgstr "задаётся либо своим именем в <signal.h>, либо номером. `trap -l'"

#~ msgid ""
#~ "or a signal number.  `trap -l' prints a list of signal names and their"
#~ msgstr "выводит список имён сигналов и соответствующих им номеров."

#~ msgid "corresponding numbers.  Note that a signal can be sent to the shell"
#~ msgstr "Заметьте, что оболочке можно послать сигнал командой"

#~ msgid "with \"kill -signal $$\"."
#~ msgstr "\"kill -signal $$\"."

#~ msgid "For each NAME, indicate how it would be interpreted if used as a"
#~ msgstr "Для каждого ИМЕНИ определяет, как оно будет обрабатываться"

#~ msgid "If the -t option is used, returns a single word which is one of"
#~ msgstr "Если задан параметр -t, возвращает слово -- `alias', `keyword',"

#~ msgid ""
#~ "`alias', `keyword', `function', `builtin', `file' or `', if NAME is an"
#~ msgstr "`function', `builtin', `file' или `' -- если, соответственно, ИМЯ"

#~ msgid ""
#~ "alias, shell reserved word, shell function, shell builtin, disk file,"
#~ msgstr "является псевдокомандой, зарезервированным словом, функцией, или"

#~ msgid "or unfound, respectively."
#~ msgstr "встроенной командой оболочки, дисковым файлом или не найдено."

#~ msgid "If the -p flag is used, either returns the name of the disk file"
#~ msgstr ""
#~ "При использовании флага -p либо возвращается имя выполняемого дискового "
#~ "файла,"

#~ msgid "that would be executed, or nothing if -t would not return `file'."
#~ msgstr "либо ничего, если -t вернуло бы значение, отличное от  `file'"

#~ msgid "If the -a flag is used, displays all of the places that contain an"
#~ msgstr ""
#~ "При использовании флага -a выводится расположение всех исполняемых файлов"

#~ msgid ""
#~ "executable named `file'.  This includes aliases and functions, if and"
#~ msgstr ""
#~ "с указанным именем. Если одновременно не используется флаг -p и только"

#~ msgid "only if the -p flag is not also used."
#~ msgstr "тогда, выводятся также псевдокоманды и функции."

#~ msgid "Type accepts -all, -path, and -type in place of -a, -p, and -t,"
#~ msgstr "Вместо -a, -p и -t можно использовать, соответственно, -all,"

#~ msgid "respectively."
#~ msgstr "-path и -type."

#~ msgid "Ulimit provides control over the resources available to processes"
#~ msgstr "ulimit позволяет управлять ресурсами, доступными запущенным"

#~ msgid "started by the shell, on systems that allow such control.  If an"
#~ msgstr "оболочкой процессам (на системах, допускающих такое управление)."

#~ msgid "option is given, it is interpreted as follows:"
#~ msgstr "Параметры интерпретируются следующим образом:"

#~ msgid "    -S\tuse the `soft' resource limit"
#~ msgstr "    -S\tиспользовать `мягкое' ограничение ресурсов"

#~ msgid "    -H\tuse the `hard' resource limit"
#~ msgstr "    -H\tиспользовать `жёсткое' ограничение ресурсов"

#~ msgid "    -a\tall current limits are reported"
#~ msgstr "    -a\tвывести информацию о всех текущих ограничениях"

#~ msgid "    -c\tthe maximum size of core files created"
#~ msgstr "    -c\tмаксимальный размер создаваемых файлов слепков памяти"

#~ msgid "    -d\tthe maximum size of a process's data segment"
#~ msgstr "    -d\tмаксимальный размер сегмента данных процесса"

#~ msgid "    -m\tthe maximum resident set size"
#~ msgstr "    -m\tмаксимальный размер резидентной части процесса"

#~ msgid "    -s\tthe maximum stack size"
#~ msgstr "    -s\tмаксимальный размер стека"

#~ msgid "    -t\tthe maximum amount of cpu time in seconds"
#~ msgstr "    -t\tмаксимальное процессорное время (в секундах)"

#~ msgid "    -f\tthe maximum size of files created by the shell"
#~ msgstr "    -f\tмаксимальный размер создаваемых оболочкой файлов"

#~ msgid "    -p\tthe pipe buffer size"
#~ msgstr "    -p\tразмер буфера конвейера"

#~ msgid "    -n\tthe maximum number of open file descriptors"
#~ msgstr "    -n\tмаксимальное количество открытых файловых дексрипторов"

#~ msgid "    -u\tthe maximum number of user processes"
#~ msgstr "    -u\tмаксимальное число процессов одного пользователя"

#~ msgid "    -v\tthe size of virtual memory"
#~ msgstr "    -v\tразмер виртуальной памяти"

#~ msgid "If LIMIT is given, it is the new value of the specified resource."
#~ msgstr ""
#~ "Если задано ОГРАНИЧЕНИЕ, оно задёт новое значение для указанного ресурса."

#~ msgid "Otherwise, the current value of the specified resource is printed."
#~ msgstr ""
#~ "В противном случае выводится текущее значение для указанного ресурса."

#~ msgid "If no option is given, then -f is assumed.  Values are in 1k"
#~ msgstr "Если параметры не заданы, предполагается, что задано -f. Значения"

#~ msgid "increments, except for -t, which is in seconds, -p, which is in"
#~ msgstr ""
#~ "измеряются в КБ, кроме -t, измеряемого в секундах, -p, единица измерения"

#~ msgid "increments of 512 bytes, and -u, which is an unscaled number of"
#~ msgstr "которого -- 512 байтов, и -u, задающего безразмерное число"

#~ msgid "processes."
#~ msgstr "процессов."

#~ msgid ""
#~ "The user file-creation mask is set to MODE.  If MODE is omitted, or if"
#~ msgstr ""
#~ "Устанавливает маску создания пользователем файлов в РЕЖИМ. Если опущен"

#~ msgid ""
#~ "`-S' is supplied, the current value of the mask is printed.  The `-S'"
#~ msgstr ""
#~ "РЕЖИМ или задан параметр -S выводится текущее значение маски. Параметр"

#~ msgid ""
#~ "option makes the output symbolic; otherwise an octal number is output."
#~ msgstr "-S делает вывод символическим, в противном случае используется"

#~ msgid "If MODE begins with a digit, it is interpreted as an octal number,"
#~ msgstr ""
#~ "восьмеричое число. Если РЕЖИм начинается с цифры, он интерпретируется"

#~ msgid ""
#~ "otherwise it is a symbolic mode string like that accepted by chmod(1)."
#~ msgstr ""
#~ "как восьмеричное число, в противном случае как строка, принимаемая "
#~ "chmod(1)."

#~ msgid ""
#~ "Wait for the specified process and report its termination status.  If"
#~ msgstr ""
#~ "Подождать завершения указанного процесса и сообщить код завершения. Если"

#~ msgid "N is not given, all currently active child processes are waited for,"
#~ msgstr ""
#~ "N не задано, ожидается завершение работы всех активных дочерних процессов"

#~ msgid "and the return code is zero.  N may be a process ID or a job"
#~ msgstr "и код возврата равен 0. N может быть идентификатором процесса"

#~ msgid "specification; if a job spec is given, all processes in the job's"
#~ msgstr ""
#~ "или спецификацией задачи, если задана спецификация задачи, ожидается"

#~ msgid "pipeline are waited for."
#~ msgstr "завершение работы всех процессов конвейера задачи."

#~ msgid "and the return code is zero.  N is a process ID; if it is not given,"
#~ msgstr ""
#~ "и код возврата равен 0. N -- идентификатор процесса, если он не задан,"

#~ msgid "all child processes of the shell are waited for."
#~ msgstr "ожидается завершение работы всех дочерних процессов оболочки."

#~ msgid "The `for' loop executes a sequence of commands for each member in a"
#~ msgstr "Цикл `for' выполняет последовательность команд для каждого члена"

#~ msgid ""
#~ "list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is"
#~ msgstr ""
#~ "списка. Если отсутствует `in СЛОВА ...;', предполагается, что задано"

#~ msgid ""
#~ "assumed.  For each element in WORDS, NAME is set to that element, and"
#~ msgstr "`in \"$@\"'. Для каждого из СЛОВ ИМЕНИ присваивается его значение"

#~ msgid "the COMMANDS are executed."
#~ msgstr "и затем выполняются КОМАНДЫ."

#~ msgid "The WORDS are expanded, generating a list of words.  The"
#~ msgstr "СЛОВА разворачиваются и образуют список слов. Полученный список"

#~ msgid "set of expanded words is printed on the standard error, each"
#~ msgstr ""
#~ "выводится на стандартный поток ошибок, каждому приписывается спереди"

#~ msgid "preceded by a number.  If `in WORDS' is not present, `in \"$@\"'"
#~ msgstr "число. Если `in СЛОВА' отсутствует, предполагается заданным"

#~ msgid "is assumed.  The PS3 prompt is then displayed and a line read"
#~ msgstr ""
#~ "`in \"$@\"'. Затем выводится приглашение PS3 и со стандартного ввода"

#~ msgid "from the standard input.  If the line consists of the number"
#~ msgstr "считывается строка. Если строка состоит из числа, соответствующего"

#~ msgid "corresponding to one of the displayed words, then NAME is set"
#~ msgstr "одному из выведенных слов, ИМЯ устанавливается равным этому"

#~ msgid "to that word.  If the line is empty, WORDS and the prompt are"
#~ msgstr "слову. Если строка пуста, слова и приглашение выводятся ещё раз."

#~ msgid "redisplayed.  If EOF is read, the command completes.  Any other"
#~ msgstr "Если прочитан символ конца файла, выполнение команды завершается."

#~ msgid "value read causes NAME to be set to null.  The line read is saved"
#~ msgstr "любое другое значение устанавливает ИМЯ в NULL. Прочитанная строка"

#~ msgid "in the variable REPLY.  COMMANDS are executed after each selection"
#~ msgstr "сохраняется в переменной REPLY. После каждого выбора выполняются"

#~ msgid "until a break or return command is executed."
#~ msgstr ""
#~ "КОМАНДЫ до тех пор, пока не будет выполнена команда break или return."

#~ msgid "Selectively execute COMMANDS based upon WORD matching PATTERN.  The"
#~ msgstr ""
#~ "Выполняет КОМАНДЫ в зависимости от того, какому ШАБЛОНУ соответствует"

#~ msgid "`|' is used to separate multiple patterns."
#~ msgstr ""
#~ "СЛОВО. Для разделения нескольких допустимых шаблонов используется `|'."

#~ msgid ""
#~ "The if COMMANDS are executed.  If the exit status is zero, then the then"
#~ msgstr ""
#~ "Выполняются КОМАНДЫ, заданные в if. Если код возврата нулевой, выполняются"

#~ msgid ""
#~ "COMMANDS are executed.  Otherwise, each of the elif COMMANDS are executed"
#~ msgstr "КОМАНДЫ then, иначе по очереди выполняются КОМАНДЫ elif, и если код"

#~ msgid ""
#~ "in turn, and if the exit status is zero, the corresponding then COMMANDS"
#~ msgstr ""
#~ "возврата нулевой, выполняются соответствующие КОМАНДЫ then и выполнение"

#~ msgid ""
#~ "are executed and the if command completes.  Otherwise, the else COMMANDS"
#~ msgstr ""
#~ "команды if завершается. В противном случае выполняются КОМАНДЫ else,"

#~ msgid ""
#~ "are executed, if present.  The exit status is the exit status of the last"
#~ msgstr "если они присутствуют. Код возврата равен коду возврата последней"

#~ msgid "command executed, or zero if no condition tested true."
#~ msgstr ""
#~ "выполненной команды, либо нулю, если ни одно условие не было истинным."

#~ msgid "Expand and execute COMMANDS as long as the final command in the"
#~ msgstr ""
#~ "Разворачивает и выполняет КОМАНДЫ до тех пор, пока последняя команда"

#~ msgid "`while' COMMANDS has an exit status of zero."
#~ msgstr "предложения `while' не завершит работу с нулевым кодом возврата."

#~ msgid "`until' COMMANDS has an exit status which is not zero."
#~ msgstr "предложения `until' не завершит работу с ненулевым кодом возврата."

#~ msgid "Create a simple command invoked by NAME which runs COMMANDS."
#~ msgstr "Создаёт простую команду, вызываемую по ИМЕНИ и выполняющую КОМАНДЫ."

#~ msgid "Arguments on the command line along with NAME are passed to the"
#~ msgstr "Аргументы командной строки, переданные ИМЕНИ, передаются в функцию"

#~ msgid "function as $0 .. $n."
#~ msgstr "как $0 .. $n."

#~ msgid "Run a set of commands in a group.  This is one way to redirect an"
#~ msgstr "Выполняет набор команд. Это один из способов осуществить"

#~ msgid "entire set of commands."
#~ msgstr "перенаправление для целого набора команд."

#~ msgid "This is similar to the `fg' command.  Resume a stopped or background"
#~ msgstr ""
#~ "Похоже на команду `fg'. Продолжает выполнение остановленной или фоновой"

#~ msgid "job.  If you specifiy DIGITS, then that job is used.  If you specify"
#~ msgstr ""
#~ "задачи. Если заданы ЦИФРЫ, использяется задача с этим номером, а если"

#~ msgid ""
#~ "WORD, then the job whose name begins with WORD is used.  Following the"
#~ msgstr "СЛОВО -- задача, имя которой начинается с этого слова. Завершение"

#~ msgid "job specification with a `&' places the job in the background."
#~ msgstr "спецификации задачи символом & переводит задачу в фоновый режим."

#~ msgid "BASH_VERSION    The version numbers of this Bash."
#~ msgstr "BASH_VERSION    Номер версии Bash."

#~ msgid "CDPATH          A colon separated list of directories to search"
#~ msgstr "CDPATH          Разделённый запятыми список каталогов, где ищется"

#~ msgid "\t\twhen the argument to `cd' is not found in the current"
#~ msgstr "\t\tаргумент команды `cd', если он не найден в текущем"

#~ msgid ""
#~ "HISTFILE        The name of the file where your command history is stored."
#~ msgstr "HISTFILE        Имя файла, где сохраняется история команд."

#~ msgid "HISTFILESIZE    The maximum number of lines this file can contain."
#~ msgstr "HISTFILESIZE    Максимальное число строк в этом файле."

#~ msgid "HISTSIZE        The maximum number of history lines that a running"
#~ msgstr "HISTSIZE        Максимальное число строк истории команд, к которым"

#~ msgid "\t\tshell can access."
#~ msgstr "\t\tимеет доступ оболочка."

#~ msgid "HOME            The complete pathname to your login directory."
#~ msgstr "HOME            Полный путь к домашнему каталогу."

#~ msgid ""
#~ "HOSTTYPE        The type of CPU this version of Bash is running under."
#~ msgstr ""
#~ "HOSTTYPE        Тип процессора, на котором работает эта версия Bash."

#~ msgid ""
#~ "IGNOREEOF       Controls the action of the shell on receipt of an EOF"
#~ msgstr ""
#~ "IGNOREEOF       Управляет действиями, совершаемыми оболочкой при вводе"

#~ msgid "\t\tcharacter as the sole input.  If set, then the value"
#~ msgstr "\t\tсимвола конца файла. Если установлена, её значение -- число"

#~ msgid "\t\tof it is the number of EOF characters that can be seen"
#~ msgstr "\t\tсимволов конца файла, которые могут быть встречены подряд,"

#~ msgid "\t\tin a row on an empty line before the shell will exit"
#~ msgstr "\t\tв пустой строке, после чего оболочка завершит работу"

#~ msgid "\t\t(default 10).  When unset, EOF signifies the end of input."
#~ msgstr ""
#~ "\t\t(по умолчанию 10). Если не установлена, EOF обозначает конец ввода."

#~ msgid "MAILCHECK\tHow often, in seconds, Bash checks for new mail."
#~ msgstr ""
#~ "MAILCHECK\tКак часто, в секундах, Bash проверяет наличие новой почты."

#~ msgid "MAILPATH\tA colon-separated list of filenames which Bash checks"
#~ msgstr "MAILPATH\tРазделённый запятыми список имён файлов, где Bash"

#~ msgid "\t\tfor new mail."
#~ msgstr "\t\tпроверяет наличие новой почты."

#~ msgid "OSTYPE\t\tThe version of Unix this version of Bash is running on."
#~ msgstr "OSTYPE\t\tВерсия Unix, под которой работает эта версия Bash."

#~ msgid "PATH            A colon-separated list of directories to search when"
#~ msgstr "PATH            Разделённый запятыми список каталогов, где ищутся"

#~ msgid "\t\tlooking for commands."
#~ msgstr "\t\tкоманды."

#~ msgid "PROMPT_COMMAND  A command to be executed before the printing of each"
#~ msgstr "PROMPT_COMMAND  Команда, выполняемая перед выводом каждого"

#~ msgid "\t\tprimary prompt."
#~ msgstr "\t\tпервичного приглашения."

#~ msgid "PS1             The primary prompt string."
#~ msgstr "PS1             Строка первичного приглашения."

#~ msgid "PS2             The secondary prompt string."
#~ msgstr "PS2             Строка вторичного приглашения."

#~ msgid "TERM            The name of the current terminal type."
#~ msgstr "TERM            Имя типа текущего терминала."

#~ msgid "auto_resume     Non-null means a command word appearing on a line by"
#~ msgstr ""
#~ "auto_resume     Ненулевые значения слов команд, встречающиеся в строке"

#~ msgid "\t\titself is first looked for in the list of currently"
#~ msgstr "\t\tотдельно, сначала ищутся в списке остановленных"

#~ msgid "\t\tstopped jobs.  If found there, that job is foregrounded."
#~ msgstr "\t\tв данный момент задач. Если найдено, задача активируется."

#~ msgid "\t\tA value of `exact' means that the command word must"
#~ msgstr "\t\t`exact' значит, что команда должна в точности"

#~ msgid "\t\texactly match a command in the list of stopped jobs.  A"
#~ msgstr "\t\tсоответствовать команде в списке остановленных задач."

#~ msgid "\t\tvalue of `substring' means that the command word must"
#~ msgstr "\t\t`substring' значит, что команда должна быть подстрокой"

#~ msgid "\t\tmatch a substring of the job.  Any other value means that"
#~ msgstr "\t\tзадачи. Любые другие значения означают, что"

#~ msgid "\t\tthe command must be a prefix of a stopped job."
#~ msgstr "\t\tкоманда должна быть префиксом остановленной задачи."

#~ msgid "command_oriented_history"
#~ msgstr "command_oriented_history"

#~ msgid ""
#~ "                Non-null means to save multiple-line commands together on"
#~ msgstr ""
#~ "                Ненулевое значение означает, что многострочные команды"

#~ msgid "                a single history line."
#~ msgstr "                будут сохраняться в одной строке истории."

#~ msgid "histchars       Characters controlling history expansion and quick"
#~ msgstr "histchars       Управляющие символы расширения истории и быстрой"

#~ msgid "\t\tsubstitution.  The first character is the history"
#~ msgstr "\t\tподстановки. Первый символ -- символ подстановки"

#~ msgid "\t\tsubstitution character, usually `!'.  The second is"
#~ msgstr "\t\tистории, обычно `!'. Второй -- символ `быстрой"

#~ msgid "\t\tthe `quick substitution' character, usually `^'.  The"
#~ msgstr "\t\tподстановки', обычно `^'. Третий -- символ `комментария"

#~ msgid "\t\tthird is the `history comment' character, usually `#'."
#~ msgstr "\t\tистории', обычно `#'."

#~ msgid "HISTCONTROL\tSet to a value of `ignorespace', it means don't enter"
#~ msgstr "HISTCONTROL\tЕсли равен `ignorespace', это означает, что строки,"

#~ msgid "\t\tlines which begin with a space or tab on the history"
#~ msgstr "\t\tначинающиеся с пробела или знака табуляции, не попадают"

#~ msgid "\t\tlist.  Set to a value of `ignoredups', it means don't"
#~ msgstr "\t\tв историю. `ignoredups' означает, что строки, сопадающие"

#~ msgid "\t\tenter lines which match the last entered line.  Set to"
#~ msgstr "\t\tс предыдущей, не попадают в историю. `ignoreboth' --"

#~ msgid "\t\t`ignoreboth' means to combine the two options.  Unset,"
#~ msgstr "\t\tодновременное действие обоих параметров. Если не"

#~ msgid "\t\tor set to any other value than those above means to save"
#~ msgstr "\t\tустановлено, или равно другому значению, то в историю"

#~ msgid "\t\tall lines on the history list."
#~ msgstr "\t\tкоманд попадают все строки."

#~ msgid "Adds a directory to the top of the directory stack, or rotates"
#~ msgstr "Помещает каталог на вершину стека каталогов или вращает"

#~ msgid "the stack, making the new top of the stack the current working"
#~ msgstr "стек так, чтобы на вершине находился текущий каталог. Без"

#~ msgid "directory.  With no arguments, exchanges the top two directories."
#~ msgstr "аргументов меняет местами два верхних каталога."

#~ msgid "+N\tRotates the stack so that the Nth directory (counting"
#~ msgstr "+N\tВращает стек так, чтобы N-й каталог (считая с левой стороны "

#~ msgid "\tfrom the left of the list shown by `dirs') is at the top."
#~ msgstr "\tсписка, выводимого `dirs') оказался на вершине стека."

#~ msgid "-N\tRotates the stack so that the Nth directory (counting"
#~ msgstr "-N\tВращает стек так, чтобы N-й каталог (считая с правой"

#~ msgid "\tfrom the right) is at the top."
#~ msgstr "\tстороны) оказался на вершине стека."

#~ msgid "-n\tsuppress the normal change of directory when adding directories"
#~ msgstr "-n\tподавляет обычную смену каталога при добавлении каталога"

#~ msgid "\tto the stack, so only the stack is manipulated."
#~ msgstr "\tв стек, так что меняется только содержимое стека."

#~ msgid "dir\tadds DIR to the directory stack at the top, making it the"
#~ msgstr "dir\tпомещает DIR на вершину стека и делает его новым"

#~ msgid "You can see the directory stack with the `dirs' command."
#~ msgstr "Просматривать стек каталогов можно командой `dirs'."

#~ msgid "Removes entries from the directory stack.  With no arguments,"
#~ msgstr "Удаляет значения из стека каталогов. Без аргументов"

#~ msgid "removes the top directory from the stack, and cd's to the new"
#~ msgstr "удаляет из стека каталог на вершине и делает рабочим каталог,"

#~ msgid "+N\tremoves the Nth entry counting from the left of the list"
#~ msgstr "+N\tудаляет N-й каталог, считая с левой стороны списка,"

#~ msgid "\tshown by `dirs', starting with zero.  For example: `popd +0'"
#~ msgstr "\tвыводимого `dirs', начиная с нуля. Например, `popd +0'"

#~ msgid "\tremoves the first directory, `popd +1' the second."
#~ msgstr "\tудаляет первый каталог, `popd +1' -- второй."

#~ msgid "-N\tremoves the Nth entry counting from the right of the list"
#~ msgstr "-N\tудаляет N-й каталог, считая с правой стороны списка,"

#~ msgid "\tshown by `dirs', starting with zero.  For example: `popd -0'"
#~ msgstr "\tвыводимого `dirs', начиная с нуля. Например, `popd -0'"

#~ msgid "\tremoves the last directory, `popd -1' the next to last."
#~ msgstr "\tудаляет последний каталог, `popd -1' -- предпоследний."

#~ msgid ""
#~ "-n\tsuppress the normal change of directory when removing directories"
#~ msgstr "-n\tподавляет обычную смену каталога при удалении каталогов из"

#~ msgid "\tfrom the stack, so only the stack is manipulated."
#~ msgstr "\tстека, так что меняется только содержимое стека."

#~ msgid "Display the list of currently remembered directories.  Directories"
#~ msgstr "Выводит список запомненных на данный момент каталогов. Каталоги"

#~ msgid "find their way onto the list with the `pushd' command; you can get"
#~ msgstr ""
#~ "попадают в список при использовании команды `pushd', вы можете забрать"

#~ msgid "back up through the list with the `popd' command."
#~ msgstr "их из списка командой `popd'."

#~ msgid ""
#~ "The -l flag specifies that `dirs' should not print shorthand versions"
#~ msgstr ""
#~ "Флаг -l указывает, что `dirs' не должна выводит сокращённые варианты"

#~ msgid ""
#~ "of directories which are relative to your home directory.  This means"
#~ msgstr "каталогов, заданных относительно домашнего. Это означает, что"

#~ msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
#~ msgstr "`~/bin' будет отображаться как `/homes/bfox/bin'. Флаг -v"

#~ msgid "causes `dirs' to print the directory stack with one entry per line,"
#~ msgstr "заставляет `dirs' выводить каталоги по одному в строке, предваряя"

#~ msgid ""
#~ "prepending the directory name with its position in the stack.  The -p"
#~ msgstr ""
#~ "имя каталога номером его позиции в стеке. Флаг -p делает то же самое,"

#~ msgid "flag does the same thing, but the stack position is not prepended."
#~ msgstr "но не добавляются номера позиций. Флаг -c очищает стек каталогов,"

#~ msgid ""
#~ "The -c flag clears the directory stack by deleting all of the elements."
#~ msgstr "удаляя все его элементы."

#~ msgid ""
#~ "+N\tdisplays the Nth entry counting from the left of the list shown by"
#~ msgstr "+N\tвыводит N-й каталог, считая с левой стороны списка, выводимого"

#~ msgid "\tdirs when invoked without options, starting with zero."
#~ msgstr "\tdirs при вызове без параметров, начиная с нуля."

#~ msgid ""
#~ "-N\tdisplays the Nth entry counting from the right of the list shown by"
#~ msgstr "-N\tвыводит N-й каталог, считая с правой стороны списка, выводимого"

#~ msgid "Toggle the values of variables controlling optional behavior."
#~ msgstr "Меняет значение переменных, управляющих поведением оболочки."

#~ msgid "The -s flag means to enable (set) each OPTNAME; the -u flag"
#~ msgstr "Флаг -s означает включить (установить) каждое ИМЯ_ПАРАМЕТРА,"

#~ msgid "unsets each OPTNAME.  The -q flag suppresses output; the exit"
#~ msgstr "флаг -u сбрасывает. Флаг -q подавляет вывод, установлен или"

#~ msgid "status indicates whether each OPTNAME is set or unset.  The -o"
#~ msgstr "сброшен параметр определяется по коду возврата. Параметр -o"

#~ msgid "option restricts the OPTNAMEs to those defined for use with"
#~ msgstr "ограничивает работу параметрами, определёнными с помощью"

#~ msgid "`set -o'.  With no options, or with the -p option, a list of all"
#~ msgstr "`set -o'. Без параметров или при заданном параметре -p, выводится"

#~ msgid "settable options is displayed, with an indication of whether or"
#~ msgstr "список всех установленных параметров и информация, установлены"

#~ msgid "not each is set."
#~ msgstr "они или нет."
