# Italian translation for bash
# Copyright (C) 2009 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Sergio Zanchetta <primes2h@ubuntu.com>, 2010, 2011.
#
msgid ""
msgstr ""
"Project-Id-Version: bash-4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2011-10-17 09:14+0200\n"
"Last-Translator: Sergio Zanchetta <primes2h@ubuntu.com>\n"
"Language-Team: Italian <tp@lists.linux.it>\n"
"Language: it\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural= (n != 1)\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "indice dell'array errato"

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr ""

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: impossibile convertire un array indicizzato in uno associativo"

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: impossibile assegnare a un indice non numerico"

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr ""
"%s: %s: deve essere usato un indice nell'assegnazione di un array associativo"

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: impossibile creare: %s"

#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr ""
"bash_execute_unix_command: impossibile trovare una mappatura per il comando"

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: il primo carattere non spazio non è \"\"\""

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "carattere di chiusura \"%c\" non presente in %s"

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: separatore di tipo due punti mancante"

#: bashline.c:4733
#, fuzzy, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "\"%s\": impossibile eliminare l'associazione"

#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr ""

#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr ""

#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr ""

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "\"%s\": nome alias non valido"

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "modifica delle righe non abilitata"

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "\"%s\": nome della mappatura non valido"

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: impossibile leggere: %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "\"%s\" nome della funzione sconosciuto"

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s non è associato ad alcun tasto.\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s può essere invocato tramite "

#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "\"%s\": impossibile eliminare l'associazione"

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "numero di cicli"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "significativo solo in un ciclo \"for\", \"while\" o \"until\""

#: builtins/caller.def:136
#, fuzzy
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Restituisce il contesto della chiamata alla subroutine corrente.\n"
"    \n"
"    Senza ESPR, restituisce \"$riga $nomefile\".  Con ESPR, restituisce\n"
"    \"$riga $subroutine $nomefile\"; questa informazione aggiuntiva può "
"essere usata\n"
"    per fornire uno stack trace.\n"
"    \n"
"    Il valore dell'ESPR indica di quanti frame di chiamata tornare indietro "
"rispetto\n"
"    a quello attuale; in cima c'è il frame 0.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce 0 a meno che non sia in esecuzione una funzione di shell o "
"che l'ESPR\n"
"    non sia valida."

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "HOME non impostata"

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "troppi argomenti"

#: builtins/cd.def:342
#, fuzzy
msgid "null directory"
msgstr "nessun'altra directory"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "OLDPWD non impostata"

#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "riga %d: "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "attenzione: "

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s: uso: "

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: l'opzione richiede un argomento"

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: è necessario un argomento numerico"

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s: non trovata"

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s: opzione non valida"

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s: nome dell'opzione non valido"

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "\"%s\": non è un identificatore valido"

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "numero ottale non valido"

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "numero esadecimale non valido"

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "numero non valido"

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: specifica di segnale non valida"

#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "\"%s\": non è un pid o un numero di job valido"

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s: variabile in sola lettura"

#: builtins/common.c:273
#, fuzzy, c-format
msgid "%s: cannot assign"
msgstr "%s: impossibile azzerare"

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s fuori dall'intervallo"

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "argomento"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s fuori dall'intervallo"

#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s: job inesistente"

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s: nessun controllo dei job"

#: builtins/common.c:301
msgid "no job control"
msgstr "nessun controllo dei job"

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s: limitato"

#: builtins/common.c:313
msgid "restricted"
msgstr "limitato"

#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: non è un comando interno di shell"

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "errore in scrittura: %s"

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "errore nell'impostazione degli attributi del terminale: %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "errore nel recupero degli attributi del terminale: %s"

#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: errore nel recupero della directory corrente: %s: %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: specifica di job ambigua"

#: builtins/common.c:971
msgid "help not available in this version"
msgstr ""

#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: impossibile azzerare: %s in sola lettura"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s: impossibile azzerare"

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s: nome azione non valido"

#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s: nessun completamento specificato"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "attenzione: l'opzione -F potrebbe non funzionare come previsto"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "attenzione: l'opzione -C potrebbe non funzionare come previsto"

#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "funzione di completamento attualmente non in esecuzione"

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "può essere usato solo in una funzione"

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "impossibile usare \"-f\" per creare funzioni"

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s: funzione in sola lettura"

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr ""

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr ""

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr ""

#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, fuzzy, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "\"%s\": nome alias non valido"

#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: impossibile eliminare variabili array in questo modo"

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: impossibile convertire un array associativo in uno indicizzato"

#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr ""

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "caricamento dinamico non disponibile"

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "impossibile aprire l'oggetto condiviso %s: %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "impossibile trovare %s nell'oggetto condiviso %s: %s"

#: builtins/enable.def:422
#, fuzzy, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: non caricato dinamicamente"

#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr ""

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: non caricato dinamicamente"

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: impossibile eliminare: %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s: è una directory"

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s: non è un file regolare"

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s: file troppo grande"

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: impossibile eseguire il file binario"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: impossibile eseguire: %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "logout\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "non è una shell di login: utilizzare \"exit\""

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Sono presenti job interrotti.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Ci sono job in esecuzione.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "nessun comando trovato"

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr "specifica della cronologia"

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: impossibile aprire il file temp: %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "attuale"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "job %d avviato senza controllo dei job"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opzione illecita -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: l'opzione richiede un argomento -- %c\n"

#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "hashing disabilitato"

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s tabella di hash vuota\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "rich.\tcomando\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Comandi di shell corrispondenti alla parola chiave \""
msgstr[1] "Comandi di shell corrispondenti alle parole chiave \""

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""

#: builtins/help.def:185
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"nessun argomento della guida corrisponde a \"%s\". Provare \"help help\" o "
"\"man -k %s\" o \"info %s\"."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: impossibile aprire: %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Questi comandi della shell sono definiti internamente. Digitare \"help\" per "
"consultare questa lista.\n"
"Digitare \"help nome\" per saperne di più sulla funzione \"nome\".\n"
"Usare \"info bash\" per saperne di più sulla shell in generale.\n"
"Usare \"man -k\" o \"info\" per saperne di più su comandi non presenti nella "
"lista.\n"
"\n"
"Un asterisco (*) vicino a un nome significa che il comando è disabilitato.\n"
"\n"

#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "impossibile usare più di uno tra -anrw"

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "posizione nella cronologia"

#: builtins/history.def:338
#, fuzzy, c-format
msgid "%s: invalid timestamp"
msgstr "%s: nome dell'opzione non valido"

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: espansione della cronologia non riuscita"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: inlib non riuscito"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "nessuna altra opzione permessa con \"-x\""

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: gli argomenti devono essere ID di processo o di job"

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Errore sconosciuto"

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "attesa espressione"

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: non è un array indicizzato"

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: specifica di descrittore di file non valida"

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: descrittore di file non valido: %s"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s: numero di righe non valido"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: origine dell'array non valida"

#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: quantum di callback non valido"

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "nome della variabile array vuoto"

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr "necessario il supporto alla variabile array"

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "\"%s\": manca il carattere di formato"

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "\"%c\": specifica di formato dell'orario non valida"

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "\"%c\": carattere di formato non valido"

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "attenzione: %s: %s"

#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr ""

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "cifra esadecimale mancante in \\x"

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "cifra unicode mancante in \\%c"

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "nessun'altra directory"

#: builtins/pushd.def:360
#, fuzzy, c-format
msgid "%s: invalid argument"
msgstr "%s: argomento di limite non valido"

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "<nessuna directory corrente>"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "stack delle directory vuoto"

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "indice dello stack delle directory"

#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Visualizza l'elenco delle directory attualmente in memoria. Le directory\n"
"    vengono inserite nell'elenco con il comando \"pushd\"; è possibile\n"
"    andare a ritroso nell'elenco con il comando \"popd\".\n"
"    \n"
"    Opzioni:\n"
"      -c\tPulisce lo stack delle directory eliminandone tutti gli elementi\n"
"      -l\tNon stampa la tilde come prefisso per le directory relative alla\n"
"    \tpropria directory home\n"
"      -p\tStampa lo stack delle directory una voce per riga\n"
"      -v\tStampa lo stack delle directory una voce per riga usando la\n"
"    \tposizione nello stack stesso come prefisso\n"
"    \n"
"    Argomenti:\n"
"      +N\tVisualizza l'N-sima voce contando a partire da sinistra "
"dell'elenco\n"
"    \tmostrato da dirs quando invocato senza opzioni, iniziando da zero.\n"
"    \n"
"      -N\tVisualizza l'N-sima voce contando a partire da destra dell'elenco\n"
"\tmostrato da dirs quando invocato senza opzioni, iniziando da zero."

#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Aggiunge una directory in cima allo stack delle directory o ruota lo\n"
"    stack stesso, mettendo come primo elemento l'attuale directory\n"
"    di lavoro. Senza argomenti scambia le prime due directory in cima.\n"
"    \n"
"    Opzioni:\n"
"      -n\tEvita il normale cambio di directory quando vengono aggiunte\n"
"    \tdirectory allo stack, così da manipolare solo lo stack stesso.\n"
"    \n"
"    Argomenti:\n"
"      +N\tRuota lo stack in modo che l'N-sima directory (contando\n"
"    \ta partire da sinistra dell'elenco mostrato da \"dirs\", iniziando da\n"
"    \tzero) sia in cima.\n"
"    \n"
"      -N\tRuota lo stack in modo che l'N-sima directory (contando\n"
"    \ta partire da destra dell'elenco mostrato da \"dirs\", iniziando da\n"
"    \tzero) sia in cima.\n"
"    \n"
"      dir\tAggiunge DIR in cima allo stack delle directory, facendone la\n"
"    \tdirectory di lavoro corrente.\n"
"    \n"
"    Il comando interno \"dirs\" visualizza lo stack delle directory."

#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Rimuove voci dallo stack delle directory. Senza argomenti, rimuove\n"
"    la directory in cima allo stack e passa alla nuova prima directory.\n"
"    \n"
"    Opzioni:\n"
"      -n\tEvita il normale cambio di directory quando vengono rimosse\n"
"    \tdirectory dallo stack, così da manipolare solo lo stack stesso.\n"
"    \n"
"    Argomenti:\n"
"      +N\tRimuove l'N-sima voce contando a partire da sinistra dell'elenco\n"
"    \tmostrato da \"dirs\", iniziando da zero. Per esempio: \"popd +0\"\n"
"    \trimuove la prima directory, \"popd +1\" la seconda.\n"
"    \n"
"      -N\tRimuove l'N-sima voce contando a partire da destra dell'elenco\n"
"    \tmostrato da \"dirs\", iniziando da zero. Per esempio: \"popd -0\"\n"
"    \trimuove l'ultima directory, \"popd -1\" la penultima.\n"
"    \n"
"    Il comando interno \"dirs\" visualizza lo stack delle directory."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: specifica di timeout non valida"

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "errore in lettura: %d: %s"

#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr ""
"è possibile eseguire \"return\" solo da una funzione o da uno script chiamato"

#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr "impossibile azzerare contemporaneamente una funzione e una variabile"

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s: non è una variabile array"

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s: non è una funzione"

#: builtins/setattr.def:194
#, fuzzy, c-format
msgid "%s: cannot export"
msgstr "%s: impossibile azzerare"

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "numero di scorrimenti"

#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "impossibile impostare e azzerare opzioni di shell contemporaneamente"

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: nome dell'opzione di shell non valido"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "necessario un nome file come argomento"

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s: file non trovato"

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "impossibile sospendere"

#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "impossibile sospendere una shell di login"

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s ha \"%s\" come alias\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s è una parola chiave di shell\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s è una funzione\n"

#: builtins/type.def:299
#, fuzzy, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s è un comando interno di shell\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s è un comando interno di shell\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "%s è %s\n"

#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "hash effettuato su %s (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: argomento di limite non valido"

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "\"%c\": comando errato"

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: impossibile recuperare il limite: %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "limite"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: impossibile modificare il limite: %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "numero ottale"

#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "\"%c\": operatore di modo simbolico non valido"

#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "\"%c\": carattere di modo simbolico non valido"

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " riga "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "ultimo comando: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Interruzione..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr ""

#: error.c:310
#, fuzzy, c-format
msgid "DEBUG warning: "
msgstr "attenzione: "

#: error.c:488
msgid "unknown command error"
msgstr "errore di comando sconosciuto"

#: error.c:489
msgid "bad command type"
msgstr "tipo di comando errato"

#: error.c:490
msgid "bad connector"
msgstr "connettore errato"

#: error.c:491
msgid "bad jump"
msgstr "salto errato"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s: variabile non assegnata"

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\atempo di attesa scaduto per l'input: auto-logout\n"

#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "impossibile redirigere lo standard input da /dev/null: %s"

#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: \"%c\": carattere di formato non valido"

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr ""

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "errore della pipe"

#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr ""

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr ""

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr ""

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: limitato: impossibile specificare \"/\" nei nomi dei comandi"

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s: comando non trovato"

#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5975
#, fuzzy, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: impossibile eseguire il file binario"

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: interprete errato"

#: execute_cmd.c:6037
#, fuzzy, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: impossibile eseguire il file binario"

#: execute_cmd.c:6123
#, fuzzy, c-format
msgid "`%s': is a special builtin"
msgstr "%s è un comando interno di shell\n"

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "impossibile duplicare fd %d su fd %d"

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "superato il livello di ricorsione dell'espressione"

#: expr.c:291
msgid "recursion stack underflow"
msgstr "underflow dello stack di ricorsione"

#: expr.c:478
msgid "syntax error in expression"
msgstr "errore di sintassi nell'espressione"

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "tentata un'assegnazione a una non variabile"

#: expr.c:531
#, fuzzy
msgid "syntax error in variable assignment"
msgstr "errore di sintassi nell'espressione"

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "divisione per 0"

#: expr.c:593
msgid "bug: bad expassign token"
msgstr "bug: token di expassign errato"

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "atteso \":\" per l'espressione condizionale"

#: expr.c:973
msgid "exponent less than 0"
msgstr "esponente minore di 0"

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "atteso identificatore dopo un pre-incremento o un pre-decremento"

#: expr.c:1057
msgid "missing `)'"
msgstr "\")\" mancante"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "errore di sintassi: atteso un operando"

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "errore di sintassi: operatore aritmetico non valido"

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (il token dell'errore è \"%s\")"

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "base aritmetica non valida"

#: expr.c:1587
#, fuzzy
msgid "invalid integer constant"
msgstr "%s: numero di righe non valido"

#: expr.c:1603
msgid "value too great for base"
msgstr "valore troppo grande per la base"

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s: errore di espressione\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: impossibile accedere alle directory padre"

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "impossibile reimpostare il modo nodelay per fd %d"

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr ""
"impossibile allocare un nuovo descrittore di file per l'input della bash da "
"fd %d"

#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: buffer già esistente per il nuovo fd %d"

#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pipe pgrp"

#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr ""

#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr ""

#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "il pid %d del fork appare nel job in esecuzione %d"

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "eliminazione del job %d interrotto con il gruppo di processi %ld"

#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) segnato come ancora in vita"

#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: pid inesistente"

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "Segnale %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Completato"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Fermato"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Fermato(%s)"

#: jobs.c:1881
msgid "Running"
msgstr "In esecuzione"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Eseguito(%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Uscita %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "Stato sconosciuto"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(core dump creato) "

#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (dir: %s)"

#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "setpgid del figlio (%ld a %ld)"

#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: il pid %ld non è un figlio di questa shell"

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: nessun record del processo %ld"

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: il job %d è fermo"

#: jobs.c:3551
#, fuzzy, c-format
msgid "%s: no current jobs"
msgstr "%s: job inesistente"

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s: il job è terminato"

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: il job %d è già in background"

#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: attivato WNOHANG per evitare blocchi indefiniti"

#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s: riga %d: "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr " (core dump creato)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(dir ora: %s)\n"

#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp non riuscita"

#: jobs.c:4434
#, fuzzy
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: disciplina di linea"

#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: disciplina di linea"

#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "impossibile impostare il gruppo di processi del terminale (%d)"

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "nessun controllo dei job in questa shell"

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: asserzione non riuscita: %s\n"

#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: asserzione non riuscita\r\n"

#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "sconosciuto"

#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "malloc: blocco eliminato nell'elenco dei disponibili"

#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "free: chiamata con un argomento di blocco già liberato"

#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "free: chiamata con un argomento di blocco non allocato"

#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: riscontrato un underflow; mh_nbytes fuori intervallo"

#: lib/malloc/malloc.c:1007
#, fuzzy
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: riscontrato un underflow; mh_nbytes fuori intervallo"

#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "free: dimensioni diverse dei blocchi di inizio e di fine"

#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "realloc: chiamata con un argomento di blocco non allocato"

#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: riscontrato un underflow; mh_nbytes fuori intervallo"

#: lib/malloc/malloc.c:1197
#, fuzzy
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: riscontrato un underflow; mh_nbytes fuori intervallo"

#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: dimensioni diverse dei blocchi di inizio e di fine"

#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr ""
"register_alloc: forse la tavola di allocazione è piena con FIND_ALLOC\n"

#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: forse %p è già come allocato nella tabella\n"

#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_alloc: forse %p è già come libero nella tabella\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "base non valida"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: host sconosciuto"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: servizio non valido"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: specifica del percorso di rete errata"

#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "operazione di rete non supportata"

#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: impossibile cambiare la localizzazione (%s)"

#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: impossibile cambiare la localizzazione (%s): %s"

#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: impossibile cambiare la localizzazione (%s)"

#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: impossibile cambiare la localizzazione (%s): %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "È presente della posta in $_"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "È presente della nuova posta in $_"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "La posta in %s è stata letta\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "errore di sintassi: richiesta espressione aritmetica"

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "errore di sintassi: \";\" non atteso"

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "errore di sintassi: \"((%s))\""

#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: tipo di istruzione errata %d"

#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr ""
"here-document alla riga %d è delimitato da un EOF (era richiesto \"%s\")"

#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr ""
"make_redirection: istruzione di reindirizzamento \"%d\" fuori dell'intervallo"

#: parse.y:2428
#, c-format
msgid ""
"shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line "
"truncated"
msgstr ""

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr ""

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "EOF non atteso durante la ricerca di \"%c\""

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "EOF non atteso durante la ricerca di \"]]\""

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr ""
"errore di sintassi nell'espressione condizionale: token non atteso \"%s\""

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "errore di sintassi nell'espressione condizionale"

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "token non atteso \"%s\", era atteso \")\""

#: parse.y:4543
msgid "expected `)'"
msgstr "atteso \")\""

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "argomento non atteso \"%s\" per l'operatore unario condizionale"

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr "argomento non atteso per l'operatore unario condizionale"

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "token non atteso \"%s\", era atteso un operatore binario condizionale"

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr "atteso operatore binario condizionale"

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "argomento non atteso \"%s\" per l'operatore binario condizionale"

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr "argomento non atteso per l'operatore binario condizionale"

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "token non atteso \"%c\" nel comando condizionale"

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "token non atteso \"%s\" nel comando condizionale"

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "token non atteso %d nel comando condizionale"

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "errore di sintassi vicino al token non atteso \"%s\""

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "errore di sintassi vicino a \"%s\""

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "errore di sintassi: EOF non atteso"

#: parse.y:6151
msgid "syntax error"
msgstr "errore di sintassi"

#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Usare \"%s\" per uscire dalla shell.\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "EOF non atteso durante la ricerca di \")\""

#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: funzione \"%s\" non trovata"

#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr ""

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: COMPSPEC NULL"

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: connettore errato \"%d\""

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: descrittore di file non valido"

#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: puntatore a file NULL"

#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != numfile xtrace fp (%d)"

#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: \"%c\": carattere di formato non valido"

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "descrittore di file fuori dell'intervallo"

#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: redirezione ambigua"

#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: impossibile sovrascrivere il file esistente"

#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: limitato: impossibile redirigere l'output"

#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "impossibile creare un file temporaneo per here-document: %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: impossibile assegnare fd a una variabile"

#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port non supportata senza rete"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "errore di reindirizzamento: impossibile duplicare fd"

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "impossibile trovare /tmp, è necessario crearla"

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "/tmp deve essere un nome di directory valido"

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr ""

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: opzione non valida"

#: shell.c:1343
#, fuzzy, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "impossibile reimpostare il modo nodelay per fd %d"

#: shell.c:1354
#, fuzzy, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "impossibile reimpostare il modo nodelay per fd %d"

#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr ""

#: shell.c:1658
#, fuzzy, c-format
msgid "%s: Is a directory"
msgstr "%s: è una directory"

#: shell.c:1907
msgid "I have no name!"
msgstr "Manca il nome"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, versione %s-(%s)\n"

#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Uso:\t%s [opzione lunga GNU] [opzione] ...\n"
"\t%s [opzione lunga GNU] [opzione] file-script ...\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "Opzioni lunghe GNU:\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Opzioni di shell:\n"

#: shell.c:2069
#, fuzzy
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-irsD o -c comando o -O opzione_shopt\t\t(solo invocazione)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\topzione -%s oppure -o\n"

#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr ""
"Digitare «%s -c \"help set\"» per ulteriori informazioni sulle opzioni di "
"shell.\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Digitare \"%s -c help\" per ulteriori informazioni sui comandi interni di "
"shell.\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Usare il comando \"bashbug\" per segnalare i bug.\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr ""

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr ""

#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: operazione non valida"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Segnale inesistente"

#: siglist.c:51
msgid "Hangup"
msgstr "Chiusura"

#: siglist.c:55
msgid "Interrupt"
msgstr "Interruzione"

#: siglist.c:59
msgid "Quit"
msgstr "Uscita (con core dump)"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Istruzione non consentita"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Rilevato trace/breakpoint"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Istruzione ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Istruzione EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Eccezione in virgola mobile"

#: siglist.c:87
msgid "Killed"
msgstr "Ucciso"

#: siglist.c:91
msgid "Bus error"
msgstr "Errore di bus"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Errore di segmentazione"

#: siglist.c:99
msgid "Bad system call"
msgstr "Chiamata di sistema errata"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Pipe interrotta"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Sveglia"

#: siglist.c:111
msgid "Terminated"
msgstr "Terminato"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Condizione di I/O urgente"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Fermato (segnale)"

#: siglist.c:127
msgid "Continue"
msgstr "Continuato"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Processo figlio concluso o fermato"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Fermato (input da terminale)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Fermato (output da terminale)"

#: siglist.c:147
msgid "I/O ready"
msgstr "I/O pronto"

#: siglist.c:151
msgid "CPU limit"
msgstr "Limite di CPU"

#: siglist.c:155
msgid "File limit"
msgstr "Limite di file"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Timer (virtuale)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Timer (profilo)"

#: siglist.c:167
msgid "Window changed"
msgstr "Finestra modificata"

#: siglist.c:171
msgid "Record lock"
msgstr "Blocco del record"

#: siglist.c:175
msgid "User signal 1"
msgstr "Segnale 1 dell'utente"

#: siglist.c:179
msgid "User signal 2"
msgstr "Segnale 2 dell'utente"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "Dati di input HTF in sospeso"

#: siglist.c:187
msgid "power failure imminent"
msgstr "mancanza di alimentazione imminente"

#: siglist.c:191
msgid "system crash imminent"
msgstr "crash di sistema imminente"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "processo spostato su un'altra CPU"

#: siglist.c:199
msgid "programming error"
msgstr "errore di programmazione"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "Modalità di monitoraggio HFT concessa"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "Modalità di monitoraggio HFT revocata"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "la sequenza sonora HFT è stata completata"

#: siglist.c:215
msgid "Information request"
msgstr "Richiesta di informazioni"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Segnale sconosciuto n° %d"

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "sostituzione errata: nessuna chiusura di \"%s\" in %s"

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: impossibile assegnare una lista a un membro di un array"

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "impossibile creare una pipe per la sostituzione del processo"

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "impossibile creare un figlio per la sostituzione del processo"

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "impossibile aprire la pipe con nome %s in lettura"

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "impossibile aprire la pipe con nome %s in scrittura"

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "impossibile duplicare una pipe con nome %s come fd %d"

#: subst.c:6370
#, fuzzy
msgid "command substitution: ignored null byte in input"
msgstr "sostituzione errata: manca «\"» di chiusura in %s"

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "impossibile creare una pipe per la sostituzione del comando"

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "impossibile creare un figlio per la sostituzione del comando"

#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: impossibile duplicare la pipe come fd 1"

#: subst.c:7082 subst.c:10252
#, fuzzy, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: %s: valore non valido per il descrittore del file di traccia"

#: subst.c:7178 subst.c:7196 subst.c:7369
#, fuzzy, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: numero di righe non valido"

#: subst.c:7212 subst.c:7377
#, fuzzy, c-format
msgid "%s: invalid variable name"
msgstr "\"%s\": nome alias non valido"

#: subst.c:7478
#, fuzzy, c-format
msgid "%s: parameter not set"
msgstr "%s: parametro nullo o non impostato"

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parametro nullo o non impostato"

#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: expressione di sottostringa < 0"

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s: sostituzione errata"

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: impossibile assegnare in questo modo"

#: subst.c:10111
msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr ""
"le versioni future della shell forzeranno la valutazione come fosse una "
"sostituzione aritmetica"

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "sostituzione errata: manca «\"» di chiusura in %s"

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "nessuna corrispondenza: %s"

#: test.c:147
msgid "argument expected"
msgstr "atteso argomento"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: attesa espressione intera"

#: test.c:265
msgid "`)' expected"
msgstr "atteso \")\""

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "atteso \")\", trovato %s"

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: atteso operatore binario"

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: atteso operatore unario"

#: test.c:896
msgid "missing `]'"
msgstr "\"]\" mancante"

#: test.c:914
#, fuzzy, c-format
msgid "syntax error: `%s' unexpected"
msgstr "errore di sintassi: \";\" non atteso"

#: trap.c:220
msgid "invalid signal number"
msgstr "numero di segnale non valido"

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr ""

#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: valore errato in trap_list[%d]: %p"

#: trap.c:416
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""
"run_pending_traps: il gestore dei segnali è SIG_DFL, viene inviato "
"nuovamente %d (%s)"

#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: segnale errato %d"

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "errore nell'importazione della definizione di funzione per \"%s\""

#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "livello di shell (%d) troppo alto, reimpostato a 1"

#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: nessun contesto di funzione nell'ambito corrente"

#: variables.c:2661
#, fuzzy, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: impossibile assegnare fd a una variabile"

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr ""

#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr ""

#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: nessun contesto di funzione nell'ambito corrente"

#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "%s ha exportstr null"

#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "carattere non valido %d in exportstr per %s"

#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "nessun \"=\" in exportstr per %s"

#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""
"pop_var_context: la prima parte di shell_variables non è un contesto di "
"funzione"

#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: nessun contesto global_variables"

#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr ""
"pop_scope: la prima parte di shell_variables non è un ambito temporaneo "
"d'ambiente"

#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: impossibile aprire come FILE"

#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: valore non valido per il descrittore del file di traccia"

#: variables.c:6450
#, fuzzy, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s fuori dall'intervallo"

#: version.c:46 version2.c:46
#, fuzzy
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "Copyright © 2009 Free Software Foundation, Inc.\n"

#: version.c:47 version2.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"Licenza GPLv3+: GNU GPL versione 3 o successiva <http://gnu.org/licenses/gpl."
"html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, versione %s (%s)\n"

#: version.c:91 version2.c:91
#, fuzzy
msgid "This is free software; you are free to change and redistribute it."
msgstr "Questo è software libero; è possibile modificarlo e ridistribuirlo.\n"

#: version.c:92 version2.c:92
#, fuzzy
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "Non c'è ALCUNA GARANZIA, nei limiti permessi dalla legge.\n"

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: impossibile allocare %lu byte (%lu byte allocati)"

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: impossibile allocare %lu byte"

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: impossibile allocare %lu byte (%lu byte allocati)"

#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: impossibile allocare %lu byte"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [nome[=valore] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] nome [nome ...]"

#: builtins.c:53
#, fuzzy
msgid ""
"bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpvsPVS] [-m mappatura] [-f nomefile] [-q nome] [-u nome] [-r "
"seqtasti] [-x seqtasti:comando-shell] [seqtasti:funzione-readline o comando-"
"readline]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [comandoint-shell [arg ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [espr]"

#: builtins.c:66
#, fuzzy
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]]] [dir]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] comando [arg ...]"

#: builtins.c:78
#, fuzzy
msgid ""
"declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] "
"[name ...]"
msgstr "declare [-aAfFgilrtux] [-p] [nome[=valore] ...]"

#: builtins.c:80
#, fuzzy
msgid ""
"typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] "
"[name ...]"
msgstr "typeset [-aAfFgilrtux] [-p] nome[=valore] ..."

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [opzione] nome[=valore] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [arg ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [arg ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f nome_file] [nome ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [arg ...]"

#: builtins.c:96
#, fuzzy
msgid "getopts optstring name [arg ...]"
msgstr "getopts stringaopz nome [arg]"

#: builtins.c:98
#, fuzzy
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a nome] [comando [argomenti ...]] [redirezione ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e ename] [-lnr] [primo] [ultimo] oppure fc -s [pat=rep] [comando]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [spec_job]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [spec_job ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p nomepercorso] [-dt] [nome ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [modello ...]"

#: builtins.c:123
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d posiz] [n] oppure history -anrw [nomefile] oppure history -"
"ps arg [arg...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [specjob ...] oppure jobs -x comando [argomenti]"

#: builtins.c:131
#, fuzzy
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [specjob ...]"

#: builtins.c:134
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s specsegn | -n numsegn | -specsegn] pid | specjob ... oppure kill -l "
"[specsegn]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let arg [arg ...]"

#: builtins.c:138
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a array] [-d delim] [-i testo] [-n ncaratt] [-N ncaratt] [-p "
"stringa] [-t secondi] [-u fd] [nome ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
#, fuzzy
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCHP] [-o nome-opzione] [--] [arg ...]"

#: builtins.c:144
#, fuzzy
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [nome ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [nome[=valore] ...] oppure export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [nome[=valore] ...] oppure readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source nomefile [argomenti]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". nomefile [argomenti]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [espr]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ arg... ]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[arg] spec_segnale ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] nome [nome ...]"

#: builtins.c:171
#, fuzzy
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHacdefilmnpqrstuvx] [limite]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [modo]"

#: builtins.c:177
#, fuzzy
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [id]"

#: builtins.c:181
#, fuzzy
msgid "wait [pid ...]"
msgstr "wait [pid]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NOME [in PAROLE ... ] ; do COMANDI; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( espr1; espr2; espr3 )); do COMANDI; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NOME [in PAROLE ... ;] do COMANDI; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] pipeline"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case PAROLA in [MODELLO [| MODELLO]...) COMANDI ;;]... esac"

#: builtins.c:194
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if COMANDI; then COMANDI; [ elif COMANDI; then COMANDI; ]... [ else "
"COMANDI; ] fi"

#: builtins.c:196
#, fuzzy
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while COMANDI; do COMANDI; done"

#: builtins.c:198
#, fuzzy
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until COMANDI; do COMANDI; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NOME] comando [redirezioni]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function name { COMANDI ; } oppure name () { COMANDI ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ COMANDI ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "spec_job [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( espressione ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ espressione ]]"

#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr "variabili - nomi e significati di alcune variabili di shell"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | dir]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [nomeopz ...]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] formato [argomenti]"

#: builtins.c:231
#, fuzzy
msgid ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-"
"W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-DE] [-o opzione] [-A azione] [-G modglob] [-"
"W elencoparole]  [-F funzione] [-C comando] [-X modfiltro] [-P prefisso] [-S "
"suffisso] [nome ...]"

#: builtins.c:235
#, fuzzy
msgid ""
"compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-"
"F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o opzione]  [-A azione] [-G modglob] [-W "
"elencoparole]  [-F funzione] [-C comando] [-X modfiltro] [-P prefisso] [-S "
"suffisso] [parola]"

#: builtins.c:239
#, fuzzy
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o opzione] [-DE] [nome ...]"

#: builtins.c:242
#, fuzzy
msgid ""
"mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"mapfile [-n numero] [-O origine] [-s numero] [-t] [-u fd] [-C callback] [-c "
"quantità] [array]"

#: builtins.c:244
#, fuzzy
msgid ""
"readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"readarray [-n numero] [-O origine] [-s numero] [-t] [-u fd] [-C callback] [-"
"c quantità] [array]"

#: builtins.c:256
#, fuzzy
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"Definisce o visualizza alias.\n"
"    \n"
"    Senza argomenti, \"alias\" stampa l'elenco degli alias nella forma\n"
"    riusabile \"alias NOME=VALORE\" sullo standard output.\n"
"    \n"
"    Altrimenti, un alias è definito per ogni NOME a cui è fornito un "
"VALORE.\n"
"    Uno spazio finale in VALORE determina un controllo della parola "
"successiva\n"
"    che andrà a sostituire l'alias quando viene espanso.\n"
"    \n"
"    Opzioni:\n"
"      -p\tStampa tutti gli alias definiti in un formato riusabile\n"
"    \n"
"    Stato di uscita:\n"
"    alias restituisce vero a meno che non venga fornito un NOME per il "
"quale\n"
"    non sia stato definito alcun alias."

#: builtins.c:278
#, fuzzy
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Rimuove ogni NOME dall'elenco degli alias definiti.\n"
"    \n"
"    Opzioni:\n"
"      -a\tRimuove tutte le definizioni di alias.\n"
"    \n"
"    Restituisce successo a meno che NOME non sia un alias esistente."

#: builtins.c:291
#, fuzzy
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated "
"commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Imposta le associazioni di tasti e le variabili di Readline.\n"
"    \n"
"    Associa una sequenza di tasti a una funzione o a una macro Readline, "
"oppure imposta una\n"
"    variabile di Readline.  La sintassi di argomento senza opzione è "
"equivalente a quella\n"
"    trovata in ~/.inputrc, ma deve essere passata come singolo argomento:\n"
"    es., bind '\"\\C-x\\C-r\": ri-leggi-file-init'.\n"
"    \n"
"    Opzioni:\n"
"      -m  mappatura      Usa MAPPATURA come la mappatura per la durata di "
"questo\n"
"                         comando.  Nomi accettabili per la mappatura sono "
"emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command e vi-insert.\n"
"      -l                 Elenca i nomi delle funzioni.\n"
"      -P                 Elenca i nomi delle funzioni e le associazioni.\n"
"      -p                 Elenca le funzioni e le associazioni in una forma "
"che\n"
"                         possa essere riusata come input.\n"
"      -S                 Elenca le sequenze di tasti che invocano le macro e "
"i loro valori.\n"
"      -s                 Elenca le sequenze di tasti che invocano le macro e "
"i loro valori\n"
"                         in una forma che possa essere riusata come input.\n"
"      -V                 Elenca i nomi e i valori delle variabili.\n"
"      -v                 Elenca i nomi e i valori delle variabili in una "
"forma che possa\n"
"                         essere riusata come input.\n"
"      -q  nome-funzione  Identifica il tasto che invoca la funzione "
"nominata.\n"
"      -u  nome-funzione  Rimuove l'associazione tra la funzione nominata e "
"tutti i tasti associati.\n"
"      -r  seqtasti       Rimuove l'associazione per la SEQTASTI.\n"
"      -f  nomefile       Legge le associazioni di tasti da NOMEFILE.\n"
"      -x  seqtasti:comando-shell\tEsegue il COMANDO-SHELL quando viene "
"inserita\n"
"    \t\t\t\t\tla SEQTASTI.\n"
"    \n"
"    Stato di uscita:\n"
"    bind restituisce 0 a meno che non sia fornita una opzione non "
"riconosciuta o si riscontri un errore."

#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Esce da cicli for, while o until.\n"
"    \n"
"    Esce da un ciclo FOR, WHILE o UNTIL. Se è specificato N, interrompe N "
"cicli\n"
"    racchiusi.\n"
"    \n"
"    Stato di uscita:\n"
"    Lo stato di uscita è 0 a meno che N non sia maggiore o uguale a 1."

#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Riprende cicli for, while o until.\n"
"    \n"
"    Riprende l'iterazione successiva del ciclo chiuso FOR, WHILE o UNTIL.\n"
"    Se è specificato N, riprende l'N-simo ciclo chiuso.\n"
"    \n"
"    Stato di uscita:\n"
"    Lo stato di uscita è 0 a meno che N non sia maggiore o uguale a 1."

#: builtins.c:354
#, fuzzy
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Esegue comandi interni di shell.\n"
"    \n"
"    Esegue il COMINTERNO-SHELL con ARGOMENTI senza portare a termine una "
"ricerca\n"
"    comandi. Ciò è utile quando si desidera reimplementare un comando "
"interno come una\n"
"    funzione di shell, ma è necessario eseguire il comando all'interno della "
"funzione.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato di uscita del COMINTERNO-SHELL, o falso se il "
"COMINTERNO-SHELL\n"
"    non è un comando interno di shell."

#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Restituisce il contesto della chiamata alla subroutine corrente.\n"
"    \n"
"    Senza ESPR, restituisce \"$riga $nomefile\".  Con ESPR, restituisce\n"
"    \"$riga $subroutine $nomefile\"; questa informazione aggiuntiva può "
"essere usata\n"
"    per fornire uno stack trace.\n"
"    \n"
"    Il valore dell'ESPR indica di quanti frame di chiamata tornare indietro "
"rispetto\n"
"    a quello attuale; in cima c'è il frame 0.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce 0 a meno che non sia in esecuzione una funzione di shell o "
"che l'ESPR\n"
"    non sia valida."

#: builtins.c:387
#, fuzzy
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname "
"component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully "
"when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Cambia la directory di lavoro della shell.\n"
"    \n"
"    Cambia la directory corrente a DIR. La DIR predefinita è il valore della "
"variabile\n"
"    HOME della shell.\n"
"    \n"
"    La variabile CDPATH definisce il percorso di ricerca per la directory "
"che contiene\n"
"    DIR. I nomi di directory alternative in CDPATH sono separati da un due "
"punti (:).\n"
"    Una nome nullo di directory corrisponde alla directory corrente.  Se DIR "
"inizia\n"
"    con uno slash (/), CDPATH non viene usato.\n"
"    \n"
"    Se la directory non viene trovata e l'opzione di shell \"cdable_vars\" è "
"impostata,\n"
"    si assume che la parola sia un nome di variabile. Se questa variabile ha "
"un valore,\n"
"    viene usato per DIR.\n"
"    \n"
"    Opzioni:\n"
"        -L\tForza a seguire i collegamenti simbolici\n"
"        -P\tUsa la struttura fisica della directory senza seguire i "
"collegamenti\n"
"    \tsimbolici\n"
"        -e\tSe viene fornita l'opzione -P e non può essere determinata con "
"successo\n"
"    \tla directory di lavoro corrente, esce con uno stato diverso da zero\n"
"    \n"
"    Il valore predefinito è seguire i collegamenti simbolici, come se fosse "
"specificato \"-L\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce 0 se viene cambiata la directory o se $PWD è impostata con "
"successo quando\n"
"    viene usato -P; altrimenti un valore diverso da zero."

#: builtins.c:425
#, fuzzy
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Stampa il nome della directory di lavoro corrente.\n"
"    \n"
"    Opzioni:\n"
"      -L\tStampa il valore di $PWD se contiene il nome della directory\n"
"    \tdi lavoro corrente\n"
"      -P\tStampa la directory fisica senza alcun collegamento simbolico\n"
"    \n"
"    In maniera predefinita \"pwd\" si comporta come se fosse specificato \"-L"
"\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce 0 a meno che non venga fornita una opzione non valida o che "
"la\n"
"    directory corrente non possa essere letta."

#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Comando nullo.\n"
"    \n"
"    Nessun effetto; il comando non esegue nulla.\n"
"    \n"
"    Stato di uscita:\n"
"    ha sempre successo."

#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Restituisce successo come risultato.\n"
"    \n"
"    Stato di uscita:\n"
"    ha sempre successo."

#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Restituisce un risultato di insuccesso.\n"
"    \n"
"    Stato di uscita:\n"
"    Sempre un insuccesso."

#: builtins.c:471
#, fuzzy
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Esegue un comando semplice o visualizza informazioni sui comandi.\n"
"    \n"
"    Esegue il COMANDO con gli ARGOMENTI ignorando la ricerca delle funzioni "
"di shell o\n"
"    visualizza informazioni sui COMANDI specificati.  Può essere usato per "
"invocare comandi\n"
"    sul disco quando esiste una funzione con lo stesso nome.\n"
"    \n"
"    Opzioni:\n"
"      -p\tUsa un valore predefinito per il PERCORSO che garantisce che "
"vengano trovate tutte\n"
"    \tle utilità standard\n"
"      -v\tStampa una descrizione del COMANDO simile al comando interno \"type"
"\"\n"
"      -V\tStampa una descrizione più prolissa di ciascun COMANDO\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato di uscita del COMANDO o insuccesso se il COMANDO "
"non viene trovato."

#: builtins.c:490
#, fuzzy
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Imposta i valori e gli attributi delle variabili.\n"
"    \n"
"    Dichiara le variabili e fornisce loro attributi.  Se non vengono forniti "
"NOMI,\n"
"    visualizza gli attributi e i valori di tutte le variabili.\n"
"    \n"
"    Opzioni:\n"
"      -f\tLimita l'azione o la visualizzazione ai nomi e alle definizioni di "
"funzione\n"
"      -F\tLimita la visualizzazione ai soli nomi di funzione (più numero di "
"riga e\n"
"    \tfile sorgente durante il debug)\n"
"      -g\tCrea variabili globali quando usato in una funzione di shell; "
"altrimenti\n"
"    \tè ignorato\n"
"      -p\tVisualizza gli attributi e i valori di ciascun NOME\n"
"    \n"
"    Opzioni che impostano gli attributi:\n"
"      -a\tRende i NOMI array indicizzati (se supportata)\n"
"      -A\tRende i NOMI array associativi (se supportata)\n"
"      -i\tFornisce ai NOMI l'attributo \"integer\"\n"
"      -l\tConverte i NOMI in lettere minuscole in fase di assegnazione\n"
"      -r\tImposta i NOMI in sola lettura\n"
"      -t\tFornisce ai NOMI l'attributo \"trace\"\n"
"      -u\tConverte i NOMI in lettere maiuscole in fase di assegnazione\n"
"      -x\tImposta i NOMI come esportabili\n"
"    \n"
"    Usando \"+\" al posto di \"-\" disattiva l'attributo fornito.\n"
"    \n"
"    Le variabili con attributo intero vengono valutate aritmeticamente "
"(vedere\n"
"    il comando \"let\") quando alla variabile è assegnato un valore.\n"
"    \n"
"    Quando viene usato in una funzione, \"declare\" rende locali i NOMI, "
"come con\n"
"    il comando \"local\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o "
"si riscontri un errore."

#: builtins.c:532
#, fuzzy
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Imposta valori e attributi di variabile.\n"
"    \n"
"    Obsoleto. Vedere \"help declare\"."

#: builtins.c:540
#, fuzzy
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Definisce variabili locali.\n"
"    \n"
"    Crea una variabile locale chiamata NOME fornendogli un VALORE. L'OPZIONE "
"può\n"
"    essere una qualsiasi opzione accettata da \"declare\".\n"
"    \n"
"    Le variabili locali possono essere usate solo all'interno di una "
"funzione; sono\n"
"    visibili solo alla funzione nella quale sono definite e ai relativi "
"figli.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita un'opzione non valida, "
"non si\n"
"    riscontri un errore o la shell non stia eseguendo una funzione."

#: builtins.c:557
#, fuzzy
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by "
"a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value "
"HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal "
"value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Scrive argomenti sullo standard output.\n"
"    \n"
"    Visualizza gli ARG sullo standard output seguiti da un ritorno a capo.\n"
"    \n"
"    Opzioni:\n"
"      -n\tNon accoda un carattere di ritorno a capo\n"
"      -e\tAbilita l'interpretazione dei seguenti caratteri backslash di "
"escape\n"
"      -E\tDisabilita esplicitamente l'interpretazione dei caratteri "
"backslash di escape\n"
"    \n"
"    \"echo\" interpreta i seguenti caratteri backslash di escape:\n"
"      \\a\tavviso (campanello)\n"
"      \\b\tbackspace\n"
"      \\c\telimina ulteriore output\n"
"      \\e\tcarattere di escape\n"
"      \\f\tavanzamento pagina\n"
"      \\n\tritorno a capo\n"
"      \\r\tritorno carrello\n"
"      \\t\ttabulazione orizzontale\n"
"      \\v\ttabulazione verticale\n"
"      \\\\\tbackslash\n"
"      \\0nnn\til carattere il cui codice ASCII è NNN (ottale).  NNN può "
"avere\n"
"    \tda 0 a 3 cifre ottali\n"
"      \\xHH\til carattere otto bit il cui valore è HH (esadecimale).  HH "
"può\n"
"    \tavere una o due cifre esadecimali\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga riscontrato un errore di "
"scrittura."

#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Scrive argomenti sullo standard output.\n"
"    \n"
"    Visualizza gli ARG sullo standard output seguiti da un ritorno a capo.\n"
"    \n"
"    Opzioni:\n"
"      -n\tNon accoda un ritorno a capo\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga riscontrato un errore di "
"scrittura."

#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Abilita o disabilita comandi interni di shell.\n"
"    \n"
"    Abilita o disabilita comandi interni di shell. La disabilitazione "
"permette di\n"
"    eseguire un comando su disco che abbia lo stesso nome del comando "
"interno\n"
"    di shell senza dover usare un nome di percorso completo.\n"
"    \n"
"    Opzioni:\n"
"      -a\tStampa un elenco di comandi interni mostrando se sono abilitati o "
"meno\n"
"      -n\tDisabilita ogni NOME o visualizza un elenco di comandi interni "
"disabilitati\n"
"      -p\tStampa l'elenco dei comandi interni in un formato riusabile\n"
"      -s\tStampa solo i nomi dei comandi interni \"speciali\" Posix\n"
"    \n"
"    Opzioni che controllano il caricamento dinamico:\n"
"      -f\tCarica il comando interno NOME dall'oggetto condiviso NOMEFILE\n"
"      -d\tRimuove un comando interno caricato con -f\n"
"    \n"
"    Senza opzioni viene abilitato ogni NOME.\n"
"    \n"
"    Per usare il comando \"test\" trovato in $PATH invece di quello interno "
"della\n"
"    shell, digitare \"enable -n test\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che NOME non sia un comando interno di shell "
"o si riscontri un errore."

#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Esegue argomenti come un comando di shell.\n"
"    \n"
"    Combina gli ARGOMENTI dentro una singola stringa usando il risultato\n"
"    come input per la shell ed esegue i comandi risultanti.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato di uscita del comando o successo se il comando è "
"nullo."

#: builtins.c:652
#, fuzzy
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Analizza gli argomenti di opzione.\n"
"    \n"
"    Getopts è usato dalle procedure di shell per analizzare i parametri\n"
"    posizionali come opzioni.\n"
"    \n"
"    STRINGAOPZ contiene le lettere di opzione da riconoscere; se una "
"lettera\n"
"    è seguita da un due punti, ci si aspetta che l'opzione abbia un "
"argomento,\n"
"    che dovrebbe essere separato da uno spazio.\n"
"    \n"
"    Ogni volta che viene evocato getopts posiziona l'opzione successiva\n"
"    nella variabile di shell $nome inizializzando il nome, se non esiste,\n"
"    e l'indice dell'argomento successivo da elaborare nella variabile di\n"
"    shell OPTIND.  OPTIND è inizializzata a 1 ogni volta che viene invocata\n"
"    la shell o uno script di shell.  Quando una opzione richiede un "
"argomento,\n"
"    getopts posiziona tale argomento nella variabile di shell OPTARG.\n"
"    \n"
"    getopts riporta gli errori in uno o due modi.  Se il primo carattere "
"della\n"
"    STRINGAOPZ è un due punti, riporta gli errori in silenzio.  In questa\n"
"    modalità non vengono stampati messaggi di errore.  Se viene riscontrata "
"una\n"
"    opzione non valida, getopts posiziona il carattere di opzione trovato "
"in\n"
"    ARGOPZ.  Se un argomento richiesto non viene trovato, getopts posiziona\n"
"    un \":\" nel NOME e imposta ARGOPZ al carattere di opzione trovato.  Se "
"getopts\n"
"    non è in modalità silenziosa e viene riscontrata una opzione non valida, "
"getopts\n"
"    posiziona \"?\" nel NOME e azzera ARGOPZ.  Se un argomento richiesto non "
"viene\n"
"    trovato, viene posizionato un \"?\" nel NOME, ARGOPZ viene azzerato e "
"viene stampato\n"
"    un messaggio diagnostico.\n"
"    \n"
"    Se il valore della variabile di shell ERROPZ è pari a 0, getopts "
"disabilita\n"
"    la stampa dei messaggi di errore anche se il primo carattere della "
"STRINGAOPZ\n"
"    non è un due punti.  Il valore predefinito di ERROPZ è pari a 1.\n"
"    \n"
"    Getopts normalmente analizza i parametri posizionali ($0 - $9), ma se\n"
"    vengono forniti più argomenti, vengono analizzati questi ultimi.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo se viene trovata una opzione, insuccesso se viene "
"raggiunta\n"
"    la fine delle opzioni o viene riscontrato un errore."

#: builtins.c:694
#, fuzzy
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""
"Sostituisce la shell con il comando fornito.\n"
"    \n"
"    Esegue il COMANDO, sostituendo questa shell con il programma "
"specificato.\n"
"    Gli ARGOMENTI diventano gli argomenti per il COMANDO. Se il COMANDO non "
"è specificato,\n"
"    ogni redirezione avrà effetto nella shell corrente.\n"
"    \n"
"    Opzioni:\n"
"      -a nome\tPassa NOME come l'argomento zero per il COMANDO\n"
"      -c\t\tEsegue il COMANDO con un ambiente vuoto\n"
"      -l\t\tPosiziona un trattino nell'argomento zero per il COMANDO\n"
"    \n"
"    Se il comando non può essere eseguito una shell non interattiva esce, a "
"meno che\n"
"    non venga impostata l'opzione di shell \"execfail\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia trovato il COMANDO o si "
"riscontri un errore di ridirezione."

#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Esce dalla shell.\n"
"    \n"
"    Esce dalla shell con uno stato N. Se N è omesso lo stato di uscita\n"
"    è quello dell'ultimo comando eseguito."

#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""
"Esce da una shell di login.\n"
"    \n"
"    Esce da una shell di login con stato di uscita N. Restituisce un errore "
"se non eseguito\n"
"    in una shell di login."

#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""
"Visualizza o esegue comandi dall'elenco della cronologia.\n"
"    \n"
"    fc è usato per elencare, modificare e rieseguire comandi dall'elenco "
"della cronologia.\n"
"    PRIMO e ULTIMO possono essere numeri che specificano l'intervallo oppure "
"PRIMO può\n"
"    essere una stringa, nel qual caso significa il comando più recente che "
"inizia con\n"
"    quella stringa.\n"
"    \n"
"    Opzioni:\n"
"      -e EDITOR\tSeleziona l'editor da usare.  Il predefinito è FCEDIT, "
"quindi EDITOR,\n"
"    \t\tinfine vi\n"
"      -l \tElenca le righe invece di modificarle\n"
"      -n\tOmette i numeri di riga nell'elencare i comandi\n"
"      -r\tInverte l'ordine delle righe (elenca prima le più recenti)\n"
"    \n"
"    Con il formato \"fc -s [pat=rep ...] [comando]\", il COMANDO è\n"
"    rieseguito dopo aver effettuato la sostituzione VECCHIO=NUOVO.\n"
"    \n"
"    Un alias utile da usare insieme è r=\"fc -s\", in modo che digitando \"r "
"cc\"\n"
"    viene eseguito l'ultimo comando che inizia con \"cc\" e digitando \"r\" "
"riesegue\n"
"    l'ultimo comando.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo o lo stato del comando eseguito, non zero se si "
"riscontra un errore."

#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Sposta i job in primo piano.\n"
"    \n"
"    Mette il job identificato da SPEC_JOB in primo piano, rendendolo il\n"
"    job corrente.  Se SPEC_JOB non è presente, viene usata la nozione di\n"
"    job corrente della shell.\n"
"    \n"
"    Stato di uscita:\n"
"    Stato del comando messo in primo piano, o insuccesso se si riscontra un "
"errore."

#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Sposta i job sullo sfondo.\n"
"    \n"
"    Mette il  jobs identificato da ogni SPEC_JOB sullo sfondo, come se "
"fossero\n"
"    stati avviati con \"&\". Se SPEC_JOB non è presente, viene usata la "
"nozione\n"
"    di job corrente della shell.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che il controllo dei job non sia abilitato o "
"si riscontri un errore."

#: builtins.c:793
#, fuzzy
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Ricorda o visualizza le posizioni dei programmi.\n"
"    \n"
"    Determina e ricorda il nome completo di percorso per ogni comando NOME. "
"Se non\n"
"    viene fornito alcun argomento, sono visualizzate le informazioni sui "
"comandi memorizzati.\n"
"    \n"
"    Opzioni:\n"
"      -d\t\tDimentica la posizione memorizzata di ogni NOME\n"
"      -l\t\tVisualizza in un formato che può essere riusato come input\n"
"      -p nomepercorso\tUsa NOMEPERCORSO come il nome completo di percorso "
"per NOME\n"
"      -r\t\tDimentica tutte le posizioni memorizzate\n"
"      -t\t\tStampa la posizione memorizzata di ogni NOME, facendo\n"
"    \t\tprecedere ciascuna posizione con il NOME corrispondente se vengono\n"
"    \t\tforniti valori NOME multipli\n"
"    Argomenti:\n"
"      NOME\t\tOgni NOME è ricercato in $PATH e aggiunto all'elenco\n"
"    \t\tdei comandi memorizzati.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia trovato NOME o sia fornita una "
"opzione non valida."

#: builtins.c:818
#, fuzzy
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""
"Visualizza informazioni sui comandi interni.\n"
"    \n"
"    Visualizza un breve sommario dei comandi interni. Se viene specificato "
"il\n"
"    MODELLO fornisce un aiuto dettagliato su tutti i comandi corrispondenti "
"al\n"
"    MODELLO, altrimenti viene stampato l'elenco degli argomenti di aiuto.\n"
"    \n"
"    Opzioni:\n"
"      -d\tVisualizza una breve descrizione per ciascun argomento\n"
"      -m\tVisualizza l'uso in formato pseudo manpage\n"
"      -s\tVisualizza solo una breve sintassi sull'uso per ciascun argomento "
"che\n"
"    \tcorrisponde al MODELLO\n"
"    \n"
"    Argomenti:\n"
"      MODELLO\tModello che specifica un argomento di aiuto\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga trovato il MODELLO o sia "
"fornita una opzione non valida."

#: builtins.c:842
#, fuzzy
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Visualizza o manipola l'elenco della cronologia.\n"
"    \n"
"    Visualizza l'elenco della cronologia con i numeri di riga, aggiungendo a "
"ciascuna voce\n"
"    modificata il prefisso \"*\".  Un argomento pari a N elenca solo le "
"ultime N voci.\n"
"    \n"
"    Opzioni:\n"
"      -c\tPulisce la cronologia eliminando tutte le voci\n"
"      -d posiz\tElimina la voce della cronologia alla posizione POSIZ.\n"
"    \n"
"      -a\tAccoda righe al file della cronologia relative alla sessione "
"attuale\n"
"      -n\tLegge tutte le righe non ancora lette dal file della cronologia\n"
"      -r\tLegge il file della cronologia e ne accoda il contenuto all'elenco "
"della\n"
"    \t\tcronologia\n"
"      -w\tScrive la cronologia corrente nel file della cronologia\n"
"    \t\te ne accoda le voci all'elenco della cronologia\n"
"    \n"
"      -p\tEffettua l'espansione della cronologia su ciascun ARG e visualizza "
"il\n"
"    \t\trisultato senza memorizzarlo nell'elenco della cronologia\n"
"      -s\tAccoda gli ARG all'elenco della cronologia come una voce singola\n"
"    \n"
"    Se viene fornito il NOMEFILE, viene usato come file della cronologia.  "
"Altrimenti,\n"
"    se presente, viene usato il valore di $HISTFILE, in alternativa ~/."
"bash_history.\n"
"    \n"
"    Se la variabile $HISTTIMEFORMAT è impostata e non è nulla, il suo valore "
"viene usato\n"
"    come una stringa di formato per strftime(3) per stampare l'orario "
"associato a ciascuna\n"
"    voce di cronologia visualizzata.  Altrimenti non viene stampato alcun "
"orario.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o "
"si riscontri un errore."

#: builtins.c:879
#, fuzzy
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Visualizza lo stato dei job.\n"
"    \n"
"    Elenca i job attivi. SPECJOB limita l'output a quei job.\n"
"    Senza opzioni, è visualizzato lo stato di tutti i job attivi.\n"
"    \n"
"    Opzioni:\n"
"      -l\tElenca gli ID dei processi in aggiunta alle normali informazioni\n"
"      -n\tElenca solo i processi che hanno cambiato stato dall'ultima\n"
"    \tnotifica\n"
"      -p\tElenca solo l'ID dei processi\n"
"      -r\tLimita l'output ai job in esecuzione\n"
"      -s\tLimita l'output ai processi fermati\n"
"    \n"
"    Se viene fornito -x, il COMANDO è eseguito dopo che tutte le specifiche "
"dei job che\n"
"    appaiono in ARGOMENTI sono state rimpiazzate con l'ID del processo "
"leader nel gruppo di\n"
"    quel job.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o "
"si riscontri un errore.\n"
"    Se viene usato -x, restituisce lo stato di uscita del COMANDO."

#: builtins.c:906
#, fuzzy
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Rimuove job dalla shell corrente.\n"
"    \n"
"    Rimuove ciascun argomento SPECJOB dalla tabella dei job attivi.  Senza "
"alcun\n"
"    SPECJOB, la shell usa la sua nozione del job corrente.\n"
"    \n"
"    Opzioni:\n"
"      -a\tRimuove tutti i job se non viene fornito uno SPECJOB\n"
"      -h\tMarca ciascun SPECJOB in modo che non venga inviato un SIGHUP al "
"job se la\n"
"    \tshell lo riceve\n"
"      -r\tRimuove solo i job in esecuzione\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida "
"o uno SPECJOB."

#: builtins.c:925
#, fuzzy
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Invia un segnale a un job.\n"
"    \n"
"    Invia il segnale chiamato dallo SPECSEGN o dal NUMSEGN ai processi "
"identificati\n"
"    dal PID o dallo SPECJOB.  Se non è presente né lo SPECSEGN né il "
"NUMSEGN, viene\n"
"    allora considerato SIGTERM.\n"
"    \n"
"    Opzioni:\n"
"      -s segn\tSEGN è il nome di un segnale\n"
"      -n segn\tSEGN è il numero di un segnale\n"
"      -l\tElenca i nomi dei segnali; Se ci sono argomenti dopo \"-l\"\n"
"    \tvengono valutati come numeri di segnale di cui elencare i nomi\n"
"    \n"
"    Kill è un comando interno di shell per due ragioni: permette di usare "
"gli ID\n"
"    dei job invece degli ID dei processi e permette di uccidere quei "
"processi che\n"
"    abbiano raggiunto un numero limite prefissato di processi creabili.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o "
"si riscontri un errore."

#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Valuta espressioni aritmetiche.\n"
"    \n"
"    Valuta ciascun ARG come una espressione aritmetica.  La valutazione è "
"effettuata con\n"
"    interi a larghezza fissa senza alcun controllo per overflow, sebbene la "
"divisione\n"
"    per 0 sia bloccata e contrassegnata come un errore.  Il seguente elenco "
"di operatori\n"
"    è raggruppato per livelli di operatore di uguale precedenza.  I livelli "
"sono elencati\n"
"    in ordine di precedenza decrescente.\n"
"    \n"
"    \tid++, id--\tIncremento e decremento successivo di variabile\n"
"    \t++id, --id\tIncremento e decremento precedente di variabile\n"
"    \t-, +\t\tMeno e più unari\n"
"    \t!, ~\t\tNegazione logica e bit a bit\n"
"    \t**\t\tEsponenziazione\n"
"    \t*, /, %\t\tMoltiplicazione, divisione, resto\n"
"    \t+, -\t\tAddizione, sottrazione\n"
"    \t<<, >>\t\tScorrimento bit a bit sinistro e destro\n"
"    \t<=, >=, <, >\tComparazione\n"
"    \t==, !=\t\tUguaglianza, disuguaglianza\n"
"    \t&\t\tAND bit a bit\n"
"    \t^\t\tXOR bit a bit\n"
"    \t|\t\tOR bit a bit\n"
"    \t&&\t\tAND logico\n"
"    \t||\t\tOR logico\n"
"    \tespr ? espr : espr\n"
"    \t\t\tOperatore condizionale\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tAssegnazione\n"
"    \n"
"    Le variabili di shell sono ammesse come operandi.  Il nome della "
"variabile è\n"
"    sostituito dal suo valore (forzato a un intero a larghezza fissa) "
"all'interno\n"
"    di una espressione.  Non è necessario che la variabile abbia il proprio "
"attributo\n"
"    intero abilitato per essere usata in una espressione.\n"
"    \n"
"    Gli operatori sono valutati in ordine di precedenza.  Le "
"sottoespressioni tra\n"
"    parentesi sono valutate per prime e possono avere la precedenza sulle "
"regole\n"
"    sopradescritte.\n"
"    \n"
"    Stato di uscita:\n"
"    Se l'ultimo ARG viene valutato pari a 0 restituisce 1, altrimenti "
"restituisce 0."

#: builtins.c:994
#, fuzzy
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters. By default, the backslash character escapes delimiter "
"characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, "
"unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out\n"
"    (in which case it's greater than 128), a variable assignment error "
"occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Legge una riga dallo standard input e la divide in campi.\n"
"    \n"
"    Legge una singola riga dallo standard input o, se viene fornita "
"l'opzione -u,\n"
"    dal descrittore di file FD.  La riga è divisa in campi corrispondenti a\n"
"    parole dove la prima parola è assegnata al primo NOME, la seconda "
"parola\n"
"    al secondo NOME e così via, con ciascuna parola rimanente assegnata al\n"
"    corrispondente ultimo NOME.  Sono riconosciuti come delimitatori di "
"parola\n"
"    solo quelli presenti in $IFS.\n"
"    \n"
"    Se non viene fornito alcun NOME, la riga letta è memorizzata nella "
"variabile REPLY.\n"
"    \n"
"    Opzioni:\n"
"      -a array\tAssegna le parole lette agli indici sequenziali della "
"variabile\n"
"    \t\tdi ARRAY, iniziando da zero\n"
"      -d delim\tContinua fino alla lettura del primo carattere di DELIM, "
"invece\n"
"    \t\tdi un ritorno a capo \n"
"      -e\t\tUsa Readline per ottenere la riga in una shell interattiva\n"
"      -i testo\tUsa TESTO come testo iniziale per Readline\n"
"      -n ncarat\tRitorna dopo la lettura di NCARAT caratteri invece di "
"attendere\n"
"    \t\tun a capo, ma rispetta un delimitatore se vengono letti meno di\n"
"    \t\tNCARAT caratteri prima del delimitatore stesso\n"
"      -N ncarat\tRitorna solo dopo la lettura di NCARAT caratteri esatti, a "
"meno che non si\n"
"    \t\triscontri un EOF o un time out di lettura, ignorando qualsiasi "
"delimitatore\n"
"      -p stringa\tVisualizza la stringa PROMPT senza un a capo finale prima\n"
"    \t\tdel tentativo di lettura\n"
"      -r\t\tNon ammette backslash per fare l'escape dei caratteri\n"
"      -s\t\tNon fa l'echo dell'input proveniente da un terminale\n"
"      -t secondi\tVa in timeout e restituisce insuccesso se non viene letta "
"una\n"
"    \t\triga di input completa entro i SECONDI forniti.  Il valore della\n"
"    \t\tvariabile TMOUT è il timeout predefinito.  SECONDI può essere\n"
"    \t\tuna frazione.  Se SECONDI è pari a 0, la lettura restituisce "
"successo\n"
"    \t\tsolo se l'input è disponibile sul descrittore di file specificato.  "
"Lo\n"
"    \t\tstato di uscita è maggiore di 128 se viene superato il timeout\n"
"      -u fd\t\tLegge dal descrittore di file FD invece che dallo standard "
"input\n"
"    \n"
"    Stato di uscita:\n"
"    Il codice restituito è zero a meno che non sia riscontrato un EOF, un "
"timeout in lettura\n"
"    o venga fornito un descrittore di file non valido come argomento per -u."

#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Ritorna da una funzione di shell.\n"
"    \n"
"    Causa l'uscita da una funzione o da uno script sorgente con il valore "
"di\n"
"    ritorno specificato da N.  Se N è omesso, lo stato di ritorno è quello\n"
"    dell'ultimo comando eseguito all'interno della funzione o dello script.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce N, oppure insuccesso se la shell non sta eseguendo una "
"funzione o uno script."

#: builtins.c:1055
#, fuzzy
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell "
"functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Imposta o azzera i valori delle opzioni di shell e dei parametri "
"posizionali.\n"
"    \n"
"    Cambia il valore degli attributi di shell e dei parametri posizionali, "
"o\n"
"    visualizza i nomi e i valori delle variabili di shell.\n"
"    \n"
"    Opzioni:\n"
"      -a  Marca le variabili che sono modificate o create per "
"l'esportazione.\n"
"      -b  Notifica immediatamente della terminazione di un job.\n"
"      -e  Esce immediatamente se un comando esce con uno stao diverso da "
"zero.\n"
"      -f  Disabilita la generazione dei nomi file (globbing).\n"
"      -h  Ricorda la posizione dei comandi quando vengono cercati.\n"
"      -k  Tutte le assegnazioni degli argomenti sono posizionate "
"nell'ambiente per un\n"
"          comando, non solo quelle che precedono il nome del comando "
"stesso.\n"
"      -m  Abilita il controllo dei job.\n"
"      -n  Legge i comandi senza eseguirli.\n"
"      -o nome-opzione\n"
"          Imposta la variabile corrispondente al nome dell'opzione:\n"
"              allexport    Uguale a -a\n"
"              braceexpand  Uguale a -B\n"
"              emacs        Usa una interfaccia di modifica righe di stile "
"emacs\n"
"              errexit      Uguale a -e\n"
"              errtrace     Uguale a -E\n"
"              functrace    Uguale a -T\n"
"              hashall      Uguale a -h\n"
"              histexpand   Uguale a -H\n"
"              history      Abilita la cronologia comandi\n"
"              ignoreeof    Non esce dalla shell dopo aver raggiunto EOF\n"
"              interactive-comments\n"
"                           Permette ai commenti di comparire nei comandi "
"interattivi\n"
"              keyword      Uguale a -k\n"
"              monitor      Uguale a -m\n"
"              noclobber    Uguale a -C\n"
"              noexec       Uguale a -n\n"
"              noglob       Uguale a -f\n"
"              nolog        Accettato al momento ma ignorato\n"
"              notify       Uguale a -b\n"
"              nounset      Uguale a -u\n"
"              onecmd       Uguale a -t\n"
"              physical     Uguale a -P\n"
"              pipefail     Il valore restituito da una pipeline è lo stato\n"
"                           dell'ultimo comando che esce con uno stato "
"diverso da zero,\n"
"                           oppure zero se nessun comando esce con uno stato "
"diverso da zero\n"
"              posix        Modifica il comportamento di bash dove "
"l'operazione\n"
"                           predefinita è diversa dallo standard Posix per "
"rispettare\n"
"                           lo standard stesso\n"
"              privileged   Uguale a -p\n"
"              verbose      Uguale a -v\n"
"              vi           Usa un'editor di riga stile vi\n"
"              xtrace       Uguale a -x\n"
"      -p  Abilitato ogni qualvolta gli id utente reali non corrispondono a "
"quelli effettivi.\n"
"          Disabilita l'analisi del file $ENV e l'importazione delle funzioni "
"di\n"
"          shell.  Disabilitare questa opzione comporta l'impostazione degli\n"
"          uid e gid effettivi a uid e gid reali.\n"
"      -t  Esce dopo la lettura e l'esecuzione di un comando.\n"
"      -u  Tratta le variabili non impostate come un errore durante la "
"sostituzione.\n"
"      -v  Stampa le righe di input della shell mentre vengono lette.\n"
"      -x  Stampa i comandi e i loro argomenti mentre vengono eseguiti.\n"
"      -B  La shell effettua l'espansione delle parentesi graffe\n"
"      -C  Se impostata, non permette la sovrascrittura dei file regolari "
"esistenti\n"
"          da parte della redirezione dell'output.\n"
"      -E  Se impostata, la trap ERR è ereditata dalle funzioni di shell.\n"
"      -H  Abilita la sostituzione per la cronologia stile !.  Questo flag è "
"abilitato\n"
"          in modo predefinito quando la shell è interattiva.\n"
"      -P  Se impostata, non segue i link simbolici quando vengono eseguiti "
"dei comandi\n"
"          come cd, il quale cambia la directory corrente.\n"
"      -T  Se impostata, la trap DEBUG è ereditata dalle funzioni di shell.\n"
"      --  Assegna tutti gli argomenti rimasti ai parametri posizionali.\n"
"          Se non sono rimasti argomenti, i parametri posizionali\n"
"          vengono azzerati.\n"
"      -   Assegna tutti gli argomenti rimasti ai parametri posizionali.\n"
"          Le opzioni -x e -v sono disabilitate.\n"
"    \n"
"    Usando + al posto di - questi flag vengono disabilitati.  I\n"
"    flag possono anche essere usati subito dopo l'invocazione della shell.  "
"Il set corrente\n"
"    dei flag può essere trovato in $-.  I restanti n ARG sono parametri\n"
"    posizionali e vengono assegnati, in ordine, a $1, $2, .. $n.  Se non\n"
"    vengono forniti ARG, vengono stampate tutte le variabili di shell.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida."

#: builtins.c:1140
#, fuzzy
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Azzera i valori e gli attributi delle variabili e delle funzioni di shell.\n"
"    \n"
"    Per ciascun NOME, rimuove la corrispondente variabile o funzione.\n"
"    \n"
"    Opzioni:\n"
"      -f\tConsidera ciascun NOME come una funzione di shell\n"
"      -v\tConsidera ciascun NOME come una variabile di shell\n"
"    \n"
"    Senza opzioni, unset prova prima ad azzerare una variabile e, in caso di "
"insuccesso,\n"
"    prova ad azzerare una funzione.\n"
"    \n"
"    Alcune variabili non possono essere azzerate; vedere anche \"readonly"
"\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o "
"NOME sia in sola lettura."

#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Imposta l'attributo di esportazione per le variabili di shell.\n"
"    \n"
"    Marca ciascun NOME per l'esportazione automatica all'ambiente dei "
"comandi\n"
"    eseguiti successivi.  Se è fornito un VALORE, lo assegna prima "
"dell'esportazione.\n"
"    \n"
"    Opzioni:\n"
"      -f\tRimanda alle funzioni di shell\n"
"      -n\tRimuove la proprietà di esportazione da ciascun NOME\n"
"      -p\tVisualizza un elenco di tutte le variabili e funzioni esportate\n"
"    \n"
"    L'argomento \"--\" disabilita l'elaborazione di ulteriori opzioni.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o "
"il NOME non sia valido."

#: builtins.c:1181
#, fuzzy
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Marca la variabili di shell come non modificabili.\n"
"    \n"
"    Marca ciascun NOME in sola lettura; i valori di questi NOMI non possono\n"
"    essere modificati da un assegnamento successivo.  Se viene fornito il\n"
"     VALORE, lo assegna prima di marcarlo in sola lettura.\n"
"    \n"
"    Opzioni:\n"
"      -a\tRimanda alle variabili degli array indicizzati\n"
"      -A\tRimanda alle variabili degli array associativi\n"
"      -f\tRimanda alle funzioni di shell\n"
"      -p\tVisualizza un elenco di tutte le variabili e le funzioni in sola "
"lettura\n"
"    \n"
"    Un argomento pari a \"--\" disabilita ulteriori analisi delle opzioni.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida "
"o NOME non sia valido."

#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Sposta i parametri posizionali.\n"
"    \n"
"    Rinomina i parametri posizionali $N+1,$N+2 ... a $1,$2 ...  Se N non\n"
"    è fornito, viene assunto a 1.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che N non sia negativo o maggiore di $#."

#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Esegue comandi da un file nella shell corrente.\n"
"    \n"
"    Legge ed esegue comandi da NOMEFILE nella shell corrente. Le voci\n"
"    in $PATH sono usate per trovare la directory contenente il NOMEFILE.\n"
"    Se vengono forniti ARGOMENTI, essi diventano i parametri di posizione\n"
"    quando viene eseguito NOMEFILE.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito in NOMEFILE; "
"insuccesso se\n"
"    il NOMEFILE non può essere letto."

#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Sospende l'esecuzione della shell.\n"
"    \n"
"    Sospende l'esecuzione di questa shell fino a che non riceve un segnale "
"SIGCONT.\n"
"    A meno di forzature, le shell di login non possono essere sospese.\n"
"    \n"
"    Opzioni:\n"
"      -f\tForza la sospensione, anche se in presenza di una shell di login\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia abilitato il controllo job o si "
"riscontri un errore."

#: builtins.c:1262
#, fuzzy
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Analizza espressioni condizionali.\n"
"    \n"
"    Esce con stato 0 (vero) o 1 (falso) in base all'analisi\n"
"    dell'ESPR.  Le espressioni possono essere unarie o binarie.  Le\n"
"    espressioni unarie sono spesso usate per esaminare lo stato di un file.\n"
"    Esistono anche operatori di stringa e di comparazione numerica.\n"
"    \n"
"    Il comportamento del test dipende dal numero degli argomenti.  Leggere\n"
"    la pagina di manuale di bash per le specifiche complete.\n"
"    \n"
"    Operatori su file:\n"
"    \n"
"      -a FILE        Vero se il file esiste.\n"
"      -b FILE        Vero se è un file speciale a blocchi.\n"
"      -c FILE        Vero se è un file speciale a caratteri.\n"
"      -d FILE        Vero se il file è una directory.\n"
"      -e FILE        Vero se il file esiste.\n"
"      -f FILE        Vero se il file esiste ed è un file regolare.\n"
"      -g FILE        Vero se il file è un set-group-id.\n"
"      -h FILE        Vero se il file è un link simbolico.\n"
"      -L FILE        Vero se il file è un link simbolico.\n"
"      -k FILE        Vero se il file ha il suo bit \"sticky\" impostato.\n"
"      -p FILE        Vero se il file è una pipe con nome.\n"
"      -r FILE        Vero se il file è leggibile dall' utente corrente.\n"
"      -s FILE        Vero se il file esiste e non è vuoto.\n"
"      -S FILE        Vero se il file è un socket.\n"
"      -t FD          Vero se il descrittore di file è aperto su un "
"terminale.\n"
"      -u FILE        Vero se il file è un set-user-id.\n"
"      -w FILE        Vero se il file è scrivibile dall'utente corrente.\n"
"      -x FILE        Vero se il file è eseguibile dall'utente corrente.\n"
"      -O FILE        Vero se l'utente corrente è il reale proprietario del "
"file.\n"
"      -G FILE        Vero se il gruppo dell'utente corrente è il reale "
"proprietario del file.\n"
"      -N FILE        Vero se il file è stato modificato dall'ultima volta "
"che è stato letto.\n"
"    \n"
"      FILE1 -nt FILE2  Vero se il file1 è più recente del file2 (in accordo "
"con la\n"
"                       data di modifica).\n"
"    \n"
"      FILE1 -ot FILE2  Vero se il file1 è più vecchio del file2.\n"
"    \n"
"      FILE1 -ef FILE2  Vero se il file1 è un link hardware al file2.\n"
"    \n"
"    Operatori di stringa:\n"
"    \n"
"      -z STRINGA     Vero se la stringa e vuota.\n"
"    \n"
"      -n STRINGA\n"
"         STRINGA     Vero se la stringa non è vuota.\n"
"    \n"
"      STRINGA1 = STRINGA2\n"
"                     Vero se le stringhe sono uguali.\n"
"      STRINGA1 != STRINGA2\n"
"                     Vero se le stringhe non sono uguali.\n"
"      STRINGA1 < STRINGA2\n"
"                     Vero se la STRINGA1 viene ordinata lessicograficamente "
"prima della STRINGA2.\n"
"      STRINGA1 > STRINGA2\n"
"                     Vero se la STRINGA1 viene ordinata lessicograficamente "
"dopo la STRINGA2.\n"
"    \n"
"    Altri operatori:\n"
"    \n"
"      -o OPZIONE     Vero se l'OPZIONE di shell è abilitata.\n"
"      -v VAR\t Vero se la variabile di shell VAR è impostata.\n"
"      ! ESPR         Vero se l'ESPR è falsa.\n"
"      ESPR1 -a ESPR2 Vero se entrambe le espressioni espr1 E espr2 sono "
"vere.\n"
"      ESPR1 -o ESPR2 Vero se sono vere le espressioni espr1 O espr2.\n"
"    \n"
"      arg1 OP arg2   Test aritmetici.  OP è uno tra -eq, -ne,\n"
"                     -lt, -le, -gt oppure -ge.\n"
"    \n"
"    Gli operatori aritmetici binari restituiscono vero se ARG1 è uguale, non "
"uguale,\n"
"    più piccolo di, più piccolo o uguale, più grande di o più grande o "
"uguale\n"
"    ad ARG2.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo se l'ESPR viene valutata vera; insuccesso se l'ESPR "
"viene valutata\n"
"    falsa o viene fornito un argomento non valido."

#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Valuta l'espressione condizionale.\n"
"    \n"
"    Questo è un sinonimo del comando interno \"test\", ma l'ultimo argomento "
"deve\n"
"    essere un \"]\" letterale per corrispondere al \"[\" di apertura."

#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Visualizza le durate dei processi.\n"
"    \n"
"    Stampa i tempi utente e di sistema accumulati per la shell e per tutti "
"i\n"
"    relativi processi figli.\n"
"    \n"
"    Stato di uscita:\n"
"    Sempre successo."

#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  "
"If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or "
"a\n"
"    script run by the . or source builtins finishes executing.  A "
"SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause "
"the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""
"Esegue il trap dei segnali e di altri eventi.\n"
"    \n"
"    Definisce e attiva i gestori da eseguire quando la shell riceve segnali\n"
"    o altre condizioni.\n"
"    \n"
"    ARG è un comando da leggere ed eseguire quando la shell riceve il o i\n"
"    segnali SPEC_SEGNALE.  Se ARG o \"-\" non sono presenti (e viene "
"fornito\n"
"    un singolo SPEC_SEGNALE), ciascun segnale specificato è riportato\n"
"    al suo valore originario.  Se ARG è pari a null, ogni SPEC_SEGNALE è\n"
"    ignorato dalla shell e dai comandi che invoca.\n"
"    \n"
"    Se uno SPEC_SEGNALE è EXIT (0) ARG viene eseguito all'uscita dalla "
"shell.  Se\n"
"    lo SPEC_SEGNALE è DEBUG, ARG viene eseguito prima di ogni comando "
"semplice.  Se\n"
"    uno SPEC_SEGNALE è RETURN, ARG viene eseguito al termine di ogni "
"esecuzione\n"
"    di una funzione di shell o di uno script avviato dai comandi interni . o "
"source.\n"
"    Un SPEC_SEGNALE di ERR significa eseguire ARG ogni volta che un errore "
"di comando\n"
"    causi l'uscita della shell quando è abilitata l'opzione -e.\n"
"    \n"
"    Se non vengono forniti argomenti, trap stampa l'elenco di comandi "
"associati\n"
"    a ciascun segnale.\n"
"    \n"
"    Ozioni:\n"
"      -l\tStampa un elenco di nomi di segnale e i loro corrispondenti "
"numeri\n"
"      -p\tVisualizza i comandi trap associati a ciascun SPEC_SEGNALE\n"
"    \n"
"    Ciascun SPEC_SEGNALE è un nome di segnale in <signal.h> oppure un numero "
"di segnale.\n"
"    I nomi di segnale sono case insensitive e il prefisso SIG è opzionale.  "
"Per\n"
"    inviare un segnale alla shell usare \"kill -signal $$\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che SPEC_SEGNALE non sia valido o si "
"fornisca una opzione non valida."

#: builtins.c:1401
#, fuzzy
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""
"Visualizza informazioni sul tipo di comando.\n"
"    \n"
"    Per ciascun NOME, indica come sarebbe interpretato se fosse usato come\n"
"    un nome di comando.\n"
"    \n"
"    Opzioni:\n"
"      -a\tVisualizza tutte le posizioni contenenti un eseguibile chiamato "
"NOME,\n"
"    \tincludendo alias, comandi interni e funzioni se e solo se\n"
"    \tnon viene usata anche l'opzione \"-p\"\n"
"      -f\tNon esegue la ricerca delle funzioni di shell\n"
"      -P\tForza una ricerca del PERCORSO per ciascun NOME anche se è un "
"alias,\n"
"    \tun comando interno o una funzione, e restituisce il nome del file su "
"disco\n"
"    \tche sarebbe eseguito\n"
"      -p\tRestituisce o il nome del file su disco che sarebbe eseguito,\n"
"    \toppure niente se \"type -t NOME\" non restituisce \"file\".\n"
"      -t\tVisualizza una singola parola che è una tra \"alias\", \"keyword"
"\",\n"
"    \t\"function\", \"builtin\", \"file\" or \"\", se il NOME è "
"rispettivamente un alias,\n"
"    \tuna parola riservata di shell, una funzione di shell, un comando "
"interno di shell,\n"
"    \tun file su disco o non trovato\n"
"    \n"
"    Argomenti:\n"
"      NOME\tIl nome del comando da interpretare.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo se tutti i NOMI vengono trovati; insuccesso in caso "
"contrario."

#: builtins.c:1432
#, fuzzy
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Modifica i limiti delle risorse di shell.\n"
"    \n"
"    Fornisce il controllo sulle risorse disponibili per la shell e per i "
"processi\n"
"    che crea, sui sistemi che permettono tale controllo.\n"
"    \n"
"    Opzioni:\n"
"      -S\tUsa il limite di risorse \"leggero\"\n"
"      -H\tUsa il limite di risorse \"pesante\"\n"
"      -a\tRiporta tutti i limiti correnti\n"
"      -b\tLa dimensione del buffer del socket\n"
"      -c\tLa dimensione massima dei file di core creati\n"
"      -d\tLa dimensione massima di un segmento di dati di processo\n"
"      -e\tLa priorità massima di scheduling (\"nice\")\n"
"      -f\tLa dimensione massima dei file scritti dalla shell e dai suoi "
"figli\n"
"      -i\tIl numero massimo di segnali pendenti\n"
"      -l\tLa dimensione massima di memoria che un processo può impegnare\n"
"      -m\tIl numero massimo di set residenti\n"
"      -n\tIl numero massimo di descrittori di file aperti\n"
"      -p\tLa dimensione del buffer della pipe\n"
"      -q\tIl numero massimo di byte nelle code messaggi POSIX\n"
"      -r\tLa priorità massima di scheduling in tempo reale\n"
"      -s\tLa dimensione massima dello stack\n"
"      -t\tLa quantità massima di tempo CPU in secondi\n"
"      -u\tIl numero massimo di processi utente\n"
"      -v\tLa dimensione della memoria virtuale\n"
"      -x\tIl numero massimo di lock dei file\n"
"    \n"
"    Se viene fornito un LIMITE, sarà il nuovo valore della risorsa "
"specificata;\n"
"    I valori LIMITE speciali \"soft\", \"hard\" e \"unlimited\" "
"corrispondono\n"
"    rispettivamente agli attuali limiti leggero, pesante e senza limite.\n"
"    Altrimenti viene stampato il valore attuale della risorsa specificata.  "
"Se\n"
"    non viene fornita alcuna opzione, viene assunta -f.\n"
"    \n"
"    I valori sono ad incrementi di 1024-byte, ad eccezione di -t che è in "
"secondi,\n"
"    -p che è ad incrementi di 512 byte e -u che è un numero di processi non\n"
"    scalato.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida "
"o venga riscontrato un errore."

#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Visualizza o imposta la maschera del modo file.\n"
"    \n"
"    Imposta la maschera di creazione file dell'utente su MODO.  Se MODO "
"viene omesso, stampa\n"
"    il valore corrente della maschera.\n"
"    \n"
"    Se MODO inizia con una cifra, è interpretato con un numero ottale;\n"
"    altrimenti come una stringa di modo simbolico come quella accettata da "
"chmod(1).\n"
"    \n"
"    Opzioni:\n"
"      -p\tSe MODO viene omesso, mostra in una forma che possa essere riusata "
"come input\n"
"      -S\tRende simbolico l'output; altrimenti viene mostrato un numero "
"ottale\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che MODO non sia valido o venga fornita una "
"opzione non valida."

#: builtins.c:1503
#, fuzzy
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or "
"a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of "
"IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns "
"its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, "
"before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Attende il completamento del job restituendo lo stato di uscita.\n"
"    \n"
"    Attende il processo identificato dall'ID, che può essere un ID di "
"processo o\n"
"    una specifica di job, riportando il suo stato di termine.  Se non è\n"
"    fornito un ID, attende tutti i processi figlio correntemente attivi, "
"restituendo\n"
"    zero come stato.  Se l'ID è una specifica di job, attende tutti i "
"processi\n"
"    presenti nella pipeline del job.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ID; insuccesso se l'ID non è valido o viene "
"fornita una\n"
"    opzione non valida."

#: builtins.c:1534
#, fuzzy
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination "
"status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an "
"invalid\n"
"    option is given."
msgstr ""
"Attende il completamento del processo e restituisce lo stato di uscita.\n"
"    \n"
"    Attende per il processo specificato e riporta il suo stato di "
"terminazione.  Se non\n"
"    viene fornito il PID, l'attesa comprende tutti i processi figlio "
"correntemente attivi\n"
"    e il codice restituito è zero.  Il PID deve essere un ID di processo.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ID; insuccesso se l'ID non è valido o viene "
"fornita una opzione non\n"
"    valida."

#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Esegue comandi per ciascun membro di un elenco.\n"
"    \n"
"    Il ciclo \"for\" esegue una sequenza di comandi per ciascun membro di "
"un\n"
"    elenco di voci.  Se \"in PAROLE ...;\" non è presente, allora viene "
"assunto\n"
"    \"in \"$@\"\".  Per ciascun elemento in PAROLE, NOME è impostato a "
"quell'elemento e\n"
"    i COMANDI vengono eseguiti.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ciclo \"for\" aritmetico.\n"
"    \n"
"    Equivalente a\n"
"    \t(( ESPR1 ))\n"
"    \twhile (( ESPR2 )); do\n"
"    \t\tCOMANDI\n"
"    \t\t(( ESPR3 ))\n"
"    \tdone\n"
"    ESPR1, ESPR2 e ESPR3 sono espressioni aritmetiche.  Se viene omessa "
"qualche\n"
"    espressione, si comporta come se valesse 1.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Seleziona le parole da un elenco ed esegue i comandi.\n"
"    \n"
"    Le PAROLE vengono estese, generando un elenco di parole.  L'insieme\n"
"    di parole estese viene stampato sullo standard error, ognuna delle\n"
"    quali preceduta da un numero.  Se non è presente \"in PAROLE\", viene\n"
"    assunto `in \"$@\".  Viene poi visualizzato il prompt PS3 e viene letta\n"
"    una riga dallo standard input.  Se la riga è composta dal numero che\n"
"    corrisponde a una delle parole visualizzate, NOME è impostato a quella\n"
"    parola.  Se la riga è vuota, Le PAROLE e il prompt vengono "
"rivisualizzati.\n"
"    Se viene letto EOF, il comando termina.  Se vengono letti altri valori\n"
"    NOME viene impostato a null.  La riga letta viene salvata nella "
"variabile\n"
"    REPLY.  I COMANDI vengono eseguiti dopo ogni selezione finché non viene\n"
"    eseguito un comando di interruzione.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato di uscita dell'ultimo comando eseguito."

#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Riporta il tempo speso nell'esecuzione della pipeline.\n"
"    \n"
"    Esegue la PIPELINE e stampa, quando termina, un sommario del tempo "
"reale, tempo utente della CPU\n"
"    e tempo di sistema della CPU dedicato all'esecuzione della PIPELINE.\n"
"    \n"
"    Opzioni:\n"
"      -p\tStampa il riepilogo dei tempi nel formato portabile Posix format\n"
"    \n"
"    Il valore della variabile TIMEFORMAT è usato come formato di output.\n"
"    \n"
"    Stato di uscita:\n"
"    Viene restituito lo stato della PIPELINE."

#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Esegue comandi basati sulla corrispondenza di modello.\n"
"    \n"
"    Esegue in modo selettivo COMANDI basati sulla PAROLA corrispondente al "
"MODELLO.  Il\n"
"    carattere \"|\" è usato per separare modelli multipli.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Esegue comandi basati su condizioni.\n"
"    \n"
"    Viene eseguito l'elenco degli \"if COMANDI\".  Se lo stato di uscita è "
"zero\n"
"    viene eseguito l'elenco \"then COMANDI\", altrimenti viene eseguito "
"l'elenco\n"
"    degli \"elif COMANDI\" e, se il loro stato è zero, viene eseguito "
"l'elenco dei\n"
"    \"then COMANDI\" corrispondente e viene completato l'\"if COMANDO\".  "
"Altrimenti,\n"
"    viene eseguito l'elenco \"else COMANDI\", se presente.  Lo stato di "
"uscita\n"
"    dell'intero costrutto corrisponde a quello dell'ultimo comando eseguito, "
"o\n"
"    zero se nessuna condizione provata è vera.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1648
#, fuzzy
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Esegue i comandi finché un test ha successo.\n"
"    \n"
"    Espande ed esegue i COMANDI fino a quando il comando finale nei\n"
"    COMANDI \"while\" ha uno stato di uscita pari a zero.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1660
#, fuzzy
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Esegue i comandi finché un test non ha successo.\n"
"    \n"
"    Espande ed esegue i COMANDI fino a quando il comando finale nei\n"
"    COMANDI \"until\" ha uno stato di uscita diverso da zero.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1672
#, fuzzy
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Crea un coprocesso chiamato NOME.\n"
"    \n"
"    Esegue il COMANDO in modo asincrono, con lo standard output e lo "
"standard\n"
"    input del comando connessi attraverso una pipe ai descrittori di file "
"assegnati\n"
"    agli indici 0 e 1 di una variabile di array NOME nella shell in "
"esecuzione.\n"
"    Il NOME predefinito è \"COPROC\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato di uscita del COMANDO."

#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Definisce una funzione di shell.\n"
"    \n"
"    Crea una funzione di shell chiamata NOME.  Quando invocato come un "
"semplice comando,\n"
"    NOME esegue i COMANDI nel contesto delle chiamate di shell.  Quando "
"viene invocato NOME,\n"
"    gli argomenti sono passati alla funzione come $1...$n e il nome della "
"funzione si trova\n"
"    in $FUNCNAME.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che il NOME non sia in sola lettura."

#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Raggruppa i comandi come un'unità.\n"
"    \n"
"    Esegue un set di comandi in un gruppo.  Questo è un modo per "
"reindirizzare un\n"
"    intero set di comandi.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Ripristina un job in primo piano.\n"
"    \n"
"    Equivale all'argomento SPEC_JOB per il comando \"fg\".  Ripristina\n"
"    un job fermato o sullo sfondo.  SPEC_JOB può specificare un nome\n"
"    job o un numero di job.  SPEC_JOB seguito da \"&\" mette il job\n"
"    sullo sfondo, come se la specifica del job fosse stata fornita\n"
"    come argomento per \"bg\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato del job ripristinato."

#: builtins.c:1727
#, fuzzy
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Valuta espressioni aritmetiche.\n"
"    \n"
"    L'ESPRESSIONE è valutata seguendo le regole di valutazione\n"
"    aritmetica. Equivalente a \"let ESPRESSIONE\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce 1 se ESPRESSIONE è valutata 0, altrimenti restituisce 0."

#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Esegue comandi condizionali.\n"
"    \n"
"    Resituisce uno stato di 0 o 1 a seconda della valutazione "
"dell'espressione\n"
"    condizionale ESPRESSIONE.  Le espressioni sono composte dalle stesse "
"basilari usate\n"
"    dal comando interno \"test\", e possono essere combinate usando i "
"seguenti operatori:\n"
"    \n"
"      ( ESPRESSIONE )\tRestituisce il valore dell'ESPRESSIONE\n"
"      ! ESPRESSIONE\t\tVero se l'ESPRESSIONE è falsa; falso in caso "
"contrario\n"
"      ESPR1 && ESPR2\tVero se sia ESPR1 che ESPR2 sono vere; falso in caso "
"contrario\n"
"      ESPR1 || ESPR2\tVero se una tra ESPR1 ed ESPR2 è vera; falso in caso "
"contrario\n"
"    \n"
"    Quando vengono usati gli operatori \"==\" e \"!=\", la stringa a destra "
"dell'operatore\n"
"    è usata come un modello e ne viene effettuata la corrispondenza.\n"
"    Quando viene usato l'operatore \"=~\", la stringa a destra "
"dell'operatore è valutata\n"
"    corrispondente a un'espressione regolare.\n"
"    \n"
"    Gli operatori && e || non valutano ESPR2 se ESPR1 è sufficiente a\n"
"    determinare il valore dell'espressione.\n"
"    \n"
"    Stato di uscita:\n"
"    0 o 1 a seconda del valore dell'ESPRESSIONE."

#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Nomi e usi comuni delle variabili di shell.\n"
"    \n"
"    BASH_VERSION\tInformazioni sulla versione di Bash.\n"
"    CDPATH\tUn elenco di directory da cercare separate da un due punti\n"
"    \tfornite come argomenti per \"cd\".\n"
"    GLOBIGNORE\tUn elenco di modelli separato da un due punti che descrivono "
"i nomi\n"
"    \t\tdi file che devono essere ignorati dall'espansione di percorso.\n"
"    HISTFILE\tIl nome del file in cui è memorizzata la cronologia dei "
"comandi.\n"
"    HISTFILESIZE\tIl numero massimo di righe che può contenere questo file.\n"
"    HISTSIZE\tIl numero massimo di righe di cronologia a cui può accedere\n"
"    \t\tuna shell in esecuzione.\n"
"    HOME\tIl nome completo del percorso della propria directory di login.\n"
"    HOSTNAME\tIl nome dell'host corrente.\n"
"    HOSTTYPE\tIl tipo di CPU sulla quale è in esecuzione questa versione di "
"bash.\n"
"    IGNOREEOF\tControlla il comportamento della shell quando riceve un "
"carattere EOF\n"
"    \t\tcome unico input.  Se impostato, il suo valore corrisponde al "
"numero\n"
"    \t\tdi caratteri EOF che si possono trovare in una fila in una riga "
"vuota\n"
"    \t\tprima che la shell esca (predefinito 10).  Quando viene azzerato, "
"EOF\n"
"    \t\tindica la fine dell'input.\n"
"    MACHTYPE\tUna stringa che descrive l'attuale sistema dove è in "
"esecuzione bash.\n"
"    MAILCHECK\tQuanto spesso, in secondi, Bash controlla la presenza di "
"nuova posta.\n"
"    MAILPATH\tUn elenco di nomi di file separati da un due punti usati da "
"Bash per\n"
"    \t\tcontrollare la presenza di nuova posta.\n"
"    OSTYPE\tLa versione di Unix sulla quale è in esecuzione questa versione "
"di bash.\n"
"    PATH\tUn elenco di directory, separato da un due punti, da analizzare "
"quando\n"
"    \t\tsi cercano i comandi.\n"
"    PROMPT_COMMAND\tUn comando da eseguire prima della stampa di ciascun "
"prompt\n"
"    \t\tprimario.\n"
"    PS1\t\tLa stringa del prompt primario.\n"
"    PS2\t\tLa stringa del prompt secondario.\n"
"    PWD\t\tIl nome completo del percorso della directory corrente.\n"
"    SHELLOPTS\tUn elenco di opzioni di shell abilitate, separate da un due "
"punti.\n"
"    TERM\tIl nome del tipo di terminale corrente.\n"
"    TIMEFORMAT\tIl formato di output per le statistiche temporali "
"visualizzato dalla\n"
"    \t\tparola riservata \"time\".\n"
"    auto_resume\tNon null significa che una parola di un comando che compare "
"da\n"
"    \t\taol in una riga viene prima cercata nell'elenco dei job correnti\n"
"    \t\tfermati.  Se trovato, questo job viene messo in primo piano.\n"
"    \t\tUn valore pari a \"exact\" significa che la parola del comando deve\n"
"    \t\tcorrispondere esattamente a un comando nell'elenco dei job fermati.  "
"Un\n"
"    \t\tvalore pari a \"substring\" significa che la parola del comando "
"deve\n"
"    \t\tcorrispondere a una sottostringa del job.  Qualsiasi altro valore "
"significa\n"
"    \t\tche il comando deve essere un prefisso di un lavoro fermato.\n"
"    histchars\tCaratteri che controllano l'espansione della cronologia e la "
"sostituzione\n"
"    \t\trapida.  Il primo carattere è quello di sostituzione della "
"cronologia,\n"
"    \t\tsolitamente \"!\".  Il secondo è il carattere di \"sostituzione "
"rapida\",\n"
"    \t\tsolitamente \"^\".  Il terzo è il carattere di \"commento della "
"cronologia\",\n"
"    \t\tsolitamente \"#\".\n"
"    HISTIGNORE\tUn elenco di modelli separato da un due punti usato per "
"decidere quale\n"
"    \t\tcomando dovrebbe essere salvato nell'elenco della cronologia.\n"

#: builtins.c:1822
#, fuzzy
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Aggiunge directory allo stack.\n"
"    \n"
"    Aggiunge una directory in cima allo stack delle directory o ruota lo\n"
"    stack stesso, mettendo come primo elemento la directory di lavoro\n"
"    corrente. Senza argomenti scambia le prime due directory in cima.\n"
"    \n"
"    Opzioni:\n"
"      -n\tEvita il normale cambio di directory quando vengono aggiunte\n"
"    \tdirectory allo stack, così da manipolare solo lo stack stesso.\n"
"    \n"
"    Argomenti:\n"
"      +N\tRuota lo stack in modo che l'N-sima directory (contando\n"
"    \ta partire da sinistra dell'elenco mostrato da \"dirs\", iniziando da\n"
"    \tzero) sia in cima.\n"
"    \n"
"      -N\tRuota lo stack in modo che l'N-sima directory (contando\n"
"    \ta partire da destra dell'elenco mostrato da \"dirs\", iniziando da\n"
"    \tzero) sia in cima.\n"
"    \n"
"      dir\tAggiunge DIR in cima allo stack delle directory, facendone la\n"
"    \tdirectory di lavoro corrente.\n"
"    \n"
"    Il comando interno \"dirs\" mostra lo stack delle directory.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornito un argomento valido o "
"non abbia\n"
"    successo il cambio di directory."

#: builtins.c:1856
#, fuzzy
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Rimuove directory dallo stack.\n"
"    \n"
"    Rimuove voci dallo stack delle directory. Senza argomenti, rimuove\n"
"     la directory in cima allo stack e cambia alla nuova prima directory.\n"
"    \n"
"    Opzioni:\n"
"      -n\tEvita il normale cambio di directory quando vengono rimosse\n"
"    \tdirectory dallo stack, così da manipolare solo lo stack stesso.\n"
"    \n"
"    Argomenti:\n"
"      +N\tRimuove l'N-sima voce contando a partire da sinistra dell'elenco\n"
"    \tmostrato da \"dirs\", iniziando da zero. Per esempio: \"popd +0\"\n"
"    \trimuove la prima directory, \"popd +1\" la seconda.\n"
"    \n"
"      -N\tRimuove l'N-sima voce contando a partire da destra dell'elenco\n"
"    \tmostrato da \"dirs\", iniziando da zero. Per esempio: \"popd -0\"\n"
"    \trimuove l'ultima directory, \"popd -1\" la penultima.\n"
"    \n"
"    Il comando interno \"dirs\" mostra lo stack delle directory.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornito un argomento non "
"valido o non\n"
"    abbia successo il cambio di directory."

#: builtins.c:1886
#, fuzzy
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Visualizza lo stack delle directory.\n"
"    \n"
"    Visualizza l'elenco delle directory ricordate attualmente. Le directory\n"
"    vengono inserite nell'elenco con il comando \"pushd\"; è possibile\n"
"    andare a ritroso nell'elenco con il comando \"popd\".\n"
"    \n"
"    Opzioni:\n"
"      -c\tPulisce lo stack delle directory eliminandone tutti gli elementi\n"
"      -l\tNon stampa le directory con prefisso tilde relative alla propria\n"
"    \tdirectory home\n"
"      -p\tStampa lo stack delle directory una voce per riga\n"
"      -v\tStampa lo stack delle directory una voce per riga usando come\n"
"    \tprefisso la posizione nello stack\n"
"    \n"
"    Argomenti:\n"
"      +N\tMostra l'N-sima voce contando a partire da sinistra dell'elenco\n"
"    \tmostrato da dirs quando invocato senza opzioni, iniziando da zero.\n"
"    \n"
"      -N\tMostra l'N-sima voce contando a partire da destro dell'elenco\n"
"    \tmostrato da dirs quando invocato senza opzioni, iniziando da zero.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita un'opzione non valida o "
"si riscontri un errore."

#: builtins.c:1917
#, fuzzy
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Imposta le opzioni della shell.\n"
"    \n"
"    Cambia le impostazioni di ciascuna opzione di shell NOMEOPZ.  Senza "
"argomenti\n"
"    per le opzioni, elenca tutte le opzioni di shell indicando se sono o non "
"sono\n"
"    impostate.\n"
"    \n"
"    Opzioni:\n"
"      -o\tLimita i NOMEOPZ a quelli definiti per essere usati con \"set -o"
"\"\n"
"      -p\tStampa ogni opzione di shell indicando il relativo stato\n"
"      -q\tNon stampa l'output\n"
"      -s\tAbilita (imposta) ciascun NOMEOPZ\n"
"      -u\tDisabilita (elimina) ciascun NOMEOPZ\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo se NOMEOPZ è abilitato; insuccesso se viene "
"fornita\n"
"    una opzione non valida o NOMEOPZ è disabilitato."

#: builtins.c:1938
#, fuzzy
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in "
"printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a "
"format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as "
"appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""
"Formatta e stampa gli ARGOMENTI come indicato dal FORMATO.\n"
"    \n"
"    Opzioni:\n"
"      -v var\tAssegna l'output alla variabile di shell VAR invece\n"
"    \t\tdi visualizzarlo sullo standard output\n"
"    \n"
"    FORMATO è una stringa di caratteri che contiene tre tipi di oggetto: "
"caratteri\n"
"    semplici, che sono semplicemente copiati sullo standard output; sequenze "
"di escape\n"
"    dei caratteri, che sono convertite e copiate sullo standard output;\n"
"    specifiche di formato, ognuna delle quali provoca la stampa del "
"successivo argomento\n"
"    consecutivo.\n"
"    \n"
"    In aggiunta alle specifiche di formato standard descritte in printf(1)\n"
"    e printf(3), printf interpreta:\n"
"    \n"
"      %b\tEspande le sequenze di escape di backslash nell'argomento "
"corrispondente\n"
"      %q\tQuota l'argomento in modo che possa essere riusato come input per "
"la shell\n"
"      %(fmt)T Visualizza la stringa della data/ora risultante dall'uso di "
"FMT come stringa\n"
"            di formato per strftime(3)\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida "
"o si riscontri\n"
"    un errore di scrittura o assegnazione."

#: builtins.c:1974
#, fuzzy
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are "
"supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -"
"I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Specifica come gli argomenti debbano essere completati da Readline.\n"
"    \n"
"    Per ciascun NOME, specifica come gli argomenti debbano essere "
"completati.  Se non\n"
"    vengono fornite opzioni, le specifiche di completamento esistenti sono "
"stampate in modo\n"
"    che possano essere riusate come input.\n"
"    \n"
"    Opzioni:\n"
"      -p\tStampa le specifiche di completamento esistenti in un formato "
"riusabile\n"
"      -r\tRimuove una specifica di completamento per ciascun NOME, oppure "
"tutte\n"
"    \tse non viene fornito alcun NOME\n"
"      -D\tApplica i completamenti e le azioni come predefiniti per i "
"comandi\n"
"    \tsenza alcun completamento definito specifico\n"
"      -E\tApplica i completamenti e le azioni ai comandi \"vuoti\" --\n"
"    \tcompletamenti tentati su una riga vuota\n"
"    \n"
"    Quando viene tentato un completamento, le azioni sono applicate "
"nell'ordine\n"
"    in cui sono sopra elencate le opzioni a lettera maiuscola.\n"
"    L'opzione -D ha precedenza su -E.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o "
"si riscontri un errore."

#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Visualizza i possibili completamenti a seconda delle opzioni.\n"
"    \n"
"    È pensata per essere usata all'interno di una funzione di shell per "
"generare\n"
"    dei possibili completamenti.  Se viene fornito l'argomento opzionale "
"PAROLA,\n"
"    vengono generate le corrispondenze relative a PAROLA.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o "
"si riscontri un errore."

#: builtins.c:2019
#, fuzzy
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Modifica o visualizza le opzioni di completamento.\n"
"    \n"
"    Modifica le opzioni di completamento per ciascun NOME, oppure, se non "
"viene fornito alcun NOME,\n"
"    il completamento attualmente in esecuzione.  Con nessuna OPZIONE "
"fornita, stampa\n"
"    le opzioni di completamento per ciascun NOME o le specifiche di "
"completamento correnti.\n"
"    \n"
"    Opzioni:\n"
"    \t-o opzione\tImposta l'OPZIONE di completamento per ciascun NOME\n"
"    \t-D\t\tCambia le opzioni per il completamento di comando \"predefinito"
"\"\n"
"    \t-E\t\tCambia le opzioni per il completamento di comando \"vuoto\"\n"
"    \n"
"    Usando \"+o\" al posto di \"-o\" disabilita l'opzione specificata.\n"
"    \n"
"    Argomenti:\n"
"    \n"
"    Ciascun NOME si riferisce a un comando per il quale deve essere stata "
"precedentemente\n"
"    definita una specifica di completamento con il comando interno \"complete"
"\".  Se non viene fornito\n"
"    alcun NOME, compopt deve essere richiamato da una funzione che generi "
"attualmente\n"
"    completamenti, e le opzioni per questo generatore di completamenti "
"attualmente\n"
"    in esecuzione sono modificate\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida "
"o NOME non\n"
"    abbia una specifica di completamento definita."

#: builtins.c:2050
#, fuzzy
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable "
"ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable "
"MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard "
"input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly "
"or\n"
"    not an indexed array."
msgstr ""
"Legge righe dallo standard input in una variabile di array indicizzato.\n"
"    \n"
"    Legge righe dallo standard input nella variabile di ARRAY indicizzato, "
"oppure\n"
"    dal descrittore di file FD se viene fornita l'opzione -u.  La variabile "
"MAPFILE\n"
"    è l'ARRAY predefinito.\n"
"    \n"
"    Opzioni:\n"
"      -n numero\t\tCopia al massimo un NUMERO di righe.  Se NUMERO è 0, "
"vengono copiate tutte.\n"
"      -O origine\tInizia assegnando all'ARRAY all'indice ORIGINE.  L'indice "
"predefinito è 0.\n"
"      -s numero \tScarta le prime NUMERO righe lette.\n"
"      -t\t\tRimuove un ritorno a capo finale da ciascuna riga letta.\n"
"      -u fd\t\tLegge le righe da un descrittore di file FD invece che dallo "
"standard input.\n"
"      -C callback\tEsamina CALLBACK ogni volta che vengono lette un numero "
"QUANTO di righe.\n"
"      -c quantità\tSpecifica il numero di righe lette tra ciascuna chiamata "
"a CALLBACK.\n"
"    \n"
"    Argomenti:\n"
"      ARRAY\t\tNome della variabile di array da usare per i dati dei file.\n"
"    \n"
"    Se viene fornito -C senza -c, il quanto predefinito è 5000.  Quando\n"
"    viene analizzata CALLBACK, viene fornito l'indice dell'elemento di\n"
"    array successivo da assegnare e la riga da attribuire a quell'elemento\n"
"    come argomenti aggiuntivi.\n"
"    \n"
"    Se non viene fornito con una origine esplicita, il file di mappa "
"azzererà l'ARRAY\n"
"    prima della relativa assegnazione.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non "
"valida, ARRAY sia\n"
"    in sola lettura oppure non indicizzato."

#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Legge le righe da un file in una variabile di array.\n"
"    \n"
"    Sinonimo per \"mapfile\"."

#, c-format
#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: chiave dell'array associativo non valida"

#, fuzzy
#~ msgid "Copyright (C) 2019 Free Software Foundation, Inc."
#~ msgstr "Copyright © 2011 Free Software Foundation, Inc."

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns "
#~ msgstr ""
#~ "Restituisce il contesto della chiamata alla subroutine corrente.\n"
#~ "    \n"
#~ "    Senza ESPR, restituisce "

#~ msgid "add_process: process %5ld (%s) in the_pipeline"
#~ msgstr "add_process: processo %5ld (%s) in the_pipeline"

#~ msgid "Unknown Signal #"
#~ msgstr "Numero di segnale sconosciuto"

#~ msgid ""
#~ "License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl."
#~ "html>\n"
#~ msgstr ""
#~ "Licenza GPLv2+: GNU GPL versione 2 o successive <http://gnu.org/licenses/"
#~ "gpl.html>\n"

#~ msgid ":"
#~ msgstr ":"

#~ msgid "true"
#~ msgstr "vero"

#~ msgid "false"
#~ msgstr "falso"

#~ msgid "times"
#~ msgstr "times"
