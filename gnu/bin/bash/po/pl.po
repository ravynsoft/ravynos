# Polish translation of bash
# Copyright (C) 2007, 2010, 2011, 2013, 2014, 2015, 2016, 2018, 2019, 2020, 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Andrzej M. Krzysztofowicz <ankry@mif.pg.gda.pl> 2006,2007.
# Jakub Bogusz <qboosh@pld-linux.org> 2010-2022.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 5.2-rc1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2022-06-19 22:15+0200\n"
"Last-Translator: Jakub Bogusz <qboosh@pld-linux.org>\n"
"Language-Team: Polish <translation-team-pl@lists.sourceforge.net>\n"
"Language: pl\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "nieprawidłowy indeks tablicy"

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: usuwanie atrybutu nameref"

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: nie można przekształcić tablicy indeksowanej na asocjacyjną"

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: nie można przypisać do nienumerycznego indeksu"

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: przy przypisaniu do tablicy asocjacyjnej należy użyć nawiasów"

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: nie można utworzyć: %s"

# ???
#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: nie można znaleźć mapy klawiszy dla polecenia"

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: pierwszym drukowalnym znakiem nie jest `\"'"

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "brak zamykającego `%c' w %s"

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: brak separującego dwukropka"

#: bashline.c:4733
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "`%s': nie można usunąć dowiązania w mapie poleceń"

#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "rozwijanie nawiasów: nie można przydzielić pamięci dla %s"

#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "rozwijanie nawiasów: nie udało się przydzielić pamięci dla elementów w liczbie %u"

#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "rozwijanie nawiasów: nie udało się przydzielić pamięci dla `%s'"

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "`%s': błędna nazwa aliasu"

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "edycja wiersza nie została włączona"

# ???
#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "`%s': nieprawidłowa nazwa mapy klawiszy"

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: nie można odczytać: %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "`%s': nie znana nazwa funkcji"

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s nie jest przypisany do żadnego klawisza.\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s może być wywołany przez "

# ???
#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "`%s': nie można usunąć dowiązania"

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "licznik pętli"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "ma sens tylko w pętli `for', `while' lub `until'"

#: builtins/caller.def:136
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Zwrócenie kontekstu wywołania bieżącej procedury.\n"
"    \n"
"    Bez WYRAŻENIA zwracane jest \"$linia $plik\". Z WYRAŻENIEM zwracane jest\n"
"    \"$linia $procedura $plik\"; dodatkowe informacje służą do udostępnienia\n"
"    śladu stosu.\n"
"    \n"
"    Wartość WYRAŻENIA określa o ile ramek wywołań względem bieżącej ramki\n"
"    należy się cofnąć; numer najwyższej ramki to 0."

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "Nie ustawiono HOME"

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "za dużo argumentów"

#: builtins/cd.def:342
msgid "null directory"
msgstr "zerowy katalog"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "Nie ustawiono OLDPWD"

#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "linia %d: "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "uwaga: "

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s: składnia: "

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: opcja wymaga argumentu"

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: wymagany argument numeryczny"

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s: nie znaleziono"

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s: nieprawidłowa opcja"

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s: nieprawidłowa nazwa opcji"

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "`%s': nieprawidłowy identyfikator"

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "błędna liczba ósemkowa"

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "błędna liczba szesnastkowa"

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "nieprawidłowa liczba"

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: nieprawidłowo określony sygnał"

#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "`%s': nie jest to nr PID ani prawidłowe określenie zadania"

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s: zmienna tylko do odczytu"

#: builtins/common.c:273
#, c-format
msgid "%s: cannot assign"
msgstr "%s: nie można przypisać"

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s poza zakresem"

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "argument"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s poza zakresem"

#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s: brak takiego zadania"

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s: brak kontroli zadań"

#: builtins/common.c:301
msgid "no job control"
msgstr "brak kontroli zadań"

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s: ograniczony"

#: builtins/common.c:313
msgid "restricted"
msgstr "ograniczony"

#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: nie jest to polecenie powłoki"

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "błąd zapisu: %s"

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "błąd podczas ustawiania atrybutów terminala: %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "błąd podczas pobierania atrybutów terminala: %s"

#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: błąd przy określaniu katalogu bieżącego: %s: %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: niejednoznaczne określenie zadania"

#: builtins/common.c:971
msgid "help not available in this version"
msgstr "pomoc nie jest dostępna w tej wersji"

#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: nie można anulować definicji: %s jest tylko do odczytu"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s: nie można anulować definicji"

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s: nieprawidłowa nazwa akcji"

#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s: brak definicji dla uzupełnienia"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "uwaga: opcja -F może działać inaczej niż oczekiwano"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "uwaga: opcja -C może działać inaczej niż oczekiwano"

#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "aktualnie nie jest wykonywana funkcja dopełniania"

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "można używać tylko w funkcji"

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "nie można używać `-f' do tworzenia funkcji"

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s: funkcja tylko do odczytu"

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: zmienna referencyjna nie może być tablicą"

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: zmienna referencyjna nie może wskazywać na siebie"

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr "%s: cykliczne odwołanie do nazwy"

#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "`%s': błędna nazwa zmiennej przy odwołaniu do nazwy"

#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: nie można w ten sposób unicestwić zmiennej tablicowej"

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: nie można przekształcić tablicy asocjacyjnej na indeksowaną"

#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: przypisanie złożonej tablicy z cytowaniem jest przestarzałe"

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "ładowanie dynamiczne nie jest dostępne"

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "nie można otworzyć obiektu współdzielonego %s: %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "nie można znaleźć %s w obiekcie współdzielonym %s: %s"

#: builtins/enable.def:422
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: dynamiczne polecenie wbudowane już załadowane"

#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "funkcja ładująca dla %s zwraca niepowodzenie (%d): nie załadowano"

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: nie jest ładowany dynamicznie"

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: nie można usunąć: %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s: jest katalogiem"

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s: nie jest zwykłym plikiem"

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s: plik jest za duży"

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: nie można uruchomić pliku binarnego"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: nie można uruchomić: %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "wylogowanie\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "to nie jest powłoka logowania: użyj `exit'"

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Istnieją zatrzymane zadania.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Istnieją działające zadania.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "nie znaleziono polecenia"

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr "specyfikacja historii"

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: nie udało się otworzyć pliku tymczasowego: %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "bieżące"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "zadanie %d uruchomiono bez kontroli zadań"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: niedozwolona opcja -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: opcja wymaga argumentu -- %c\n"

#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "zapamiętywanie ścieżek poleceń w tablicy asocjacyjnej wyłączone"

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: tablica asocjacyjna pusta\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "trafienia\tpolecenie\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Polecenia powłoki pasujące do słowa kluczowego `"
msgstr[1] "Polecenia powłoki pasujące do słów kluczowych `"
msgstr[2] "Polecenia powłoki pasujące do słów kluczowych `"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"żaden temat pomocy nie pasuje do `%s'. Spróbuj `help help', `man -k %s'\n"
"lub `info %s'."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: nie można otworzyć: %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Te polecenia powłoki są poleceniami wewnętrznymi. Napisz `help', aby\n"
"zobaczyć listę.\n"
"Napisz `help nazwa', aby otrzymać więcej informacji o funkcji `nazwa'.\n"
"Użyj `info bash', aby otrzymać więcej informacji ogólnych o powłoce.\n"
"Użyj `man -k' lub `info', aby otrzymać więcej informacji o poleceniach z tej\n"
"listy.\n"
"\n"
"Gwiazdka (*) po nazwie oznacza, że dane polecenie jest wyłączone.\n"
"\n"

#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "nie można używać więcej niż jednego spośród -anrw"

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "pozycja historii"

#: builtins/history.def:338
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: nieprawidłowy znacznik czasu"

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: rozwinięcie wg historii nie powiodło się"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: inlib nie powiodło się"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "nie można używać innych opcji przy `-x'"

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: argumentami muszą być numery procesów lub zadań"

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Nieznany błąd"

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "spodziewano się wyrażenia"

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: nie jest tablicą indeksowaną"

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: nieprawidłowo określony deskryptor pliku"

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: nieprawidłowy deskryptor pliku: %s"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s: błędna liczba linii"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: błędny początek tablicy"

#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: błędna liczba linii między wywołaniami"

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "pusta nazwa zmiennej tablicowej"

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr "wymagana obsługa zmiennych tablicowych"

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "`%s': brak znaku formatującego"

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "`%c': błędne określenie formatu czasu"

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "`%c': nieprawidłowy znak formatujący"

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "uwaga: %s: %s"

#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr "problem z analizą formatu: %s"

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "brak cyfry szesnastkowej dla \\x"

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "brak cyfry unikodowej dla \\%c"

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "brak innego katalogu"

#: builtins/pushd.def:360
#, c-format
msgid "%s: invalid argument"
msgstr "%s: nieprawidłowy argument"

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "<brak katalogu bieżącego>"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "pusty stos katalogów"

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "indeks stosu katalogów"

#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Wypisanie listy aktualnie pamiętanych katalogów. Katalogi umieszczane są\n"
"    na liście za pomocą polecenia `pushd'; można cofać się w obrębie listy\n"
"    za pomocą polecenia `popd'.\n"
"    \n"
"    Opcje:\n"
"      -c\twyczyszczenie stosu katalogów poprzez usunięcie wszystkich elementów\n"
"      -l\tniewypisywanie katalogów względem kat. domowego użytkownika\n"
"    \tw postaci skróconej z tyldą\n"
"      -p\twypisanie stosu katalogów po jednym wpisie w linii\n"
"      -v\twypisanie stosu katalogów po jednym wpisie w linii, poprzedzonych\n"
"    \tpozycją na stosie\n"
"    \n"
"    Argumenty:\n"
"      +N\tWypisanie N-tej pozycji licząc od lewej strony listy wypisywanej\n"
"    \tprzez dirs wywołane bez opcji, począwszy od zera.\n"
"    \n"
"      -N\tWypisanie N-tej pozycji licząc od prawej strony listy wypisywanej\n"
"\tprzez dirs wywołane bez opcji, począwszy od zera."

#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Dodanie katalogu na wierzchołku stosu katalogów lub rotacja stosu czyniąca\n"
"    jego nowym wierzchołkiem bieżący katalog roboczy. Wywołane bez\n"
"    argumentów zamienia na stosie dwa najwyższe katalogi.\n"
"    \n"
"    Opcje:\n"
"      -n\tPominięcie zmiany katalogu podczas umieszczania katalogów na\n"
"    \tstosie tak, że zmieniany jest tylko stos.\n"
"    \n"
"    Argumenty:\n"
"      +N\tRotacja stosu czyniąca jego wierzchołkiem N-ty katalog (licząc\n"
"    \tod lewej strony listy wypisywanej przez `dirs', począwszy od zera).\n"
"    \n"
"      -N\tRotacja stosu czyniąca jego wierzchołkiem N-ty katalog (licząc\n"
"    \tod prawej strony listy wypisywanej przez `dirs', począwszy od zera).\n"
"    \n"
"      katalog\tUmieszczenie KATALOGU na wierzchołku stosu i uczynienie go\n"
"    \tnowym bieżącym katalogiem roboczym.\n"
"    \n"
"    Zawartość stosu katalogów można zobaczyć za pomocą polecenia `dirs'."

#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Usunięcie pozycji ze stosu katalogów. Wywołane bez argumentów usuwa\n"
"    katalog z wierzchołka stosu i zmienia katalog bieżący na katalog\n"
"    będący nowym wierzchołkiem stosu.\n"
"    \n"
"    Opcje:\n"
"      -n\tPominięcie zmiany katalogu podczas usuwania katalogów ze stosu\n"
"    \ttak, że zmieniany jest tylko stos.\n"
"    \n"
"    Argumenty:\n"
"      +N\tUsunięcie ze stosu N-tej pozycji licząc od lewej strony listy\n"
"    \twypisywanej przez `dirs', począwszy od zera. Na przykład: `popd +0'\n"
"    \tusuwa pierwszy katalog, `popd +1' usuwa drugi.\n"
"    \n"
"      -N\tUsunięcie ze stosu N-tej pozycji licząc od prawej strony listy\n"
"    \twypisywanej przez `dirs', począwszy od zera. Na przykład: `popd -0'\n"
"    \tusuwa ostatni katalog, `popd -1' usuwa poprzedni.\n"
"    \n"
"    Zawartość stosu katalogów można zobaczyć za pomocą polecenia `dirs'."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: nieprawidłowo określony limit czasu"

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "błąd odczytu: %d: %s"

#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr "wyjście przez `return' możliwe tylko z funkcji lub skryptu"

#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr "nie można jednocześnie anulować definicji funkcji i zmiennej"

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s: nie jest zmienną tablicową"

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s: nie jest funkcją"

#: builtins/setattr.def:194
#, c-format
msgid "%s: cannot export"
msgstr "%s: nie można wyeksportować"

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "licznik przesunięcia"

#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "nie można opcji powłoki jednocześnie ustawić i unieważnić"

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: nieprawidłowa nazwa opcji powłoki"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "wymagany argument w postaci nazwy pliku"

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s: nie znaleziono pliku"

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "nie można wstrzymać"

#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "nie można wstrzymać powłoki logowania"

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s jest aliasem do %s'\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s jest słowem kluczowym powłoki\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s jest funkcją\n"

#: builtins/type.def:299
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s jest specjalnym wewnętrznym poleceniem powłoki\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s jest wewnętrznym poleceniem powłoki\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "%s jest %s\n"

#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "ścieżka do %s jest zapamiętana (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: nieprawidłowy argument stanowiący ograniczenie"

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "`%c': złe polecenie"

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: nie można odczytać ograniczenia: %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "ograniczenie"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: nie można zmienić ograniczenia: %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "liczba ósemkowa"

#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "`%c': nieprawidłowy operator trybu symbolicznego"

#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "`%c': nieprawidłowy znak trybu symbolicznego"

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " linia "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "ostatnie polecenie: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Przerywanie..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr "INFORM: "

#: error.c:310
#, c-format
msgid "DEBUG warning: "
msgstr "DIAGNOSTYCZNE ostrzeżenie: "

#: error.c:488
msgid "unknown command error"
msgstr "nieznany błąd polecenia"

#: error.c:489
msgid "bad command type"
msgstr "zły rodzaj polecenia"

#: error.c:490
msgid "bad connector"
msgstr "zły łącznik"

#: error.c:491
msgid "bad jump"
msgstr "zły skok"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s: nieustawiona zmienna"

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aprzekroczony czas oczekiwania na dane wejściowe: auto-wylogowanie\n"

#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "nie można przekierować standardowego wejścia z /dev/null: %s"

#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: `%c': nieprawidłowy znak formatujący"

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: koproces [%d:%s] nadal istnieje"

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "błąd potoku"

#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: przekroczono maksymalny poziom zagnieżdżenia polecenia eval (%d)"

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: przekroczono maksymalny poziom zagnieżdżenia polecenia source (%d)"

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: przekroczono maksymalny poziom zagnieżdżenia funkcji (%d)"

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: ograniczony: nie można podawać `/' w nazwach poleceń"

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s: nie znaleziono polecenia"

#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5975
#, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: nie można uruchomić: nie znaleziono wymaganego pliku"

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: zły interpreter"

#: execute_cmd.c:6037
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: nie można uruchomić pliku binarnego: %s"

#: execute_cmd.c:6123
#, c-format
msgid "`%s': is a special builtin"
msgstr "`%s' jest specjalnym poleceniem wewnętrznym"

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "nie można skopiować deskryptora pliku %d do %d"

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "przekroczone ograniczenie poziomu rekursji dla wyrażenia"

#: expr.c:291
msgid "recursion stack underflow"
msgstr "niedomiar stosu rekursji"

#: expr.c:478
msgid "syntax error in expression"
msgstr "błąd składniowy w wyrażeniu"

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "próba przypisania do nie-zmiennej"

#: expr.c:531
msgid "syntax error in variable assignment"
msgstr "błąd składniowy w przypisaniu zmiennej"

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "dzielenie przez 0"

# ???
#: expr.c:593
msgid "bug: bad expassign token"
msgstr "błąd: zły prefiks operatora przypisującego"

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "spodziewano się `:' w wyrażeniu warunkowym"

#: expr.c:973
msgid "exponent less than 0"
msgstr "wykładnik mniejszy niż 0"

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "spodziewany identyfikator po operatorze preinkrementacji lub predekrementacji"

#: expr.c:1057
msgid "missing `)'"
msgstr "brakujący `)'"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "błąd składni: spodziewany argument"

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "błąd składni: nieprawidłowy operator arytmetyczny"

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (błędny znacznik to \"%s\")"

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "nieprawidłowa podstawa arytmetyczna"

#: expr.c:1587
msgid "invalid integer constant"
msgstr "błędna stała całkowita"

#: expr.c:1603
msgid "value too great for base"
msgstr "wartość za duża na podstawę"

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s: błąd w wyrażeniu\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: niemożliwy dostęp do katalogów nadrzędnych"

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "nie można wyłączyć trybu nieblokującego dla deskryptora %d"

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "nie można przydzielić nowego deskryptora pliku dla wejścia basha z %d"

#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: bufor dla nowego deskryptora %d już istnieje"

#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp pipe"

#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: PĘTLA: psi (%d) == storage[psi].bucket_next"

#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: PĘTLA: psi (%d) == storage[psi].bucket_next"

# ???
#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "proces o PID %d występuje w działającym zadaniu %d"

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "usuwanie zatrzymanego zadania %d z grupą procesów %ld"

#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) oznaczony jako nadal żywy"

#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: brak takiego PID-u"

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "Sygnał %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Zakończono"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Zatrzymano"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Zatrzymano(%s)"

#: jobs.c:1881
msgid "Running"
msgstr "Działa"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Zakończono(%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Kod wyjścia %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "Stan nieznany"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(zrzut pamięci) "

#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (katalog: %s)"

#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "setpgid potomka (%ld na %ld)"

#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: PID %ld nie jest potomkiem tej powłoki"

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: Brak rekordu dla procesu %ld"

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: zadanie %d jest zatrzymane"

#: jobs.c:3551
#, c-format
msgid "%s: no current jobs"
msgstr "%s: brak bieżących zadań"

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s: zadanie zostało przerwane"

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: zadanie %d już pracuje w tle"

#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: wyłączanie WNOHANG w celu uniknięcia nieskończonego oczekiwania"

#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s: linia %d: "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr " (zrzut pamięci)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(katalog: %s)\n"

#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp nie powiodło się"

#: jobs.c:4434
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: brak kontroli zadań w tle"

#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: dyscyplina linii"

#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "nie można ustawić grupy procesów terminala (%d)"

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "w tej powłoce nie ma kontroli zadań"

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: założenie, że %s nie jest spełnione\n"

#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: spartaczone założenie\r\n"

#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "nieznany"

# ???
#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "malloc: nieprawidłowy blok na liście wolnych bloków"

#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "free: wywołane dla bloku, który już został zwolniony"

#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "free: wywołane dla bloku, który nie został przydzielony"

#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: wykryto niedomiar; mh_nbytes poza zakresem"

#: lib/malloc/malloc.c:1007
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: wykryto niedomiar; uszkodzenie magic8"

#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "free: rozmiar początkowy i końcowy fragmentu są różne"

#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "realloc: wywołane dla bloku, który nie został przydzielony"

#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: wykryto niedomiar; mh_nbytes poza zakresem"

#: lib/malloc/malloc.c:1197
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: wykryto niedomiar; uszkodzenie magic8"

#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: rozmiar początkowy i końcowy fragmentu są różne"

#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: tablica alokacji jest pełna podczas FIND_ALLOC?\n"

#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p już znajduje się w tablicy jako przydzielony?\n"

#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p już znajduje się w tablicy jako wolny?\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "nieprawidłowa podstawa"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: nieznany host"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: nieznana usługa"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: źle określona ścieżka sieciowa"

#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "operacje sieciowe nie są wspierane"

#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: nie można zmienić lokalizacji (%s)"

#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: nie można zmienić lokalizacji (%s): %s"

#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: nie można zmienić lokalizacji (%s)"

#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: nie można zmienić lokalizacji (%s): %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Masz pocztę w $_"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Masz nową pocztę w $_"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Poczta w %s jest przeczytana\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "błąd składni: oczekiwano wyrażenia arytmetycznego"

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "błąd składni: oczekiwany `;'"

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "błąd składni: `((%s))'"

#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: zły rodzaj instrukcji %d"

#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "dokument miejscowy w linii %d ograniczony końcem pliku (oczekiwano `%s')"

#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: instrukcja przekierowania `%d' poza zakresem"

#: parse.y:2428
#, c-format
msgid "shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"
msgstr "shell_getc: shell_input_line_size (%zu) przekracza SIZE_MAX (%lu): linia skrócona"

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr "przekroczono maksymalną liczbę dokumentów w miejscu"

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "nieoczekiwany EOF podczas poszukiwania pasującego `%c'"

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "nieoczekiwany EOF podczas poszukiwania `]]'"

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "błąd składni w wyrażeniu warunkowym: nieoczekiwany znacznik `%s'"

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "błąd składni w wyrażeniu warunkowym"

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "nieoczekiwany znacznik `%s', oczekiwano `)'"

#: parse.y:4543
msgid "expected `)'"
msgstr "oczekiwano `)'"

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "nieoczekiwany argument `%s' jednoargumentowego operatora warunkowego"

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr "nieoczekiwany argument jednoargumentowego operatora warunkowego"

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "nieoczekiwany argument `%s', oczekiwano dwuarg. operatora warunkowego"

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr "oczekiwano dwuargumentowego operatora warunkowego"

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "nieoczekiwany argument `%s' dwuargumentowego operatora warunkowego"

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr "nieoczekiwany argument dwuargumentowego operatora warunkowego"

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "nieoczekiwany znacznik `%c' w poleceniu warunkowym"

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "nieoczekiwany znacznik `%s' w poleceniu warunkowym"

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "nieoczekiwany znacznik %d w poleceniu warunkowym"

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "błąd składni przy nieoczekiwanym znaczniku `%s'"

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "błąd składni przy `%s'"

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "błąd składni: nieoczekiwany koniec pliku"

#: parse.y:6151
msgid "syntax error"
msgstr "błąd składni"

#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Użyj \"%s\", aby opuścić tę powłokę.\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "nieoczekiwany EOF podczas poszukiwania pasującego `)'"

#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "uzupełnienie: nie znaleziono funkcji `%s'"

#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: możliwe zapętlenie wznowień"

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULL COMPSPEC"

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: zły łącznik `%d'"

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: nieprawidłowy deskryptor pliku"

#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: pusty wskaźnik pliku"

#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != fileno xtrace fp (%d)"

#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: `%c': nieprawidłowy znak formatujący"

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "deskryptor pliku poza zakresem"

#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: niejednoznaczne przekierowanie"

#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: nie można nadpisać istniejącego pliku"

#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: ograniczony: nie można przekierować wyjścia"

#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "nie można utworzyć pliku tymczasowego dla dokumentu miejscowego: %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: nie można przypisać deskryptora pliku do zmiennej"

#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port nie są wspierane bez sieci"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "błąd przekierowania: nie można powielić deskryptora pliku"

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "nie można znaleźć /tmp, proszę o utworzenie!"

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "/tmp musi być prawidłową nazwą katalogu"

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr "tryb ładnego wypisywania jest ignorowany w powłokach interaktywnych"

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: nieprawidłowa opcja"

#: shell.c:1343
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "nie można ustawić uid-a na %d: efektywny uid %d"

#: shell.c:1354
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "nie można ustawić gid-a na %d: efektywny gid %d"

#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr "nie można uruchomić debuggera; tryb diagnostyczny wyłączony"

#: shell.c:1658
#, c-format
msgid "%s: Is a directory"
msgstr "%s: jest katalogiem"

#: shell.c:1907
msgid "I have no name!"
msgstr "Nie mam nazwy!"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, wersja %s-(%s)\n"

#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Użycie:\t%s [długa opcja GNU] [opcja] ...\n"
"\t%s [długa opcja GNU] [opcja] plik-skryptu ...\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "Długie opcje GNU:\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Opcje powłoki:\n"

#: shell.c:2069
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-ilrsD lub -c polecenie lub -O shopt_option\t\t(tylko wywołanie)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s lub -o opcja\n"

#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Aby uzyskać więcej informacji o opcjach powłoki, napisz `%s -c \"help set\"'.\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Aby uzyskać więcej informacji o poleceniach wewnętrznych powłoki,\n"
"napisz `%s -c help'.\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Do zgłaszania błędów należy używać polecenia `bashbug'.\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "strona domowa basha: <http://www.gnu.org/software/bash>\n"

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Ogólna pomoc przy użytkowaniu oprogramowania GNU: <http://www.gnu.org/gethelp/>\n"

#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: nieprawidłowa operacja"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Błędny sygnał"

#: siglist.c:51
msgid "Hangup"
msgstr "Rozłączenie"

#: siglist.c:55
msgid "Interrupt"
msgstr "Przerwanie"

#: siglist.c:59
msgid "Quit"
msgstr "Wyjście"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Niedozwolona instrukcja"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Pułapka debuggera/breakpoint"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Instrukcja ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Pułapka EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Błąd w obliczeniach zmiennoprzecinkowych"

#: siglist.c:87
msgid "Killed"
msgstr "Unicestwiony"

#: siglist.c:91
msgid "Bus error"
msgstr "Błąd szyny"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Naruszenie ochrony pamięci"

#: siglist.c:99
msgid "Bad system call"
msgstr "Błędne wywołanie systemowe"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Przerwany potok"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Budzik"

#: siglist.c:111
msgid "Terminated"
msgstr "Zakończony"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Nagłe żądanie we/wy"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Zatrzymany (sygnał)"

#: siglist.c:127
msgid "Continue"
msgstr "Kontynuacja"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Śmierć lub zatrzymanie potomka"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Zatrzymany (wejście z tty)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Zatrzymany (wyjście na tty)"

#: siglist.c:147
msgid "I/O ready"
msgstr "We/wy gotowe"

#: siglist.c:151
msgid "CPU limit"
msgstr "Przekroczony limit procesora"

#: siglist.c:155
msgid "File limit"
msgstr "Przekroczony limit pliku"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Alarm (wirtualny)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Alarm (profiler)"

#: siglist.c:167
msgid "Window changed"
msgstr "Okno zmienione"

#: siglist.c:171
msgid "Record lock"
msgstr "Zasoby utracone"

#: siglist.c:175
msgid "User signal 1"
msgstr "Sygnał użytkownika 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Sygnał użytkownika 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "Dane wejściowe HFT"

#: siglist.c:187
msgid "power failure imminent"
msgstr "Bliska awaria zasilania"

#: siglist.c:191
msgid "system crash imminent"
msgstr "Bliska awaria systemu"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "Przeniesienie procesu na inny procesor"

#: siglist.c:199
msgid "programming error"
msgstr "Błąd programowania"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "Nadany tryb monitora HFT"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "Wycofany tryb monitora HFT"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "Sekwencja dźwiękowa HFT zakończona"

#: siglist.c:215
msgid "Information request"
msgstr "Żądanie informacji"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Nieznany sygnał #%d"

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "złe podstawienie: brak zamykającego `%s' w %s"

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: nie można przypisać listy do elementu tablicy"

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "nie można utworzyć potoku dla podstawienia procesu"

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "nie można utworzyć procesu potomnego dla podstawienia procesu"

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "nie można otworzyć nazwanego potoku %s do odczytu"

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "nie można otworzyć nazwanego potoku %s do zapisu"

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "nie można powielić nazwanego potoku %s jako deskryptor %d"

#: subst.c:6370
msgid "command substitution: ignored null byte in input"
msgstr "podstawienie polecenia: zignorowano zerowy bajt na wejściu"

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "nie można utworzyć potoku dla podstawienia polecenia"

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "nie można utworzyć procesu potomnego dla podstawienia polecenia"

#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: nie można powielić potoku jako deskryptora 1"

#: subst.c:7082 subst.c:10252
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: nieprawidłowa nazwa zmiennej przy odwołaniu do nazwy"

#: subst.c:7178 subst.c:7196 subst.c:7369
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: błędne rozwinięcie niebezpośrednie"

#: subst.c:7212 subst.c:7377
#, c-format
msgid "%s: invalid variable name"
msgstr "`%s': błędna nazwa zmiennej"

#: subst.c:7478
#, c-format
msgid "%s: parameter not set"
msgstr "%s: parametr nieustawiony"

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parametr pusty lub nieustawiony"

#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: wyrażenie dla podłańcucha < 0"

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s: złe podstawienie"

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: nie można przypisywać w ten sposób"

#: subst.c:10111
msgid "future versions of the shell will force evaluation as an arithmetic substitution"
msgstr "przyszłe wersje powłoki będą wymuszać obliczenie jako podstawienie arytmetyczne"

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "złe podstawienie: brak zamykającego \"`\" w %s"

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "brak pasującego: %s"

#: test.c:147
msgid "argument expected"
msgstr "oczekiwano argumentu"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: oczekiwano wyrażenia całkowitego"

#: test.c:265
msgid "`)' expected"
msgstr "oczekiwano `)'"

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "oczekiwano `)', znaleziono %s"

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: oczekiwano operatora dwuargumentowego"

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: oczekiwano operatora jednoargumentowego"

#: test.c:896
msgid "missing `]'"
msgstr "brakujący `]'"

#: test.c:914
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "błąd składni: oczekiwano `%s'"

#: trap.c:220
msgid "invalid signal number"
msgstr "nieprawidłowy numer sygnału"

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "obsługa pułapki: przekroczono maksymalny poziom obsługi pułapek (%d)"

#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: zła wartość trap_list[%d]: %p"

#: trap.c:416
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: obsługa sygnału jest ustawiona na SIG_DFL, wysyłając %d (%s) do siebie"

#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: zły sygnał %d"

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "błąd importu definicji funkcji dla `%s'"

#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "poziom powłoki (%d) jest za duży, ustawiono na 1"

#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: brak kontekstu funkcji w bieżącym zakresie"

#: variables.c:2661
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: nie można przypisać wartości do zmiennej"

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr "%s: nie można odziedziczyć wartości z niezgodnego typu"

#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: przypisanie wartości całkowitej przy odwołaniu do nazwy"

#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: brak kontekstu funkcji w bieżącym zakresie"

#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "%s ma pusty exportstr"

#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "nieprawidłowy znak %d w exportstr dla %s"

#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "brak `=' w exportstr dla %s"

#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: nagłówek shell_variables poza kontekstem funkcji"

#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: brak kontekstu global_variables"

#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: nagłówek shell_variables poza zakresem tymczasowego środowiska"

#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: nie można otworzyć jako PLIK"

#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: nieprawidłowa wartość dla deskryptora pliku do śledzenia"

#: variables.c:6450
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: wartość zgodności poza zakresem"

#: version.c:46 version2.c:46
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "Copyright (C) 2022 Free Software Foundation, Inc."

#: version.c:47 version2.c:47
msgid "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
msgstr "Licencja GPLv3+: GNU GPL wersja 3 lub późniejsza <http://gnu.org/licenses/gpl.html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, wersja %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr "To oprogramowanie jest wolnodostępne; można je swobodnie zmieniać i rozpowszechniać."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "Nie ma ŻADNEJ GWARANCJI w granicach dopuszczanych przez prawo."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: nie można przydzielić %lu bajtów (przydzielono %lu)"

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: nie można przydzielić %lu bajtów"

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: nie można przydzielić %lu bajtów (przydzielono %lu)"

#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: nie można przydzielić %lu bajtów"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [nazwa[=wartość] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] nazwa [nazwa ...]"

#: builtins.c:53
msgid "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr "bind [-lpvsPVSX] [-m mapa] [-f plik] [-q nazwa] [-u nazwa] [-r sekwencja] [-x sekwencja:polecenie-powłoki] [sekwencja:funkcja-readline lub polecenie-readline]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [polecenie-wbudowane [arg ... ]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [wyrażenie]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [katalog]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] polecenie [arg ...]"

#: builtins.c:78
msgid "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]"
msgstr "declare [-aAfFgiIlnrtux] [nazwa[=wartość] ...] lub declare -p [-aAfFilnrtux] [nazwa ...]"

#: builtins.c:80
msgid "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]"
msgstr "typeset [-aAfFgiIlnrtux] nazwa[=wartość] ... lub typeset -p [-aAfFilnrtux] [nazwa ...]"

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [opcja] nazwa[=wartość] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [arg ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [arg ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f plik] [nazwa ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [arg ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts łańcuch-opcji nazwa [arg ...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a nazwa] [polecenie [argument ...]] [przekierowanie ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e nazwa-ed] [-lnr] [pierwszy] [ostatni] lub fc -s [wz=zam] [polecenie]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [zadanie]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [zadanie ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p ścieżka] [-dt] [nazwa ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [wzorzec ...]"

#: builtins.c:123
msgid "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"
msgstr "history [-c] [-d offset] [n] lub history -anrw [plik] lub history -ps arg [arg ...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [zadanie ...] lub jobs -x polecenie [argumenty]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [zadanie ... | pid ...]"

#: builtins.c:134
msgid "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"
msgstr "kill [-s sygnał | -n numer-sygnału | -sygnał] pid | zadanie ... lub kill -l [sygnał]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let arg [arg ...]"

#: builtins.c:138
msgid "read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
msgstr "read [-ers] [-a tablica] [-d separator] [-i tekst] [-n liczba] [-N liczba] [-p zachęta] [-t czas] [-u fd] [nazwa ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCEHPT] [-o nazwa-opcji] [--] [-] [arg ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [nazwa ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [nazwa[=wartość] ...] lub export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [aAf] [nazwa[=wartość] ...] lub readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source plik [argumenty]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". plik [argumenty]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [wyrażenie]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ arg... ]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[arg] sygnał ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] nazwa [nazwa ...]"

#: builtins.c:171
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPRT] [ograniczenie]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [uprawnienia]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p zmienna] [id ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [pid ...]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NAZWA [in SŁOWA ... ] ; do POLECENIA; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( wyr1; wyr2; wyr3 )); do POLECENIA; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NAZWA [in SŁOWA ... ;] do POLECENIA; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] potok"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case SŁOWO in [WZORZEC [| WZORZEC]...) POLECENIA ;;]... esac"

#: builtins.c:194
msgid "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"
msgstr "if POLECENIA; then POLECENIA; [ elif POLECENIA; then POLECENIA; ]... [ else POLECENIA; ] fi"

#: builtins.c:196
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while POLECENIA; do POLECENIA-2; done"

#: builtins.c:198
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until POLECENIA; do POLECENIA-2; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NAZWA] polecenie [przekierowania]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function nazwa { POLECENIA ; } lub nazwa () { POLECENIA ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ POLECENIA ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "zadanie [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( wyrażenie ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ wyrażenie ]]"

#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr "zmienne - nazwy i znaczenie niektórych zmiennych powłoki"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | katalog]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [nazwa-opcji ...]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] format [argumenty]"

#: builtins.c:231
msgid "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"
msgstr "complete [-abcdefgjksuv] [-pr] [-DEI] [-o opcja] [-A akcja] [-G wzorzec-glob] [-W lista-słów] [-F funkcja] [-C polecenie] [-X wzorzec-filtra] [-P przedrostek] [-S przyrostek] [nazwa ...]"

#: builtins.c:235
msgid "compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr "compgen [-abcdefgjksuv] [-o opcja] [-A akcja] [-G wzorzec-glob] [-W lista-słów] [-F funkcja] [-C polecenie] [-X wzorzec-filtra] [-P przedrostek ] [-S przyrostek] [słowo]"

#: builtins.c:239
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o opcja] [-DEI] [nazwa ...]"

#: builtins.c:242
msgid "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "mapfile [-d separator] [-n liczba] [-O początek] [-s liczba] [-t] [-u fd] [-C wywołanie] [-c co-ile] [tablica]"

#: builtins.c:244
msgid "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "readarray [-d ogranicznik] [-n liczba] [-O początek] [-s liczba] [-t] [-u fd] [-C wywołanie] [-c krok] [tablica]"

#: builtins.c:256
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"Definiowanie i wyświetlanie aliasów.\n"
"    \n"
"    Bez argumentów `alias' wypisuje na standardowym wyjściu listę aliasów\n"
"    w postaci alias NAZWA=WARTOŚĆ.\n"
"    \n"
"    W przeciwnym przypadku definiowany jest alias dla każdej NAZWY, dla której\n"
"    podano WARTOŚĆ. Spacja na końcu WARTOŚCI powoduje, że podczas rozwijania\n"
"    tego aliasu podstawienie aliasów będzie przeprowadzone także dla\n"
"    następnego słowa.\n"
"    \n"
"    Opcje:\n"
"      -p\twypisanie wszystkich zdefiniowanych aliasów w formacie do\n"
"    \tponownego użycia\n"
"    \n"
"    Stan wyjściowy:\n"
"    Polecenie alias zwraca prawdę, chyba że poda się NAZWĘ, dla której nie\n"
"    zdefiniowano aliasu."

#: builtins.c:278
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Usuwa wszystkich NAZW z listy zdefiniowanych aliasów.\n"
"    \n"
"    Opcje:\n"
"      -a\tusunięcie wszystkich definicji aliasów\n"
"    \n"
"    Zwracana jest prawda, chyba że NAZWA nie jest istniejącym aliasem."

#: builtins.c:291
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Ustawianie przypisań klawiszy i zmiennych Readline.\n"
"    \n"
"    Przypisanie sekwencji klawiszy do funkcji Readline lub makra albo\n"
"    ustawienie zmiennej Readline. Składnia pozbawiona opcji jest równoważna\n"
"    stosowanej w ~/.inputrc, ale musi być przekazana jako jeden argument, np.:\n"
"    bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Opcje:\n"
"      -m  MAPA           Użycie MAPY jako mapy klawiatury na czas tego\n"
"                         polecenia. Dozwolone nazwy map klawiatury to emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command i vi-insert.\n"
"      -l                 Wypisanie nazw funkcji.\n"
"      -P                 Wypisanie nazw funkcji i dowiązań.\n"
"      -p                 Wypisanie funkcji i dowiązań w postaci nadającej się\n"
"                         do użycia jako dane wejściowe.\n"
"      -S                 Wypisanie sekwencji klawiszy wywołujących makra oraz\n"
"                         ich wartości.\n"
"      -s                 Wypisanie sekwencji klawiszy wywołujących makra oraz\n"
"                         ich wartości w postaci nadającej się do użycia jako\n"
"                         dane wejściowe.\n"
"      -V                 Wypisanie nazw zmiennych i ich wartości.\n"
"      -v                 Wypisanie nazw zmiennych i ich wartości w postaci\n"
"                         nadającej się do użycia jako dane wejściowe.\n"
"      -q  nazwa-funkcji  Określenie, które klawisze wywołują zadaną funkcję.\n"
"      -u  nazwa-funkcji  Anulowanie wszystkich dowiązań dla klawiszy\n"
"                         przypisanych do funkcji o podanej nazwie.\n"
"      -r  sekwencja      Usunięcie dowiązania dla SEKWENCJI klawiszy.\n"
"      -f  plik           Odczyt dowiązań dla klawiszy z podanego PLIKU.\n"
"      -x  sekwencja:polecenie-powłoki\tPowoduje uruchomienie POLECENIA-POWŁOKI\n"
"    \t\t\t\tgdy wprowadzona zostanie podana SEKWENCJA klawiszy.\n"
"      -X                 Lista sekwencji klawiszy przypisanych przez -x oraz\n"
"                         powiązane polecenia w postaci nadającej się do użycia\n"
"                         jako dane wejściowe.\n"
"    \n"
"    Stan wyjściowy:\n"
"    bind zwraca 0, chyba że podano nieznaną opcję lub wystąpi błąd."

#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Wyjście z pętli for, while lub until.\n"
"    \n"
"    Wyjście z pętli FOR, WHILE lub UNTIL. Jeśli podano N, sterowanie wychodzi\n"
"    za N-tą zagnieżdżoną pętlę.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Instrukcja zwraca prawdę, chyba że N jest mniejsze niż 1."

#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Wznowienie pętli for, while lub until.\n"
"    \n"
"    Wznowienie następnej iteracji otaczającej pętli FOR, WHILE lub UNTIL.\n"
"    Jeśli podano N, to wznawiana jest N-ta otaczająca pętla.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Instrukcja zwraca 0, chyba że N jest mniejsze niż 1."

#: builtins.c:354
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Wywołanie polecenia wbudowanego powłoki.\n"
"    \n"
"    Wywołanie POLECENIA-WBUDOWANEGO z argumentami ARG bez wykonywania\n"
"    wyszukiwania polecenia. Jest to przydatne w przypadku ponownego\n"
"    implementowania polecenia wbudowanego jako funkcji powłoki i wywoływania\n"
"    polecenia wbudowanego z wewnątrz tej funkcji.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Instrukcja zwraca stan wyjściowy POLECENIA-WBUDOWANEGO lub fałsz, jeśli\n"
"    POLECENIE-WBUDOWANE nie jest poleceniem wbudowanym powłoki."

#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Zwrócenie kontekstu wywołania bieżącej procedury.\n"
"    \n"
"    Bez WYRAŻENIA zwracane jest \"$linia $plik\". Z WYRAŻENIEM zwracane jest\n"
"    \"$linia $procedura $plik\"; dodatkowe informacje służą do udostępnienia\n"
"    śladu stosu.\n"
"    \n"
"    Wartość WYRAŻENIA określa o ile ramek wywołań względem bieżącej ramki\n"
"    należy się cofnąć; numer najwyższej ramki to 0.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Polecenie zwraca 0, chyba że powłoka nie wykonuje funkcji lub WYRAŻENIE\n"
"    jest nieprawidłowe."

#: builtins.c:387
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
"    A null directory name is the same as the current directory.  If DIR begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is set,\n"
"    the word is assumed to be  a variable name.  If that variable has a value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Zmiana bieżącego katalogu powłoki.\n"
"    \n"
"    Zmiana bieżącego katalogu na KATALOG. Domyślnym KATALOGIEM jest wartość\n"
"    zmiennej powłoki HOME.\n"
"    \n"
"    Zmienna CDPATH określa ścieżkę przeszukiwania w poszukiwaniu katalogu\n"
"    zawierającego KATALOG. Alternatywne nazwy katalogów są w CDPATH rozdzielone\n"
"    dwukropkami (:). Pusta nazwa katalogu oznacza to samo, co katalog\n"
"    bieżący. Jeśli KATALOG zaczyna się od ukośnika (/), to CDPATH nie\n"
"    nie jest używane.\n"
"    \n"
"    Gdy katalog nie zostanie znaleziony, a ustawiona jest zmienna powłoki\n"
"    `cdable_vars', to następuje próba użycia podanej nazwy jako nazwy zmiennej.\n"
"    Jeśli zmienna ta ma wartość, to jako KATALOG jest używana jej wartość.\n"
"    \n"
"    Opcje:\n"
"        -L\twymuszenie śledzenia dowiązań symbolicznych: rozwiązanie\n"
"    \t\tdowiązań w KATALOGU po przetworzeniu wszystkich `..'\n"
"        -P\tkorzystanie z fizycznej struktury katalogów zamiast śledzenia\n"
"    \t\tdowiązań symbolicznych: rozwiązanie dowiązań w KATALOGU przed\n"
"    \t\tprzetworzeniem wszystkich `..'\n"
"        -e\tjeśli podano opcję -P, a nie można określić bieżącego katalogu,\n"
"    \t\tpolecenie kończy się stanem niezerowym\n"
"        -@  na systemach obsługujących je, zaprezentowanie pliku mającego\n"
"    \t\trozszerzone atrybuty jako katalogu zawierającego atrybuty pliku\n"
"    \n"
"    Domyślne jest śledzenie dowiązań symbolicznych, jak z opcją `-L'.\n"
"    `..' jest przetwarzane przez usunięcie bezpośredniego poprzedniego\n"
"    elementu ścieżki przed ukośnikiem lub początkiem KATALOGU.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Polecenie zwraca 0 jeśli katalog został zmieniony oraz $PWD zostało\n"
"    zmienione pomyślnie w przypadku użycia -P; w przeciwnym razie zwraca\n"
"    wartość niezerową."

#: builtins.c:425
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Wypisanie nazwy bieżącego katalogu roboczego.\n"
"    \n"
"    Opcje:\n"
"      -L\twypisanie wartości $PWD jeśli określa bieżący katalog roboczy\n"
"      -P\twypisanie katalogu fizycznego, bez dowiązań symbolicznych\n"
"    \n"
"    Domyślnie `pwd' zachowuje się tak, jak z opcją `-L'.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Polecenie zwraca 0, chyba że podano nieprawidłową opcję lub katalog\n"
"    bieżący nie może być odczytany."

#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Polecenie puste.\n"
"    \n"
"    Żadnego efektu; polecenie nic nie robi.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zawsze zwracana jest prawda."

#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Zwrócenie wyniku pozytywnego.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zawsze zwracana jest prawda."

#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Zwrócenie wyniku negatywnego.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zawsze zwracany jest fałsz."

#: builtins.c:471
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Wywołanie prostego polecenia lub wyświetlenie informacji o poleceniach.\n"
"    \n"
"    Uruchomienie POLECENIA z ARGUMENTAMI z pominięciem wyszukiwania funkcji\n"
"    powłoki lub wyświetlenie informacji o podanych POLECENIACH. Może być użyte\n"
"    do wywołania poleceń z dysku jeśli już istnieje funkcja o danej nazwie.\n"
"    \n"
"    Opcje:\n"
"      -p\tużycie domyślnej wartości PATH, pod którą powinny być wszystkie\n"
"    \t\tstandardowe narzędzia\n"
"      -v\twypisanie opisu POLECENIA w sposób podobny do polecenia `type'\n"
"      -V\twypisanie szczegółowego opisu każdego POLECENIA\n"
"    \n"
"    Stan wyjściowy:\n"
"    Polecenie zwraca stan POLECENIA lub fałsz, jeśli POLECENIE nie zostało\n"
"    znalezione."

#: builtins.c:490
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Ustawienie wartości i atrybutów zmiennej.\n"
"    \n"
"    Deklaracja zmiennych i nadanie im wartości. Jeśli nie podano NAZW,\n"
"    wyświetlane są atrybuty i wartości wszystkich zmiennych.\n"
"    \n"
"    Opcje:\n"
"      -f\tograniczenie akcji lub wyświetlania do nazw i definicji funkcji\n"
"      -F\tograniczenie wyświetlania tylko do nazw funkcji (oraz numeru\n"
"    \t\tlinii i pliku źródłowego w przypadku diagnostyki)\n"
"      -g\ttworzenie zmiennych globalnych w przypadku użycia w funkcji\n"
"    \t\tpowłoki; w przeciwnym wypadku ignorowane\n"
"      -I\tprzy tworzeniu zmiennej lokalnej, dziedziczy ona atrybuty oraz\n"
"    \t\twartość zmiennej o tej samej nazwie z poprzedniego zakresu\n"
"      -p\twyświetlenie atrybutów i wartości dla każdej NAZWY\n"
"    \n"
"    Opcje ustawiające atrybuty:\n"
"      -a\tczyni NAZWĘ tablicą indeksowaną (jeśli są one obsługiwane)\n"
"      -A\tczyni NAZWĘ tablicą asocjacyjną (jeśli są one obsługiwane)\n"
"      -i\tnadaje NAZWIE atrybut `integer' (zmiennej całkowitej)\n"
"      -l\tprzekształca wartość każdej NAZWY na małe litery przy przypisaniu\n"
"      -n\tczyni NAZWĘ odwołaniem do zmiennej o nazwie wskazanej przez wartość\n"
"      -r\tczyni NAZWĘ tylko do odczytu\n"
"      -t\tnadaje NAZWIE atrybut `trace'\n"
"      -u\tprzekształca wartość każdej NAZWY na wielkie litery przy przypisaniu\n"
"      -x\teksportuje NAZWĘ\n"
"    \n"
"    Użycie `+' zamiast `-' wyłącza podany atrybut.\n"
"    \n"
"    Zmienne z atrybutem `integer' mają obliczaną wartość arytmetyczną\n"
"    (jak w poleceniu `let') podczas przypisywania wartości.\n"
"    \n"
"    W przypadku użycia w funkcji `declare' czyni NAZWĘ lokalną, podobnie\n"
"    jak polecenie `local'. Opcja `-g' zmienia to zachowanie.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Polecenie zwraca prawdę, chyba że podano błędną opcję lub wystąpi błąd."

#: builtins.c:532
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Ustawienie wartości i atrybutów zmiennej.\n"
"    \n"
"    Synonim `declare' - p. `help declare'."

#: builtins.c:540
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Definiowanie zmiennych lokalnych.\n"
"    \n"
"    Utworzenie zmiennej lokalnej o podanej NAZWIE i nadanie jej WARTOŚCI.\n"
"    OPCJA może być dowolną opcją przyjmowaną przez `declare'.\n"
"    \n"
"    Zmienne lokalne mogą być używane tylko w funkcji; są widoczne wyłącznie\n"
"    w funkcji, w której zostały zdefiniowanej, oraz jej potomkach.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję, wystąpi błąd przy\n"
"    przypisaniu zmiennej lub powłoka nie wykonuje żadnej funkcji."

#: builtins.c:557
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Wypisanie argumentów na standardowym wyjściu.\n"
"    \n"
"    Wypisanie na standardowym wyjściu argumentów ARG oddzielonych pojedynczymi\n"
"    spacjami oraz znaku końca linii.\n"
"    \n"
"    Opcje:\n"
"      -n\tniedołączanie znaku końca linii\n"
"      -e\twłączenie interpretowania poniższych znaków poprzedzonych\n"
"    \todwrotnym ukośnikiem\n"
"      -E\twyłączenie interpretowania poniższych znaków poprzedzonych\n"
"    \todwrotnym ukośnikiem\n"
"    \n"
"    `echo' interpretuje następujące znaki poprzedzone odwrotnym ukośnikiem:\n"
"      \\a\talarm (dzwonek)\n"
"      \\b\tcofnięcie\n"
"      \\c\tpominięcie dalszego wyjścia (w tym znaku nowego wiersza)\n"
"      \\e\tznak ESCAPE\n"
"      \\E\tznak ESCAPE\n"
"      \\f\twysuw strony\n"
"      \\n\tnowy wiersz\n"
"      \\r\tpowrót karetki\n"
"      \\t\ttabulacja pozioma\n"
"      \\v\ttabulacja pionowa\n"
"      \\\\\todwrotny ukośnik\n"
"      \\0nnn\tznak o kodzie ASCII NNN (ósemkowo). NNN może stanowić od\n"
"    \t\t0 do 3 cyfr ósemkowych\n"
"      \\xHH\tznak ośmiobitowy o wartości HH (szesnastkowo). HH może być\n"
"    \t\tjedną lub dwiema cyframi szesnastkowymi\n"
"      \\uHHHH\tznak Unicode o wartości HHHH (szesnastkowo). HHHH może mieć\n"
"    \t\tod jednej do czterech cyfr szesnastkowych.\n"
"      \\UHHHHHHHH znak Unicode o wartości HHHHHHHH (szesnastkowo). HHHHHHHH\n"
"    \t\tmoże mieć od jednej do ośmiu cyfr szesnastkowych.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że wystąpi błąd zapisu."

#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Wypisanie argumentów na standardowym wyjściu.\n"
"    \n"
"    Wypisanie na standardowym wyjściu argumentów ARG i znaku końca linii.\n"
"    \n"
"    Opcje:\n"
"      -n\tniedołączanie znaku końca linii\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że wystąpi błąd zapisu."

#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Włączanie i wyłączanie poleceń wbudowanych powłoki.\n"
"    \n"
"    Włączanie i wyłączanie poleceń wbudowanych powłoki. Wyłączenie pozwala\n"
"    na wykonanie polecenia z dysku, mającego tę samą nazwę, co polecenie\n"
"    wbudowane bez używania pełnej ścieżki.\n"
"    \n"
"    Opcje:\n"
"      -a\twypisanie listy poleceń wbudowanych z informacją, które są włączone\n"
"      -n\twyłączenie każdej NAZWY lub wypisanie listy wyłączonych poleceń\n"
"      -p\twypisanie listy poleceń w formacie do ponownego użycia\n"
"      -s\twypisanie tylko nazw posiksowych \"specjalnych\" poleceń wbudowanych\n"
"    \n"
"    Opcje sterujące dynamicznym ładowaniem:\n"
"      -f\tWczytanie polecenia wbudowanego NAZWA z obiektu współdzielonego PLIK\n"
"      -d\tUsunięcie polecenia wczytanego przez -f\n"
"    \n"
"    Bez opcji włączana jest każda NAZWA.\n"
"    \n"
"    Aby użyć polecenia `test' z $PATH zamiast wersji wbudowanej, należy\n"
"    wykonać `enable -n test'.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że NAZWA nie jest poleceniem wbudowanym lub\n"
"    wystąpi błąd."

#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Wykonanie argumentów jako polecenia powłoki.\n"
"    \n"
"    Połączenie argumentów ARG w pojedynczy łańcuch, użycie rezultatu jako\n"
"    wejścia dla powłoki i wykonanie wynikowych poleceń.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest stan wyjściowy polecenia lub prawdę, jeśli polecenie jest\n"
"    puste."

#: builtins.c:652
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Analiza opcji z argumentów.\n"
"    \n"
"    Polecenie getopts jest używane przez procedury powłoki przy analizowaniu\n"
"    parametrów pozycyjnych jako opcji.\n"
"    \n"
"    ŁAŃCUCH-OPCJI zawiera litery opcji, które mają być rozpoznane; jeśli po\n"
"    literze następuje dwukropek, opcja wymaga argumentu, który powinien być\n"
"    oddzielony od opcji spacją.\n"
"    \n"
"    Przy każdym wywołaniu getopts umieszcza następną opcję w zmiennej powłoki\n"
"    $nazwa, inicjując ją, jeśli nie istnieje; natomiast indeks następnego\n"
"    argumentu do przetworzenia jest umieszczany w zmiennej powłoki OPTIND\n"
"    OPTIND jest inicjowany wartością 1 przy każdym wywołaniu powłoki lub\n"
"    skryptu powłoki. Jeśli opcja wymaga argumentu, getopts umieszcza ten\n"
"    argument w zmiennej powłoki OPTARG.\n"
"    \n"
"    getopts zgłasza błędy na jeden z dwóch sposobów. Jeśli pierwszy znak\n"
"    ŁAŃCUCHA-OPCJI jest dwukropkiem, getopts wykorzystuje ciche zgłaszanie\n"
"    błędów. W tym trybie komunikaty błędów nie są wypisywane. Jeśli napotkana\n"
"    zostanie błędna opcja, getopts umieszcza znak opcji w OPTARG. Jeśli\n"
"    nie znaleziono wymaganego argumentu, getopts umieszcza znak ':' w NAZWIE\n"
"    i ustawia OPTARG na napotkany znak opcji. Jeśli getopts nie jest w trybie\n"
"    cichym i napotkana zostanie błędna opcja, getopts umieszcza znak '?'\n"
"    w NAZWIE i anuluje OPTARG. Jeśli nie znaleziono wymaganego argumentu,\n"
"    w NAZWIE umieszczany jest znak '?', OPTARG jest anulowany i wypisywany\n"
"    jest komunikat diagnostyczny.\n"
"    \n"
"    Jeśli zmienna powłoki OPTERR ma wartość 0, getopts wyłącza wypisywanie\n"
"    komunikatów błędów, nawet jeśli pierwszym znakiem ŁAŃCUCHA-OPCJI nie jest\n"
"    dwukropek. OPTERR domyślnie ma wartość 1.\n"
"    \n"
"    Polecenie getopts normalnie przetwarza parametry pozycyjne, ale jeśli\n"
"    podano argumenty jako wartości ARG, są one przetwarzane zamiast nich.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, jeśli napotkano opcję; fałsz, jeśli wystąpi koniec\n"
"    opcji lub błąd."

#: builtins.c:694
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"Zastąpienie powłoki podanym poleceniem.\n"
"    \n"
"    Wywoływane jest POLECENIE, zastępując tę powłokę podanym programem.\n"
"    ARGUMENTY stają się argumentami POLECENIA. Jeśli nie podano POLECENIA,\n"
"    wszystkie podane przekierowania odnoszą skutek dla bieżącej powłoki.\n"
"    \n"
"    Opcje:\n"
"      -a nazwa\tprzekazanie NAZWY jako zerowego argumentu POLECENIA\n"
"      -c\twywołanie POLECENIA z pustym środowiskiem\n"
"      -l\tumieszczenie kreski w zerowym argumencie POLECENIA\n"
"    \n"
"    Jeśli polecenia nie można wywołać, powłoka nieinteraktywna kończy się,\n"
"    chyba że ustawiona jest opcja powłoki `execfail'.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że nie uda się znaleźć POLECENIA lub wystąpi\n"
"    błąd przekierowania."

#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Opuszczenie powłoki.\n"
"    \n"
"    Opuszczenie powłoki z kodem zakończenia N. Jeśli N pominięto, kodem\n"
"    zakończenia będzie kod zakończenia ostatniego wykonanego polecenia."

#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"Opuszczenie powłoki logowania.\n"
"    \n"
"    Opuszczenie powłoki logowania z kodem zakończenia N. Zwraca błąd, jeśli\n"
"    powłoka nie jest powłoką logowania."

#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"Wyświetlanie lub wykonywanie poleceń z listy historii.\n"
"    \n"
"    fc służy do wypisywania, edycji i ponownego uruchamiania poleceń z listy\n"
"    historii. PIERWSZY i OSTATNI jako liczby określają zakres lub PIERWSZY\n"
"    jako napis oznacza najpóźniej wykonywane polecenie zaczynające się od tego\n"
"    napisu.\n"
"    \n"
"    Opcje:\n"
"       -e NAZWA-ED\tokreśla edytor, który ma być używany. Domyślnymi\n"
"    \twartościami są: najpierw FCEDIT, potem EDITOR, a na końcu vi\n"
"       -l\twypisywanie wierszy zamiast ich edycji\n"
"       -n\tniewypisywanie numerów wierszy\n"
"       -r\todwrócenie kolejności wierszy (czyniąc najnowsze wypisane\n"
"    \tpolecenie pierwszym)\n"
"    \n"
"    Przy wywołaniu polecenia w postaci `fc -s [wz=zam ...] [polecenie]',\n"
"    jest ono wywoływane ponownie po wykonaniu podstawienia WZ=ZAM.\n"
"    \n"
"    Przydatnym aliasem korzystającym z tego jest r='fc -s' tak, że napisanie\n"
"    `r cc' uruchamia ostatnie polecenie zaczynające się od `cc', a napisanie\n"
"    `r' uruchamia ponownie ostatnie polecenie.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda lub stan wykonanego polecenia; wartość niezerowa\n"
"    w przypadku błędu."

#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Przeniesienie zadania na pierwszy plan.\n"
"    \n"
"    Umieszczenie ZADANIA na pierwszym planie oraz uczynienie go bieżącym\n"
"    zadaniem. Jeśli nie określono ZADANIA, użyte zostanie zadanie bieżące\n"
"    w rozumieniu powłoki.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Stan zadania umieszczonego na pierwszym planie lub fałsz, jeśli wystąpi\n"
"    błąd."

#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Przeniesienie zadań w tło.\n"
"    \n"
"    Umieszczenie wszystkich ZADAŃ w tle tak, jakby zostały uruchomione\n"
"    z `&'. Jeśli nie określono ZADAŃ, użyte zostanie zadanie bieżące\n"
"    w rozumieniu powłoki.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że sterowanie zadaniami nie jest włączone\n"
"    lub wystąpi błąd."

#: builtins.c:793
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Zapamiętanie lub wypisanie położenia programów.\n"
"    \n"
"    Określenie i zapamiętanie pełnej ścieżki każdego polecenia NAZWA. Jeśli\n"
"    nie podano argumentów, wyświetlane są informacje o zapamiętanych\n"
"    poleceniach.\n"
"    \n"
"    Opcje:\n"
"      -d\tzapomnienie położenia każdej NAZWY\n"
"      -l\twypisanie w formacie do wykorzystania jako wejście\n"
"      -p ścieżka\tużycie ŚCIEŻKI jako pełnej ścieżki NAZWY\n"
"      -r\tzapomnienie wszystkich pamiętanych położeń\n"
"      -t\twypisanie pamiętanych położeń każdej NAZWY poprzedzając\n"
"    \t\tkażde położenie odpowiednią NAZWĄ, jeśli podano wiele NAZW\n"
"    Argumenty:\n"
"      NAZWA\tKażda nazwa jest wyszukiwana w $PATH i dodawana do listy\n"
"    \t\tpamiętanych poleceń.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że nie znaleziono NAZWY lub podano błędną\n"
"    opcję."

#: builtins.c:818
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"Wyświetlenie informacji o poleceniach wbudowanych.\n"
"    \n"
"    Wyświetlenie krótkiego przeglądu poleceń wbudowanych. Jeśli podano\n"
"    WZORZEC, wypisywany jest szczegółowy opis wszystkich poleceń pasujących do\n"
"    WZORCA, w przeciwnym wypadku - lista tematów.\n"
"    \n"
"    Opcje:\n"
"      -d\twypisanie krótkiego opisu każdego tematu\n"
"      -m\twyświetlenie sposobu użycia w formacie zbliżonym do stron man\n"
"      -s\twypisanie tylko krótkiej informacji o składni dla każdego\n"
"    \t\ttematu pasującego do WZORCA\n"
"    \n"
"    Argumenty:\n"
"      WZORZEC\tWzorzec określający temat pomocy\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że WZORCA nie znaleziono lub podano błędną\n"
"    opcję."

#: builtins.c:842
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Wyświetlanie i modyfikowanie listy historii.\n"
"    \n"
"    Wyświetlanie listy historii z numerami linii z oznaczeniem każdej\n"
"    zmodyfikowanej linii przedrostkiem `*'. Podanie argumentu N wypisuje\n"
"    tylko ostatnich N wpisów.\n"
"    \n"
"    Opcje:\n"
"      -c\twyczyszczenie listy historii poprzez usunięcie wszystkich wpisów\n"
"      -d offset\tusunięcie wpisu historii o podanym OFFSECIE. Ujemne offsety\n"
"    \t\tliczą się wstecz od końca listy historii\n"
"    \n"
"      -a\tdołączenie linii historii z tej sesji do pliku historii\n"
"      -n\todczyt wszystkich jeszcze nie przeczytanych linii z pliku\n"
"    \t\thistorii i dołączenie ich do listy historii\n"
"      -r\todczyt pliku historii i dołączenie zawartości do listy historii\n"
"      -w\tzapis bieżącej historii do pliku historii\n"
"    \n"
"      -p\trozwinięcie wg historii każdego ARG i wypisanie wyniku bez\n"
"    \t\tzapisywania go na liście historii\n"
"      -s\tdołączenie wszystkich ARG do listy historii jako pojedynczych\n"
"    \t\twpisów\n"
"    \n"
"    Jeśli podano PLIK, jest używany jako plik historii. W przeciwnym wypadku\n"
"    używany jest $HISTFILE, a jeśli ta zmienna nie jest ustawiona -\n"
"    ~/.bash_history.\n"
"    \n"
"    Jeśli zmienna $HISTTIMEFORMAT jest ustawiona i niepusta, jej wartość jest\n"
"    używana jako łańcuch formatujący dla strftime(3) do wypisywania momentu\n"
"    czasu powiązanego z każdym wypisywanym wpisem. W przeciwnym wypadku czas\n"
"    nie jest wypisywany.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję lub wystąpi błąd."

#: builtins.c:879
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Wyświetlenie stanu zadań.\n"
"    \n"
"    Wypisanie aktywnych zadań. ZADANIE ogranicza wyjście tylko do tego zadania.\n"
"    Bez opcji wypisywany jest stan wszystkich aktywnych zadań.\n"
"    \n"
"    Opcje:\n"
"      -l\twypisanie dodatkowo numerów PID procesów\n"
"      -n\twypisanie tylko procesów, które zmieniły stan od ostatniego\n"
"    \t\tpowiadomienia\n"
"      -p\twypisanie tylko numerów PID procesów\n"
"      -r\tograniczenie wyjścia do zadań działających\n"
"      -s\tograniczenie wyjścia do zadań zatrzymanych\n"
"    \n"
"    Przy podaniu -x, uruchamiane jest podane POLECENIE po zastąpieniu\n"
"    każdej z występujących w argumentach ARG specyfikacji zadań numerem PID\n"
"    procesu wiodącego danego zadania.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję lub wystąpi błąd.\n"
"    Jeśli użyto -x, zwracany jest stan wyjściowy POLECENIA."

#: builtins.c:906
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Usunięcie poleceń z bieżącej powłoki.\n"
"    \n"
"    Usunięcie każdego podanego ZADANIA z tablicy aktywnych zadań. Bez\n"
"    podania ZADANIA powłoka używa pojęcia bieżącego zadania.\n"
"    \n"
"    Opcje:\n"
"      -a\tusunięcie wszystkich zadań, jeśli nie podano ZADANIA\n"
"      -h\toznaczenie każdego zadania tak, że SIGHUP nie jest wysyłany do\n"
"    \t\tzadania, jeśli powłoka otrzyma SIGHUP\n"
"      -r\tusunięcie tylko działających zadań\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję lub ZADANIE."

#: builtins.c:925
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Wysłanie sygnału do zadania.\n"
"    \n"
"    Wysłanie do procesów określonych przez PID lub ZADANIE sygnału o nazwie\n"
"    SYGNAŁ lub NUMERZE-SYGNAŁU. Jeśli nie podano SYGNAŁU ani NUMERU-SYGNAŁU,\n"
"    przyjmowany jest SIGTERM.\n"
"    \n"
"    Opcje:\n"
"      -s SYG\tSYG jest nazwą sygnału\n"
"      -n SYG\tSYG jest numerem sygnału\n"
"      -l\tlista nazw sygnałów; jeśli `-l' występuje z argumentami, są one\n"
"    \t\ttraktowane jako numery sygnałów, dla których mają być wypisane nazwy\n"
"      -L\tsynonim -l\n"
"    \n"
"    Kill jest poleceniem wewnętrznym z dwóch powodów: umożliwia korzystanie\n"
"    z identyfikatorów zadań zamiast numerów PID oraz, w przypadku osiągnięcia\n"
"    ograniczenia na liczbę procesów, nie powoduje potrzeby uruchamiania\n"
"    dodatkowego procesu, aby jakiś zabić.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest sukces, chyba że podano błędną opcję lub wystąpi błąd."

#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Obliczanie wyrażeń arytmetycznych.\n"
"    \n"
"    Obliczenie każdego argumentu ARG jako wyrażenia arytmetycznego. Obliczenia\n"
"    są wykonywane dla liczb całkowitych o stałej długości bez sprawdzania\n"
"    przepełnienia, jednakże dzielenie przez 0 jest przechwytywane i oznaczane\n"
"    jako błąd. Poniższa lista operatorów jest pogrupowana na poziomy\n"
"    operatorów o jednakowym priorytecie. Poziomy są wypisane w kolejności\n"
"    malejącego priorytetu.\n"
"    \n"
"    \tid++, id--\tpost-inkrementacja, post-dekrementacja zmiennej\n"
"    \t++id, --id\tpre-inkrementacja, pre-dekrementacja zmiennej\n"
"    \t-, +\t\tjednoargumentowy minus, plus\n"
"    \t!, ~\t\tlogiczna i bitowa negacja\n"
"    \t**\t\tpotęgowanie\n"
"    \t*, /, %\t\tmnożenie, dzielenie, reszta z dzielenia\n"
"    \t+, -\t\tdodawanie, odejmowanie\n"
"    \t<<, >>\t\tprzesunięcie bitowe w lewo i w prawo\n"
"    \t<=, >=, <, >\tporównanie\n"
"    \t==, !=\t\trówność, nierówność\n"
"    \t&\t\tbitowe AND\n"
"    \t^\t\tbitowe XOR\n"
"    \t|\t\tbitowe OR\n"
"    \t&&\t\tlogiczne AND\n"
"    \t||\t\tlogiczne OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\toperator warunkowy\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tprzypisanie\n"
"    \n"
"    Jako operandy mogą występować zmienne powłoki. Nazwa zmiennej jest\n"
"    zastępowana w w wyrażeniu jej wartością (po konwersji do liczby\n"
"    całkowitej o stałej długości). Zmienna, aby mogła być użyta\n"
"    w wyrażeniu, nie musi mieć ustawionego atrybutu integer.\n"
"    \n"
"    Operacje są wykonywane wg. priorytetów operatorów. Najpierw są\n"
"    wykonywane podwyrażenia w nawiasach i mają one pierwszeństwo przed\n"
"    powyższymi priorytetami operatorów.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Jeśli wartością ostatniego argumentu jest 0, let zwraca 1;\n"
"    w pozostałych przypadkach zwracane jest 0."

#: builtins.c:994
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters. By default, the backslash character escapes delimiter characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times out\n"
"    (in which case it's greater than 128), a variable assignment error occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Odczyt wiersza ze standardowego wejścia i podział go na pola.\n"
"    \n"
"    Odczytanie wiersza ze standardowego wejścia lub deskryptora FD (jeśli\n"
"    podano opcję -u). Wiersz jest dzielony na pola wg reguł podziału na słowa,\n"
"    pierwsze słowo jest przypisywane pierwszej NAZWIE, drugie - drugiej NAZWIE\n"
"    itd.; wszystkie pozostałe słowa są przypisywane ostatniej NAZWIE. Jako\n"
"    ograniczniki słów są rozpoznawane tylko znaki ze zmiennej $IFS. Domyślnie\n"
"    znak odwrotnego ukośnika chroni znaki ograniczników i nowej linii.\n"
"    \n"
"    Jeśli nie podano NAZW, odczytany wiersz jest zapisywany w zmiennej REPLY.\n"
"    \n"
"    Opcje:\n"
"      -a tablica\tprzypisanie odczytanych słów do indeksów sekwencyjnych\n"
"    \t\tzmiennej tablicowej TABLICA, począwszy od zera\n"
"      -d ogr\tkontynuacja do odczytu pierwszego znaku OGR zamiast znaku nowej\n"
"    \t\tlinii\n"
"      -e\tużycie Readline'a do odczytania wiersza\n"
"      -o tekst\tużycie TEKSTU jako początkowego tekstu dla Readline'a\n"
"      -n liczba\tpowrót po odczycie LICZBY znaków zamiast oczekiwania na\n"
"    \t\tznak nowej linii; ogranicznik jest honorowany, jeśli odczytano mniej\n"
"    \t\tniż podana LICZBA znaków przed ogranicznikiem\n"
"      -N liczba\tpowrót tylko po odczycie dokładnie podanej LICZBY znaków,\n"
"    \t\tchyba że zostanie napotkany EOF lub opłynie czas; ograniczniki są\n"
"    \t\tignorowane\n"
"      -p zachęta\twypisanie łańcucha ZACHĘTY bez końcowego znaku nowej linii\n"
"    \t\tprzed próbą odczytu\n"
"      -r\twyłączenie interpretowania odwrotnych ukośników jako przedrostka\n"
"    \t\tznaków specjalnych\n"
"      -s\tbez wypisywania wejścia pochodzącego z terminala\n"
"      -t czas\tzakończenie i zwrócenie niepowodzenia, jeśli nie zostanie\n"
"    \t\todczytany cały wiersz przed upłynięciem podanego CZASU (w sekundach).\n"
"    \t\tWartość zmiennej TMOUT jest domyślnym limitem czasu. CZAS może być\n"
"    \t\tułamkowy. Przy wartości 0 odczyt powiedzie się tylko wtedy, gdy\n"
"    \t\twejście jest dostępne na podanym deskryptorze. Kod (stan) wyjściowy\n"
"    \t\tw przypadku osiągnięcia limitu czasu jest większy niż 128\n"
"      -u fd\todczyt z deskryptora pliku FD zamiast ze standardowego wejścia\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest wartość 0, chyba że zostanie napotkany koniec pliku,\n"
"    osiągnięty limit czasu (w tym przypadku jest większy niż 128), wystąpi\n"
"    błąd przypisania zmiennej albo podano nieprawidłowy deskryptor dla\n"
"    argumentu -u."

#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Powrót z funkcji powłoki.\n"
"    \n"
"    Polecenie powoduje, że funkcja lub włączony skrypt kończy się zwracając\n"
"    wartość podaną jako N. Jeśli pominięto N, stanem wyjściowym będzie stan\n"
"    ostatniego polecenia wykonanego w funkcji lub skrypcie.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracane jest N lub niepowodzenie, jeśli powłoka nie wykonuje żadnej\n"
"    funkcji ani skryptu."

#: builtins.c:1055
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Ustawianie lub anulowanie opcji powłoki i parametrów pozycyjnych.\n"
"    \n"
"    Zmiana wartości atrybutów powłoki i parametrów pozycyjnych lub\n"
"    wyświetlenie nazw i wartości zmiennych powłoki.\n"
"    \n"
"    Opcje:\n"
"      -a  Oznaczenie zmiennych, które zostały zmodyfikowane lub utworzone\n"
"          jako eksportowane.\n"
"      -b  Natychmiastowe powiadomienie o zakończeniu zadania.\n"
"      -e  Natychmiastowe zakończenie, gdy polecenie zakończy się z\n"
"          niezerowym stanem (kodem powrotu).\n"
"      -f  Wyłączenie generowania nazw plików (globbing).\n"
"      -h  Pamiętanie położenia znalezionych poleceń.\n"
"      -k  Umieszczanie w środowisku polecenia wszystkich argumentów\n"
"          o postaci przypisania, nie tylko tych, które poprzedzają nazwę\n"
"          polecenia.\n"
"      -m  Włączenie kontroli zadań.\n"
"      -n  Czytanie poleceń bez wykonywania ich.\n"
"      -o nazwa-opcji\n"
"          Ustawienie zmiennej odpowiadającej nazwa-opcji:\n"
"              allexport    to samo, co -a\n"
"              braceexpand  to samo, co -B\n"
"              emacs        korzystanie z interfejsu edycji wiersza w stylu\n"
"                           emacsa\n"
"              errexit      to samo, co -e\n"
"              errtrace     to samo, co -E\n"
"              functrace    to samo, co -T\n"
"              hashall      to samo, co -h\n"
"              histexpand   to samo, co -H\n"
"              history      włączenie historii poleceń\n"
"              ignoreeof    niekończenie powłoki po odczytaniu EOF\n"
"              interactive-comments\n"
"                           zezwolenie na wystąpienie komentarzy\n"
"                           w poleceniach interaktywnych\n"
"              keyword      to samo, co -k\n"
"              monitor      to samo, co -m\n"
"              noclobber    to samo, co -C\n"
"              noexec       to samo, co -n\n"
"              noglob       to samo, co -f\n"
"              nolog        aktualnie akceptowane ale ignorowane\n"
"              notify       to samo, co -b\n"
"              nounset      to samo, co -u\n"
"              onecmd       to samo, co -t\n"
"              physical     to samo, co -P\n"
"              pipefail     kodem powrotu potoku jest kod powrotu ostatniego\n"
"                           polecenia kończącego się z niezerowym kodem lub\n"
"                           zero, gdy żadne polecenie nie zakończyło się z\n"
"                           niezerowym kodem powrotu\n"
"              posix        zmiana zachowania basha, gdy standardowe\n"
"                           zachowanie operacji różni się od standardu\n"
"                           POSIX na zgodne ze standardem\n"
"              privileged   to samo, co -p\n"
"              verbose      to samo, co -v\n"
"              vi           korzystanie z interfejsu edycji wiersza w stylu vi\n"
"              xtrace       to samo, co -x\n"
"      -p  Włączone, gdy nie zgadzają się rzeczywisty i efektywny ID\n"
"            użytkownika. Wyłącza przetwarzanie pliku $ENV oraz import funkcji\n"
"            powłoki. Wyłączenie tej opcji powoduje, że efektywne UID i GID\n"
"            zostaną ustawione na rzeczywiste UID i GID.\n"
"      -t  Zakończenie po przeczytaniu i uruchomieniu jednego polecenia.\n"
"      -u  Traktowanie podczas podstawienia nieustawionych zmiennych jako\n"
"          błędów.\n"
"      -v  Wypisywanie wejścia powłoki tak, jak zostało przeczytane.\n"
"      -x  Wypisywanie poleceń i ich argumentów tak, jak są uruchamiane.\n"
"      -B  Przeprowadzanie przez powłokę rozwijania nawiasów.\n"
"      -C  Gdy ustawione, niepozwalanie na nadpisywanie istniejących\n"
"          zwykłych plików przez przekierowanie wyjścia.\n"
"      -E  Gdy ustawione, dziedziczenie pułapki ERR przez funkcje powłoki.\n"
"      -H  Włączenie podstawienia historii w stylu `!'. Znacznik ten jest\n"
"          domyślnie włączony dla powłoki interaktywnej.\n"
"      -P  Gdy ustawione, nierozwiązywanie dowiązań symbolicznych podczas\n"
"          uruchamiania poleceń takich, jak cd, które zmieniają katalog\n"
"          bieżący.\n"
"      -T  Gdy ustawione, dziedziczenie pułapek DEBUG i RETURN przez funkcje.\n"
"      --  Przypisanie pozostałych argumentów do parametrów pozycyjnych.\n"
"          Jeśli nie ma więcej argumentów, parametry pozycyjne są anulowane.\n"
"      -   Przypisanie pozostałych argumentów do argumentów pozycyjnych.\n"
"          Wyłączenie opcji -x i -v.\n"
"    \n"
"    Użycie + zamiast - powoduje wyłączenie powyższych znaczników. Można z nich\n"
"    także korzystać przy uruchomieniu powłoki. Aktualny zestaw opcji można\n"
"    znaleźć w $-. Pozostałe n argumentów staje się parametrami pozycyjnymi\n"
"    i są one przypisane, kolejno, do $1, $2, .. $n. Gdy nie zostaną podane\n"
"    żadne argumenty, wypisywane są wszystkie zmienne powłoki.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano nieprawidłową opcję."

#: builtins.c:1140
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Anulowanie wartości i atrybutów zmiennych i funkcji powłoki.\n"
"    \n"
"    Usunięcie zmiennych i funkcji o podanych NAZWACH.\n"
"    \n"
"    Opcje:\n"
"      -f\tpotraktowanie wszystkich NAZW jako funkcji powłoki\n"
"      -v\tpotraktowanie wszystkich NAZW jako zmiennych powłoki\n"
"      -n\tpotraktowanie wszystkich NAZW jako referencji do nazw\n"
"    \t\ti anulowanie samej zmiennej zamiast tej, do której się odnosi\n"
"    \n"
"    Bez opcji unset próbuje najpierw anulować definicję zmiennej, a jeśli to\n"
"    się nie powiedzie, próbuje anulować definicję funkcji.\n"
"    \n"
"    Niektórych zmiennych nie można usunąć - p. `readonly'.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję lub NAZWA jest tylko do\n"
"    odczytu."

#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Ustawienie atrybutu eksportowania dla zmiennych powłoki.\n"
"    \n"
"    Zaznaczenie każdej NAZWY do automatycznego eksportowania do środowiska\n"
"    później wywoływanych poleceń. Jeśli podano WARTOŚĆ, jest ona przypisywana\n"
"    przed eksportowaniem.\n"
"    \n"
"    Opcje:\n"
"      -f\tdziałanie na funkcjach powłoki\n"
"      -n\tusunięcie atrybutu eksportowania z każdej NAZWY\n"
"      -p\twyświetlenie listy wszystkich eksportowanych zmiennych i funkcji\n"
"    \n"
"    Argument `--' kończy dalsze przetwarzanie opcji.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano nieprawidłową opcję lub NAZWĘ."

#: builtins.c:1181
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Oznaczenie zmiennych powłoki jako niezmiennych.\n"
"    \n"
"    Oznaczenie każdej NAZWY jako tylko do odczytu; wartości tych NAZW nie mogą\n"
"    być zmieniane przez późniejsze podstawienia. Jeśli podano WARTOŚĆ, jest\n"
"    ona przypisywana przed oznaczeniem jako tylko do odczytu.\n"
"    \n"
"    Opcje:\n"
"      -a\tdziałanie na zmiennych tablicowych indeksowanych\n"
"      -A\tdziałanie na zmiennych tablicowych asocjacyjnych\n"
"      -f\tdziałanie na funkcjach powłoki\n"
"      -p\twyświetlenie listy wszystkich zmiennych lub funkcji tylko do odczytu,\n"
"    \t\tw zależności od tego, czy podano opcję -f\n"
"    \n"
"    Argument `--' wyłącza dalsze przetwarzanie opcji.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano nieprawidłową opcję lub NAZWĘ."

#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Przesunięcie argumentów pozycyjnych.\n"
"    \n"
"    Zmiana nazw argumentów pozycyjnych $N+1,$N+2 ... na $1,$2 ...\n"
"    Jeśli nie podano N, przyjmuje się 1.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że N jest ujemne lub większe niż $#."

#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Wykonanie poleceń z pliku w bieżącej powłoce.\n"
"    \n"
"    Odczytanie i uruchomienie poleceń z PLIKU w bieżącej powłoce. Do\n"
"    znalezienia katalogu zawierającego PLIK używane są ścieżki zawarte\n"
"    w $PATH. Jeśli podane zostaną jakiekolwiek ARGUMENTY, stają się\n"
"    parametrami pozycyjnymi podczas uruchomienia PLIKU.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest stan ostatnio wykonanego polecenia z PLIKU lub błąd, jeśli\n"
"    PLIKU nie udało się odczytać."

#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Wstrzymanie wykonywania powłoki.\n"
"    \n"
"    Wstrzymanie wykonywania danego skryptu do czasu otrzymania sygnału\n"
"    SIGCONT. Jeśli nie podano opcji wymuszenia, powłoki logowania nie można\n"
"    wstrzymać.\n"
"    \n"
"    Opcje:\n"
"      -f\twymuszenie wstrzymania, nawet jeśli powłoka jest powłoką logowania\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że kontrola zadań jest wyłączona lub wystąpi\n"
"    błąd."

#: builtins.c:1262
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Obliczenie wyrażenia warunkowego.\n"
"    \n"
"    Polecenie zwracające kod 0 (prawda) lub 1 (fałsz) w zależności od wyniku\n"
"    obliczenia WYRAŻENIA. Wyrażenia mogą mieć postać jedno- lub dwuargumentową.\n"
"    Jednoargumentowe wyrażenia służą zwykle do badania stanu pliku. Istnieją\n"
"    również operatory działające na łańcuchach tekstowych, jak też operatory\n"
"    numerycznego porównania.\n"
"    \n"
"    Zachowanie polecenia test zależy od liczby argumentów. Pełną specyfikację\n"
"    można znaleźć w podręczniku man do basha.\n"
"    \n"
"    Operatory plikowe:\n"
"    \n"
"      -a PLIK        Prawda, gdy PLIK istnieje.\n"
"      -b PLIK        Prawda, gdy PLIK jest plikiem specjalnym urządzenia\n"
"                     blokowego.\n"
"      -c PLIK        Prawda, gdy PLIK jest plikiem specjalnym urządzenia\n"
"                     znakowego.\n"
"      -d PLIK        Prawda, gdy PLIK jest katalogiem.\n"
"      -e PLIK        Prawda, gdy PLIK istnieje.\n"
"      -f PLIK        Prawda, gdy PLIK istnieje i jest zwykłym plikiem.\n"
"      -g PLIK        Prawda, gdy PLIK ma ustawiony bit SGID.\n"
"      -h PLIK        Prawda, gdy PLIK jest dowiązaniem symbolicznym.\n"
"      -L PLIK        Prawda, gdy PLIK jest dowiązaniem symbolicznym.\n"
"      -k PLIK        Prawda, gdy PLIK ma ustawiony bit `sticky'.\n"
"      -p PLIK        Prawda, gdy PLIK jest nazwanym potokiem.\n"
"      -r PLIK        Prawda, gdy PLIK jest odczytywalny przez użytkownika.\n"
"      -s PLIK        Prawda, gdy PLIK istnieje i jest niepusty.\n"
"      -S PLIK        Prawda, gdy PLIK jest gniazdem.\n"
"      -t FD          Prawda, gdy deskryptor FD jest otwarty na terminalu.\n"
"      -u FILE        Prawda, gdy PLIK ma ustawiony bit SUID.\n"
"      -w FILE        Prawda, gdy PLIK jest zapisywalny przez użytkownika.\n"
"      -x FILE        Prawda, gdy PLIK jest uruchamialny przez użytkownika.\n"
"      -O FILE        Prawda, gdy użytkownik jest efektywnym właścicielem PLIKU.\n"
"      -G FILE        Prawda, grupa użytkownika jest efektywnym właścicielem\n"
"                     PLIKU.\n"
"      -N FILE        Prawda, gdy PLIK został zmodyfikowany po ostatnim\n"
"                     odczycie.\n"
"    \n"
"      PLIK1 -nt PLIK2  Prawda, gdy PLIK1 jest nowszy niż PLIK2 (porównując\n"
"                       czas ostatniej modyfikacji).\n"
"    \n"
"      PLIK1 -ot PLIK2  Prawda, gdy PLIK1 jest starszy niż PLIK2.\n"
"    \n"
"      PLIK1 -ef PLIK2  Prawda, gdy PLIK1 jest twardym dowiązaniem do PLIK2.\n"
"    \n"
"    Operatory łańcuchowe:\n"
"    \n"
"      -z ŁAŃCUCH     Prawda, gdy ŁAŃCUCH jest pusty.\n"
"    \n"
"      -n ŁAŃCUCH\n"
"         ŁAŃCUCH     Prawda, gdy ŁAŃCUCH nie jest pusty.\n"
"    \n"
"      ŁAŃCUCH1 = ŁAŃCUCH2\n"
"                     Prawda, gdy ŁAŃCUCH1 i ŁAŃCUCH2 są równe.\n"
"      ŁAŃCUCH1 != ŁAŃCUCH2\n"
"                     Prawda, gdy ŁAŃCUCH1 i ŁAŃCUCH2 nie są równe.\n"
"      ŁAŃCUCH1 < ŁAŃCUCH2\n"
"                     Prawda, gdy ŁAŃCUCH1 znajduje się w porządku\n"
"                     leksykograficznym przed ŁAŃCUCHEM2.\n"
"      ŁAŃCUCH1 > ŁAŃCUCH2\n"
"                     Prawda, gdy ŁAŃCUCH1 znajduje się w porządku\n"
"                     leksykograficznym po ŁAŃCUCHU2.\n"
"    \n"
"    Inne operatory:\n"
"    \n"
"      -o OPCJA       Prawda, gdy podana OPCJA powłoki jest włączona.\n"
"      -v ZMIENNA     Prawda, gdy ZMIENNA powłoki jest ustawiona\n"
"      -R ZMIENNA     Prawda, gdy zmienna powłoki jest ustawiona i jest\n"
"                     referencją do nazwy\n"
"      ! WYRAŻENIE    Prawda, gdy WYRAŻENIE jest fałszywe.\n"
"      WYR1 -a WYR2   Prawda, gdy zarówno WYR1, jak i WYR2 są prawdziwe.\n"
"      WYR1 -o WYR2   Prawda, gdy WYR1 lub WYR2 jest prawdziwe.\n"
"    \n"
"      arg1 OP arg2   Testy arytmetyczne. OP jest jednym z operatorów:\n"
"                     -eq, -ne, -lt, -le, -gt lub -ge.\n"
"    \n"
"    Dwuargumentowe operatory arytmetyczne zwracają prawdę, gdy ARG1 jest\n"
"    równy, nierówny, mniejszy niż, mniejszy lub równy, większy niż lub\n"
"    większy lub równy ARG2.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, jeśli wartością WYRAŻENIA jest prawda; fałsz, gdy\n"
"    wartością WYRAŻENIA jest fałsz lub podano błędny argument."

#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Obliczenie wyrażenia warunkowego.\n"
"    \n"
"    Jest to synonim dla wbudowanego polecenia \"test\", ale wymagający, by\n"
"    ostatnim argumentem był `]' pasujący do początkowego `['."

#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Wyświetlenie czasów procesu.\n"
"    \n"
"    Wypisanie łącznych czasów w przestrzeni użytkownika i systemu dla powłoki\n"
"    i wszystkich procesów potomnych.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zawsze prawda."

#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or a\n"
"    script run by the . or source builtins finishes executing.  A SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is given."
msgstr ""
"Przechwytywanie sygnałów i innych zdarzeń.\n"
"    \n"
"    Polecenie definiujące i włączające daną akcję w przypadku, kiedy powłoka\n"
"    otrzyma sygnał lub pod innymi warunkami.\n"
"    \n"
"    Gdy powłoka otrzyma podany SYGNAŁ (lub sygnały), odczytywane i uruchamiane\n"
"    jest polecenie podane jako argument ARG. W razie braku argumentu (i podaniu\n"
"    pojedynczego SYGNAŁU) lub gdy argumentem jest `-', każdemu z podanych\n"
"    sygnałów jest przywracane pierwotne zachowanie. Jeśli ARG jest pustym\n"
"    łańcuchem, każdy SYGNAŁ jest ignorowany przez powłokę i wywołane przez nią\n"
"    polecenia.\n"
"    \n"
"    Jeżeli jako SYGNAŁ podano EXIT (0), polecenie ARG jest uruchamiane przy\n"
"    opuszczaniu powłoki. Jeśli jako SYGNAŁ podano DEBUG, ARG jest uruchamiane\n"
"    po każdym poleceniu prostym. Jeśli jako SYGNAŁ podano RETURN, ARG jest\n"
"    uruchamiane przy każdym zakończeniu funkcji powłoki lub skryptu\n"
"    uruchamianego przez polecenia wbudowane . lub source. Jeśli jako SYGNAŁ\n"
"    podano ERR, ARG jest uruchamiane za każdym razem, kiedy niepowodzenie\n"
"    polecenia spowodowałoby zakończenie powłoki w przypadku włączenia opcji -e.\n"
"    \n"
"    Jeśli nie podano argumentów, trap wypisuje listę poleceń przypisanych do\n"
"    każdego sygnału.\n"
"    \n"
"    Opcje:\n"
"      -l\twypisanie listy nazw sygnałów i ich numerów\n"
"      -p\twypisanie poleceń trap powiązanych z każdym SYGNAŁEM\n"
"    \n"
"    Każdy podawany SYGNAŁ może być nazwą sygnału wg. <signal.h> lub numerem\n"
"    sygnału. Nazwy sygnałów są niewrażliwe na wielkość liter, a prefiks SIG\n"
"    jest opcjonalny. Sygnał do powłoki można wysłać poleceniem\n"
"    \"kill -sygnał $$\".\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędny SYGNAŁ lub błędną opcję."

#: builtins.c:1401
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"Wyświetlenie informacji o rodzaju polecenia.\n"
"    \n"
"    Określenie, w jaki sposób byłaby interpretowana każda NAZWA w przypadku\n"
"    użycia jako polecenie.\n"
"    \n"
"    Opcje:\n"
"      -a\twyświetlenie wszystkich położeń zawierających program wykonywalny\n"
"    \t\to podanej NAZWIE; obejmuje aliasy, polecenia wbudowane i funkcje\n"
"    \t\ttylko jeśli nie podano dodatkowo opcji `-p'\n"
"      -f\tpominięcie wyszukiwania funkcji powłoki\n"
"      -P\twymuszenie wyszukiwania w PATH każdej nazwy, nawet jeśli jest\n"
"    \t\taliasem, poleceniem wbudowanym lub funkcją i zwrócenie nazwy pliku\n"
"    \t\tna dysku\n"
"      -p\tzwrócenie nazwy pliku na dysku lub niczego, jeśli `type -t NAZWA'\n"
"    \t\tnie zwróciłoby `file'.\n"
"      -t\tzwrócenie pojedynczego słowa: `alias', `keyword', `function',\n"
"    \t\t`builtin', `file' lub `', jeśli nazwa jest odpowiednio: aliasem,\n"
"    \t\tzarezerwowanym słowem kluczowym powłoki, funkcją powłoki, poleceniem\n"
"    \t\twbudowanym powłoki, plikiem na dysku lub nie zostanie znaleziona\n"
"    \n"
"    Argumenty:\n"
"      NAZWA\tNazwa polecenia do zinterpretowania.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, jeśli każda NAZWA zostanie znaleziona; fałsz, jeśli\n"
"    którakolwiek nie zostanie znaleziona."

#: builtins.c:1432
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Modyfikowanie limitów zasobów powłoki.\n"
"    \n"
"    Ulimit zapewnia kontrolę ilości zasobów udostępnionych powłoce i procesom\n"
"    w systemach, które taką kontrolę umożliwiają.\n"
"    \n"
"    Opcje:\n"
"      -S\tkorzystanie z \"miękkiego\" limitu zasobów\n"
"      -H\tkorzystanie ze \"sztywnego\" limitu zasobów\n"
"      -a\twypisanie wszystkich aktualnych limitów\n"
"      -b\trozmiar bufora dla gniazd\n"
"      -c\tmaksymalny rozmiar tworzonych plików core\n"
"      -d\tmaksymalny rozmiar segmentu danych procesu\n"
"      -e\tmaksymalny priorytet szeregowania procesów (`nice')\n"
"      -f\tmaksymalny rozmiar plików zapisywanych przez powłokę i jej potomków\n"
"      -i\tmaksymalna liczba oczekujących sygnałów\n"
"      -k\tmaksymalna liczba kolejek jądra (kqueue) przydzielonych dla procesu\n"
"      -l\tmaksymalny rozmiar pamięci, którą proces może zablokować\n"
"      -m\tmaksymalny rozmiar obszaru rezydentnego procesu\n"
"      -n\tmaksymalna liczba otwartych deskryptorów plików\n"
"      -p\trozmiar bufora potoku\n"
"      -q\tmaksymalna liczba bajtów w POSIX-owych kolejkach komunikatów\n"
"      -r\tmaksymalny priorytet szeregowania dla procesów czasu rzeczywistego\n"
"      -s\tmaksymalny rozmiar stosu\n"
"      -t\tmaksymalna ilość czasu procesora w sekundach\n"
"      -u\tmaksymalna liczba procesów użytkownika\n"
"      -v\trozmiar pamięci wirtualnej\n"
"      -x\tmaksymalna liczba blokad plików\n"
"      -P\tmaksymalna liczba pseudoterminali\n"
"      -R\tmaksymalny czas, jaki proces real-time może działać bez blokowania\n"
"      -T\tmaksymalna liczba wątków\n"
"    \n"
"    Nie wszystkie opcje są dostępne na wszystkich platformach.\n"
"    \n"
"    Gdy podano wartość LIMITU, stanowi ona nową wartość ograniczenia dla\n"
"    danego zasobu; specjalne wartości LIMITU: `soft', `hard' i `unlimited'\n"
"    oznaczają, odpowiednio, aktualne ograniczenie miękkie, sztywne i brak\n"
"    ograniczenia. W przeciwnym przypadku wypisywana jest aktualna wartość\n"
"    podanego ograniczenia. Gdy nie podano opcji, przyjmuje się, że podano -f.\n"
"    \n"
"    Wartości są podawane w jednostkach 1024-bajtowych, za wyjątkiem -t, które\n"
"    jest w sekundach, -p, które jest w jednostkach 512-bajtowych oraz -u, które\n"
"    jest bezwymiarową liczbą procesów.\n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję lub wystąpi błąd."

#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Wyświetlanie i ustawianie maski uprawnień plików.\n"
"    \n"
"    Ustawienie maski uprawnień tworzonych plików na UPRAWNIENIA. Jeśli\n"
"    pominięto UPRAWNIENIA, wypisywana jest aktualna wartość maski.\n"
"    \n"
"    Jeśli UPRAWNIENIA zaczynają się od cyfry, są interpretowane jako liczba\n"
"    ósemkowa; w przeciwnym wypadku jako łańcuch symbolicznych uprawnień,\n"
"    jak w poleceniu chmod(1).\n"
"    \n"
"    Opcje:\n"
"      -p\tjeśli pominięto UPRAWNIENIA, wypisywanie w formie nadającej się\n"
"    \tdo ponownego użycia jako wejście\n"
"      -S\twyjście w postaci symbolicznej; bez tej opcji jest ósemkowe\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędne uprawnienia lub błędną opcję."

#: builtins.c:1503
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Oczekiwanie na zakończenie zadania i zwrócenie stanu (kodu) wyjścia.\n"
"    \n"
"    Oczekiwanie na każdy proces o podanym identyfikatorze ID, który może być\n"
"    numerem PID lub określeniem zadania i zgłoszenie jego stanu (kodu)\n"
"    zakończenia. Jeśli nie podano ID, polecenie oczekuje na wszystkie aktualnie\n"
"    aktywne procesy potomne i zwraca prawdę. Jeśli ID jest określeniem zadania,\n"
"    oczekuje na wszystkie procesy w potoku przetwarzania danego zadania.\n"
"    \n"
"    Jeśli podano opcję -n, oczekiwanie na zakończenie następnego zadania\n"
"    i zwrócenie jego kodu zakończenia.\n"
"    \n"
"    Jeśli podano opcję -p, identyfikator procesu lub zadania, dla którego\n"
"    zwracany jest stan wyjścia, przypisywany jest do ZMIENNEJ, której nazwa\n"
"    jest podana jako argument opcji. Zmienna początkowo jest kasowana. Jest\n"
"    to przydatne tylko w przypadku podania opcji -n.\n"
"    \n"
"    Jeśli podano opcję -f, a kontrola zadań jest włączona, oczekiwanie na\n"
"    zakończenie podanego ID zamiast czekania na zmianę jego stanu.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest stan zakończenia ID; niepowodzenie, jeśli ID jest\n"
"    nieprawidłowe lub podano błędną opcję."

#: builtins.c:1534
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an invalid\n"
"    option is given."
msgstr ""
"Oczekiwanie na zakończenie procesu i zwrócenie stanu (kodu) wyjścia.\n"
"    \n"
"    Oczekiwanie na każdy z procesów podany przez PID i zgłoszenie jego statusu\n"
"    zakończenia. Gdy nie zostanie podany PID, oczekiwanie dotyczy wszystkich\n"
"    aktualnie aktywnych procesów potomnych, a kodem powrotu jest zero. PID musi\n"
"    być identyfikatorem procesu.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest status ID lub niepowodzenie, jeśli ID jest błędny lub podano\n"
"    nieprawidłową opcję."

#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Wykonanie poleceń dla każdego elementu z listy.\n"
"    \n"
"    Pętla `for' uruchamia ciąg poleceń dla każdego elementu podanej listy. Gdy\n"
"    nie zostanie podane `in SŁOWA ...;', zakłada się, że podano `in \"$@\"'.\n"
"    Dla każdego elementu SŁÓW, NAZWA jest ustawiana na ten element\n"
"    i uruchamiane są POLECENIA.    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest status zakończenia ostatniego wykonanego polecenia."

#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Arytmetyczna pętla for.\n"
"    \n"
"    Równoważne\n"
"    \t(( WYR1 ))\n"
"    \twhile (( WYR2 )); do\n"
"    \t\tPOLECENIA\n"
"    \t\t(( WYR3 ))\n"
"    \tdone\n"
"    WYR1, WYR2 i WYR3 są wyrażeniami arytmetycznymi. Jeśli któreś z wyrażeń\n"
"    zostanie pominięte, zachowanie jest takie, jakby miało ono wartość 1.    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest status zakończenia ostatniego wykonanego polecenia."

#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Wybór słów z listy i wykonanie poleceń.\n"
"    SŁOWA są rozwijane, co tworzy listę słów. Zbiór rozwiniętych słów\n"
"    wypisywany jest na standardowym wyjściu diagnostycznym, a każde słowo jest\n"
"    poprzedzone przez liczbę. Gdy nie zostanie podane `in SŁOWA', zakłada\n"
"    się, że podano `in \"$@\"'. Wyświetlany jest wówczas tekst zachęty PS3\n"
"    i odczytywany jest wiersz ze standardowego wejścia. Gdy wiersz ten składa\n"
"    się z liczby przypisanej do jednego z wypisanych słów, to NAZWA jest\n"
"    ustawiana na to słowo. Gdy wiersz jest pusty, SŁOWA i tekst zachęty są\n"
"    wyświetlane ponownie. Gdy odczytany zostanie EOF, polecenie się kończy.\n"
"    Każda inna wartość powoduje przypisanie NAZWIE wartości pustej. Odczytany\n"
"    wiersz jest zachowywany w zmiennej REPLY. Po każdym wyborze uruchamiane\n"
"    są POLECENIA aż do polecenia break.    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest status zakończenia ostatniego wykonanego polecenia."

#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Zgłoszenie czasu zajętego przez wykonanie potoku poleceń.\n"
"    \n"
"    Uruchomienie POTOKU poleceń i wypisanie podsumowania zawierającego czas\n"
"    rzeczywisty, czas procesora w trybie użytkownika oraz czas procesora\n"
"    w trybie systemu, jakie spędził POTOK poleceń do chwili zakończenia.\n"
"    \n"
"    Opcje:\n"
"      -p\twypisanie podsumowania czasów w przenośnym formacie POSIX\n"
"    \n"
"    Jako format danych wyjściowych używana jest wartość zmiennej TIMEFORMAT.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Polecenie zwraca status zakończenia POTOKU poleceń."

#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Wykonanie poleceń w oparciu o dopasowanie do wzorców.\n"
"    \n"
"    Wybiórcze uruchamianie POLECEŃ w zależności od tego, czy SŁOWO pasuje\n"
"    do WZORCA. Znak `|' służy do rozdzielania wielu wzorców.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest status zakończenia ostatniego wykonanego polecenia."

#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Wykonanie poleceń w zależności od spełnienia warunku.\n"
"    \n"
"    Uruchamiana jest lista `if POLECENIA'. Gdy jej kod powrotu jest zerem,\n"
"    uruchamiana jest lista `then POLECENIA'. W przeciwnym przypadku\n"
"    uruchamiane są poszczególne listy `elif POLECENIA' i, jeśli kod powrotu\n"
"    takiej listy jest zerem, uruchamiana jest odpowiednia lista\n"
"    `then POLECENIA', po czym polecenie if się kończy. W przeciwnym przypadku\n"
"    uruchamiana jest lista `else POLECENIA', jeśli taka istnieje. Kodem\n"
"    zakończenia całej konstrukcji jest kod zakończenia ostatniego\n"
"    uruchomionego polecenia lub zero, gdy żaden ze sprawdzanych warunków\n"
"    nie był prawdziwy.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest status zakończenia ostatniego wykonanego polecenia."

#: builtins.c:1648
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Wykonywanie poleceń dopóki test kończy się powodzeniem.\n"
"    \n"
"    Rozwijanie i uruchamianie POLECEŃ-2 dopóki ostatnie polecenie\n"
"    w POLECENIACH kończy się z kodem zerowym.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest status zakończenia ostatniego wykonanego polecenia."

#: builtins.c:1660
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Wykonywanie poleceń dopóki test nie kończy się powodzeniem.\n"
"    \n"
"    Rozwijanie i uruchamianie POLECEŃ-2 dopóki ostatnie polecenie\n"
"    w POLECENIACH kończy się z kodem niezerowym.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest status zakończenia ostatniego wykonanego polecenia."

#: builtins.c:1672
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Utworzenie koprocesu o podanej NAZWIE.\n"
"    \n"
"    Asynchroniczne wykonanie POLECENIA ze standardowym wyjściem i standardowym\n"
"    wejściem polecenia połączonych potokiem z deskryptorami plików\n"
"    przypisanymi do indeksów 0 i 1 zmiennej tablicowej NAZWA w powłoce.\n"
"    Domyślną NAZWĄ jest \"COPROC\".\n"
"    Stan wyjściowy:\n"
"    Polecenie coproc zwraca status wyjścia 0."

#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Zdefiniowanie funkcji powłoki.\n"
"    \n"
"    Utworzenie funkcji powłoki o podanej NAZWIE. Przy wywołaniu jako zwykłego\n"
"    polecenia NAZWA uruchamia POLECENIA w kontekście powłoki wywołującej.\n"
"    Przy wywoływaniu NAZWY, argumenty są przekazywane do funkcji jako $1...$n,\n"
"    a nazwa funkcji w $FUNCNAME.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest sukces, chyba że NAZWA jest tylko do odczytu."

#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Grupowanie poleceń jako jednostki.\n"
"    \n"
"    Uruchomienie zbioru poleceń jako grupy. W ten sposób można przekierować\n"
"    cały zbiór poleceń.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest status zakończenia ostatniego wykonanego polecenia."

#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Wznowienie zadania jako pierwszoplanowego.\n"
"    \n"
"    Równoważne argumentowi ZADANIE polecenia `fg'. Wznowienie zatrzymanego lub\n"
"    działającego w tle zadania. ZADANIE może określać nazwę zadania albo jego\n"
"    numer. Umieszczenie `&' po ZADANIU umieszcza zadanie w tle tak, jak to się\n"
"    dzieje po podaniu specyfikacji zadania jako argumentu dla `bg'.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracany jest stan wznowionego zadania."

#: builtins.c:1727
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Obliczenie wyrażenia arytmetycznego.\n"
"    \n"
"    Obliczenie WYRAŻENIA zgodnie z zasadami obliczania wyrażeń arytmetycznych.\n"
"    Równoważne `let \"WYRAŻENIE\"'.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracane jest 1, jeśli wartością WYRAŻENIA jest 0; 0 w przeciwnym wypadku."

#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Wykonanie polecenia warunkowego.\n"
"    \n"
"    Zwracany jest status wynoszący 0 lub 1 w zależności od wyniku WYRAŻENIA\n"
"    warunkowego. Wyrażenia są tworzone na tych samych zasadach, co w poleceniu\n"
"    `test' i mogą być łączone za pomocą następujących operatorów:\n"
"    \n"
"      ( WYRAŻENIE )\tzwraca wartość WYRAŻENIA\n"
"      ! WYRAŻENIE\tprawdziwe, gdy WYRAŻENIE jest fałszywe; fałszywe\n"
"    \t\t\tw innym przypadku\n"
"      WYR1 && WYR2\tPrawdziwe, gdy zarówno WYR1 jak i WYR2 są prawdziwe;\n"
"    \t\t\tfałszywe w innym przypadku\n"
"      WYR1 || WYR2\tPrawdziwe, gdy WYR1 lub WYR2 jest prawdziwe;\n"
"    \t\t\tfałszywe w innym przypadku\n"
"    \n"
"    W przypadku użycia operatorów `==' lub `!=' napis po prawej stronie\n"
"    operatora jest traktowany jak wzorzec i wykonywane jest dopasowywanie do\n"
"    wzorca. W przypadku użycia operatora `=~' łańcuch po prawej stronie\n"
"    operatora jest dopasowywany jako wyrażenie regularne.\n"
"    \n"
"    Operatory && i || nie obliczają WYR2, jeśli obliczenie WYR1 wystarcza do\n"
"    określenia wartości wyrażenia.\n"
"    \n"
"    Stan wyjściowy:\n"
"    0 lub 1 w zależności od wartości WYRAŻENIA."

#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Popularne zmienne powłoki i ich zastosowanie.\n"
"    \n"
"    BASH_VERSION\tInformacja o wersji tego Basha.\n"
"    CDPATH\tRozdzielona dwukropkami lista katalogów do wyszukiwania\n"
"    \t\tkatalogów podanych jako argumenty `cd'.\n"
"    GLOBIGNORE\tRozdzielona dwukropkami lista wzorców nazw plików\n"
"    \t\tdo ignorowania przy rozwijaniu ścieżek.\n"
"    HISTFILE\tNazwa pliku, w którym zapisywana jest historia poleceń.\n"
"    HISTFILESIZE\tMaksymalna liczba linii w tym pliku.\n"
"    HISTSIZE\tMaksymalna liczba linii historii, do której ma dostęp\n"
"    \t\tdziałająca powłoka.\n"
"    HOME\tPełna ścieżka do katalogu logowania.\n"
"    HOSTNAME\tNazwa bieżącego hosta.\n"
"    HOSTTYPE\tRodzaj procesora, na jakim działa ta wersja Basha.\n"
"    IGNOREEOF\tSterowanie akcją powłoki w przypadku odebrania znaku\n"
"    \t\tEOF jako jedynego wejścia. Jeśli zmienna jest ustawiona,\n"
"    \t\tjej wartością jest liczba znaków EOF, które mogą wystąpić\n"
"    \t\tw pustym wierszu przed zakończeniem powłoki (domyślnie 10).\n"
"    \t\tJeśli nie jest ustawiona, EOF oznacza koniec wejścia.\n"
"    MACHTYPE\tŁańcuch opisujący bieżący system, na jakim działa Bash.\n"
"    MAILCHECK\tOkreślenie jak często (w sekundach) Bash ma sprawdzać\n"
"    \t\tobecność nowej poczty.\n"
"    MAILPATH\tRozdzielona dwukropkami lista nazw plików, w których\n"
"    \t\tBash ma sprawdzać obecność nowej poczty.\n"
"    OSTYPE\tWersja Uniksa, na której działa ta wersja Basha.\n"
"    PATH\tRozdzielona dwukropkami lista katalogów do przeszukiwania\n"
"    \t\tprzy wyszukiwaniu poleceń.\n"
"    PROMPT_COMMAND\tPolecenie do wykonania przed wypisaniem każdego\n"
"    \t\tgłównego napisu zachęty.\n"
"    PS1\t\tGłówny napis zachęty.\n"
"    PS2\t\tDrugorzędny napis zachęty.\n"
"    PWD\t\tPełna ścieżka do bieżącego katalogu.\n"
"    SHELLOPTS\tRozdzielona dwukropkami lista włączonych opcji powłoki.\n"
"    TERM\tNazwa typu bieżącego terminala.\n"
"    TIMEFORMAT\tFormat wyjściowy do statystyk czasu wyświetlanych przez\n"
"    \t\tpolecenie wbudowane `time'.\n"
"    auto_resume\tWartość niepusta oznacza, że słowo polecenia występujące\n"
"    \t\tw linii jako jedyne jest najpierw wyszukiwane na liście aktualnie\n"
"    \t\tzatrzymanych zadań. Jeśli tam zostanie znalezione, to zadanie\n"
"    \t\tjest wznawiane jako pierwszoplanowe. Wartość `exact' oznacza, że\n"
"    \t\tsłowo polecenia musi dokładnie pasować do polecenia na liście\n"
"    \t\tzadań zatrzymanych. Wartość `substring' oznacza, że słowo\n"
"    \t\tpolecenia musi pasować do podciągu zadania. Każda inna wartość\n"
"    \t\toznacza, że polecenie musi być przedrostkiem zatrzymanego\n"
"    \t\tzadania.\n"
"    histchars\tZnaki sterujące rozwijaniem wg historii i szybkim\n"
"    \t\tpodstawianiem. Pierwszy znak jest znakiem podstawiania\n"
"    \t\thistorii, zwykle `!'. Drugi jest znakiem \"szybkiego podstawienia\",\n"
"    \t\tzwykle `^'. Trzeci znak jest znakiem \"komentarza historii\",\n"
"    \t\tzwykle `#'.\n"
"    HISTIGNORE\tRozdzielona dwukropkami lista wzorców używanych przy\n"
"    \t\tdecydowaniu, które polecenia powinny być zapisywane na liście\n"
"    \t\thistorii.\n"

#: builtins.c:1822
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Dodanie katalogów do stosu.\n"
"    \n"
"    Dodanie katalogu na wierzchołku stosu katalogów lub rotacja stosu\n"
"    czyniąca jego nowym wierzchołkiem bieżący katalog roboczy. Wywołane bez\n"
"    argumentów zamienia na stosie dwa najwyższe katalogi.\n"
"    \n"
"    Opcje:\n"
"      -n\tPominięcie zmiany katalogu podczas umieszczania katalogów na\n"
"    \t\tstosie tak, że zmieniany jest tylko stos.\n"
"    \n"
"    Argumenty:\n"
"      +N\tRotacja stosu czyniąca jego wierzchołkiem N-ty katalog (licząc\n"
"    \t\tod lewej strony listy wypisywanej przez `dirs', począwszy od zera).\n"
"    \n"
"      -N\tRotacja stosu czyniąca jego wierzchołkiem N-ty katalog (licząc\n"
"    \t\tod prawej strony listy wypisywanej przez `dirs', począwszy od zera).\n"
"    \n"
"      KATALOG\tUmieszczenie KATALOGU na wierzchołku stosu i uczynienie go\n"
"    \t\tnowym bieżącym katalogiem roboczym.\n"
"    \n"
"    Zawartość stosu katalogów można zobaczyć za pomocą polecenia `dirs'.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędny argument lub zmiana katalogu\n"
"    się nie powiedzie."

#: builtins.c:1856
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Usunięcie katalogów ze stosu.\n"
"    \n"
"    Usunięcie pozycji ze stosu katalogów. Wywołane bez argumentów usuwa\n"
"    katalog z wierzchołka stosu i zmienia katalog bieżący na katalog\n"
"    będący nowym wierzchołkiem stosu.\n"
"    \n"
"    Opcje:\n"
"      -n\tPominięcie zmiany katalogu podczas usuwania katalogów ze stosu\n"
"    \t\ttak, że zmieniany jest tylko stos.\n"
"    \n"
"    Argumenty:\n"
"      +N\tUsunięcie ze stosu N-tej pozycji licząc od lewej strony listy\n"
"    \t\twypisywanej przez `dirs', począwszy od zera. Na przykład: `popd +0'\n"
"    \t\tusuwa pierwszy katalog, `popd +1' usuwa drugi.\n"
"    \n"
"      -N\tUsunięcie ze stosu N-tej pozycji licząc od prawej strony listy\n"
"    \t\twypisywanej przez `dirs', począwszy od zera. Na przykład: `popd -0'\n"
"    \t\tusuwa pierwszy katalog, `popd -1' usuwa drugi.\n"
"    \n"
"    Zawartość stosu katalogów można zobaczyć za pomocą polecenia `dirs'.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędny argument lub zmiana katalogu\n"
"    się nie powiedzie."

#: builtins.c:1886
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Wypisanie stosu katalogów.\n"
"    \n"
"    Wypisanie listy aktualnie pamiętanych katalogów. Katalogi umieszczane są\n"
"    na liście za pomocą polecenia `pushd'; można cofać się w obrębie listy\n"
"    za pomocą polecenia `popd'.\n"
"    \n"
"    Opcje:\n"
"      -c\twyczyszczenie stosu katalogów poprzez usunięcie wszystkich jego\n"
"    \t\telementów\n"
"      -l\tnieużywanie wersji skróconej wersji z tyldą przy wypisywaniu\n"
"    \t\tkatalogów względem katalogu domowego\n"
"      -p\twypisanie katalogów ze stosu w osobnych wierszach\n"
"      -v\twypisanie katalogów ze stosu w osobnych wierszach, poprzedzając\n"
"    \t\tkażdy jego pozycją na stosie\n"
"    \n"
"    Argumenty:\n"
"      +N\tWypisanie N-tej pozycji licząc od lewej strony listy wypisywanej\n"
"    \t\tprzez dirs wywołane bez opcji, począwszy od zera.\n"
"    \n"
"      -N\tWypisanie N-tej pozycji licząc od prawej strony listy wypisywanej\n"
"    \t\tprzez dirs wywołane bez opcji, począwszy od zera.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję lub wystąpi błąd."

#: builtins.c:1917
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Ustawianie i anulowanie opcji powłoki.\n"
"    \n"
"    Zmiana ustawienia każdej z NAZWY-OPCJI. Bez argumentów będących opcjami,\n"
"    wypisywane są wszystkie podane NAZWY-OPCJI, lub wszystkie opcje powłoki,\n"
"    jeśli nie podano NAZW-OPCJI, wraz z zaznaczeniem włączonych.\n"
"    \n"
"    Opcje:\n"
"      -o\tograniczenie NAZW-OPCJI do używanych z `set -o'\n"
"      -p\twypisanie opcji powłoki z określeniem stanu\n"
"      -q\tpominięcie wyjścia\n"
"      -s\twłączenie (ustawienie) każdej NAZWY-OPCJI\n"
"      -u\twyłączenie (anulowanie) każdej NAZWY-OPCJI\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda jeśli NAZWA-OPCJI jest włączona; niepowodzenie, jeśli\n"
"    podano błędną opcję lub NAZWA-OPCJI jest wyłączona."

#: builtins.c:1938
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output; character escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or assignment\n"
"    error occurs."
msgstr ""
"Formatowanie i wypisanie ARGUMENTÓW zgodnie z FORMATEM.\n"
"    \n"
"    Opcje:\n"
"      -v ZMIENNA\tprzypisanie wyjścia do podanej ZMIENNEJ powłoki zamiast\n"
"    \t\twypisywania na standardowym wyjściu\n"
"    \n"
"    FORMAT jest łańcuchem znakowym zawierającym trzy rodzaje obiektów:\n"
"    zwykłe znaki, które są kopiowane na standardowe wyjście; znaki sekwencji\n"
"    sterujących, które są przekształcane i kopiowane na standardowe wyjście;\n"
"    oraz sekwencje formatujące, z których każda powoduje wypisanie kolejnego\n"
"    argumentu.\n"
"    \n"
"    Poza standardowymi sekwencjami formatującymi opisanymi w printf(1) oraz\n"
"    printf(3), printf interpretuje:\n"
"    \n"
"      %b\trozwinięcie sekwencji z odwrotnym ukośnikiem w odpowiadającym\n"
"    \t\targumencie\n"
"      %q\tcytowanie argumentu w sposób umożliwiający użycie na wejściu\n"
"    \t\tpowłoki\n"
"      %Q\tjak %q, ale zastosowanie precyzji na wejściu przed cytowaniem\n"
"      %(fmt)T\twypisanie łańcucha daty-czasu otrzymanego z użycia FMT jako\n"
"    \t        łańcucha formatującego dla strftime(3)\n"
"    \n"
"    Format jest używany ponownie w razie potrzeby w celu pochłonięcia\n"
"    wszystkich argumentów. Jeśli argumentów jest mniej, niż wymaga format,\n"
"    nadmiarowe sekwencje zachowują się tak, jakby podano wartość zerową lub\n"
"    łańcuch pusty.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję lub zapis albo\n"
"    przypisanie zakończy się niepowodzeniem."

#: builtins.c:1974
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    are supplied, existing completion specifications are printed in a way that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Określenie sposobu dopełniania argumentów przez Readline.\n"
"    \n"
"    Określenie dla każdej NAZWY sposobu dopełniania argumentów. Jeśli nie\n"
"    podano opcji, wypisywane są istniejące specyfikacje dopełniania w sposób\n"
"    pozwalający na ich ponowne użycie jako wejście.\n"
"    \n"
"    Opcje:\n"
"      -p\twypisanie istniejących dopełnień w formacie do ponownego użycia\n"
"      -r\tusunięcie specyfikacji dopełniania dla każdej NAZWY lub, jeśli\n"
"    \t\tnie podano NAZW, wszystkich specyfikacji dopełniania\n"
"      -D\tstosowanie dopełniania i akcji domyślnie dla poleceń bez\n"
"    \t\tokreślonych żadnych konkretnych reguł dopełniania\n"
"      -E\tstosowanie dopełniania i akcji dla \"pustych\" poleceń -\n"
"    \t\tpróby dopełnienia w pustej linii\n"
"      -I\tstosowanie dopełniania i akcji do początkowego słowa (zwykle\n"
"    \t\tpolecenia)\n"
"    \n"
"    Przy próbie dopełnienia akcje są wykonywane w kolejności takiej, jak\n"
"    wielkie litery wymienione powyżej. Jeśli podano wiele opcji, opcja -D\n"
"    ma priorytet nad -E, a obie mają priorytet nad -I.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję lub wystąpi błąd."

#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Wypisanie możliwych uzupełnień w zależności od opcji.\n"
"    \n"
"    Przeznaczone do wykorzystania w funkcjach powłoki generujących możliwe\n"
"    uzupełnienia. Gdy podany jest opcjonalny argument SŁOWO, generowane są\n"
"    uzupełnienia pasujące do SŁOWA.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję lub wystąpi błąd."

#: builtins.c:2019
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, print\n"
"    the completion options for each NAME or the current completion specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Zmiana lub wyświetlenie opcji dopełniania.\n"
"    \n"
"    Zmiana opcji dopełniania dla każdej NAZWY lub, jeśli nie podano NAZW,\n"
"    aktualnie wykonywanego dopełniania. Jeśli nie podano OPCJI, wypisanie\n"
"    opcji dopełniania dla każdej NAZWY lub bieżącej specyfikacji dopełniania.\n"
"    \n"
"    Opcje:\n"
"    \t-o opcja\tUstawienie podanej OPCJI dopełniania dla każdej NAZWY\n"
"    \t-D\t\tZmiana opcji dla \"domyślnego\" dopełniania polecenia\n"
"    \t-E\t\tZmiana opcji dla dopełniania \"pustego\" polecenia\n"
"    \t-I\t\tZmiana opcji dla dopełniania dla początkowego słowa\n"
"    \n"
"    Użycie `+o' zamiast `-o' wyłącza podaną opcję.\n"
"    \n"
"    Argumenty:\n"
"    \n"
"    Każda NAZWA odnosi się do polecenia, dla którego specyfikacja dopełniania\n"
"    musi być wcześniej zdefiniowana przy użyciu polecenia wbudowanego\n"
"    `complete'. Jeśli nie podano NAZW, compopt musi być wywołane z funkcji\n"
"    aktualnie generującej dopełnienia, wtedy zmieniane są opcje dla aktualnie\n"
"    wykonywanego generatora dopełnień.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję lub NAZWA nie ma\n"
"    zdefiniowanej specyfikacji dopełniania."

#: builtins.c:2050
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly or\n"
"    not an indexed array."
msgstr ""
"Odczyt linii ze standardowego wejścia do zmiennej tablicowej indeksowanej.\n"
"    \n"
"    Odczyt linii ze standardowego wejścia (lub deskryptora FD, jeśli podano\n"
"    opcję -u) do zmiennej tablicowej indeksowanej TABLICA. Zmienna MAPFILE\n"
"    jest domyślną TABLICĄ.\n"
"    \n"
"    Opcje:\n"
"      -d ogr\tUżycie OGRanicznika do kończenia linii zamiast znaku nowej linii\n"
"      -n liczba\tSkopiowanie maksymalnie podanej LICZBY linii. Jeśli LICZBA\n"
"    \t\t\twynosi 0, kopiowane są wszystkie linie.\n"
"      -O początek\tRozpoczęcie wpisywania do TABLICY od indeksu POCZĄTKU.\n"
"    \t\t\tDomyślny indeks wynosi 0.\n"
"      -s liczba\tPominięcie pierwszych LICZBA odczytanych linii.\n"
"      -t\tUsunięcie końcowego znaku końca linii z każdej wczytanej linii.\n"
"      -u fd\tOdczyt linii z deskryptora FD zamiast standardowego wejścia.\n"
"      -C wywołanie\tObliczenie WYWOŁANIA po odczycie każdego CO-ILE linii.\n"
"      -c co-ile\tLiczba linii do wczytania między każdym WYWOŁANIEM.\n"
"    \n"
"    Argumenty:\n"
"      TABLICA\tNazwa zmiennej tablicowej do użycia na dane z pliku.\n"
"    \n"
"    Jeśli podano -C bez -c, domyślnym krokiem jest 5000. Podczas obliczania\n"
"    WYWOŁANIA jest przekazywany indeks do następnego elementu tablicy, który\n"
"    ma być przypisany oraz - jako kolejne argumenty - linia do przypisania.\n"
"    \n"
"    Jeśli nie podano jawnie początku, mapfile czyści TABLICĘ przed\n"
"    przypisywaniem.\n"
"    \n"
"    Stan wyjściowy:\n"
"    Zwracana jest prawda, chyba że podano błędną opcję lub TABLICA jest tylko\n"
"    do odczytu, lub nie jest tablicą indeksowaną."

#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Odczyt linii z pliku do zmiennej tablicowej.\n"
"    \n"
"    Synonim polecenia `mapfile'."
