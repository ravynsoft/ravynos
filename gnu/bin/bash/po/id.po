# Pesan Bahasa Indonesia untuk bash
# Copyright (C) 2008 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Arif E. Nugroho <arif_endro@yahoo.com>, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 5.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2021-09-17 19:30+0700\n"
"Last-Translator: Arif E. Nugroho <arif_endro@yahoo.com>\n"
"Language-Team: Indonesian <translation-team-id@lists.sourceforge.net>\n"
"Language: id\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "array subscript buruk"

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: menghapus atribut nameref"

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: tidak dapat mengubah index ke array yang berassosiasi"

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: tidak dapat mengassign ke index tidak-numeric"

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: harus menggunakan subscript ketika memberikan assosiasi array"

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: tidak dapat membuat: %s"

#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: tidak dapat menemukan keymap untuk perintah"

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: bukan karakter whitespace (spasi) pertama ditemukan `\"'"

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "tidak menutup '%c' dalam %s"

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: hilang pemisah colon"

#: bashline.c:4733
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "'%s': tidak dapat melepaskan dalam peta perintah"

#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "brace expansion: cannot allocate memory for %s"

#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "brace expansion: failed to allocate memory for %u elements"

#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "brace expansion: failed to allocate memory for `%s'"

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "`%s': nama alias tidak valid"

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "pengubahan baris tidak aktif"

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "'%s': nama keymap tidak valid"

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: tidak dapat membaca: %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "'%s': nama fungsi tidak dikenal"

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s tidak terikat ke kunci apapun.\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s dapat dipanggil melalui "

#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "'%s': tidak dapat melepaskan"

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "jumlah loop"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "hanya berarti dalam sebuah `for', `while', atau `until'loop"

#: builtins/caller.def:136
#, fuzzy
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Mengembalikan context dari panggilan subroutine saat ini.\n"
"    \n"
"    Tanpa EXPR, mengembalikan \"$line $filename\". Dengan EXPR,\n"
"    mengembalikan \"$line $subroutine $filename\"; informasi extra ini\n"
"    dapat digunakan untuk menyediakan jejak stack.\n"
"    \n"
"    Nilai dari EXPR mengindikasikan bagaimana banyak panggilan frames "
"kembali sebelum\n"
"    yang ada; Top frame adalah frame 0.    \n"
"    Status Keluar:\n"
"    Mengembalikan 0 kecuali shell sedang tidak menjalankan sebuah fungsi "
"shell atau EXPR\n"
"    tidak valid."

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "HOME tidak diset"

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "terlalu banyak argumen"

#: builtins/cd.def:342
msgid "null directory"
msgstr "null direktori"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "OLDPWD tidak diset"

#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "baris %d: "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "peringatan: "

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s: penggunaan: "

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: pilihan membutuhkan sebuah argumen"

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: argumen numeric dibutuhkan"

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s: tidak ditemukan"

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s: pilihan tidak valid"

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s: nama pilihan tidak valid"

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "`%s': bukan sebuah identifier yang valid"

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "nomor oktal tidak valid"

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "nomor hexa tidak valid"

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "nomor tidak valid"

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: spesifikasi sinyal tidak valid"

#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "`%s': bukan sebuah pid atau spesifikasi pekerjaan yang valid"

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s: variabel baca-saja"

#: builtins/common.c:273
#, fuzzy, c-format
msgid "%s: cannot assign"
msgstr "%s: tidak dapat unset"

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s diluar jangkauan"

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "argumen"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s diluar jangkauan"

#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s: tidak ada pekerjaan seperti itu"

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s: tidak ada pengontrol kerja"

#: builtins/common.c:301
msgid "no job control"
msgstr "tidak ada pengontrol kerja"

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s: terbatas"

#: builtins/common.c:313
msgid "restricted"
msgstr "terbatas"

#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: bukan sebuah builtin shell"

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "gagal menulis: %s"

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "error menentukan atribut terminal: %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "error mendapatkan atribut terminal: %s"

#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: error mengambil direktori saat ini: %s: %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: spesifikasi pekerjaan ambigu"

#: builtins/common.c:971
msgid "help not available in this version"
msgstr "bantuan tidak tersedia di versi ini"

#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: tidak dapat unset: baca-saja %s"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s: tidak dapat unset"

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s: nama aksi tidak valid"

#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s: tidak ada spesifikasi completion"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr ""
"peringatan: pilihan -F mungkin tidak bekerja seperti yang anda harapkan"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr ""
"peringatan: pilihan -C mungkin tidak bekerja seperti yang anda harapkan"

#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "saat ini sedang tidak menjalankan fungsi completion"

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "hanya dapat digunakan dalam sebuah fungsi"

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "tidak dapat menggunakan `-f' untuk membuat fungsi"

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s: fungsi baca-saja"

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: reference variable cannot be an array"

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: nameref variable self references not allowed"

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr "%s: circular name reference"

#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "`%s': nilai dari berkas pendeskripsi penelusur tidak valid"

#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: tidak dapat menghapus variabel array secara ini"

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: tidak dapat mengubah assosiasi ke array index"

#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: quoted compound array assignment ditinggalkan"

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "dynamic loading tidak tersedia"

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "tidak dapat membuka object shared %s: %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "tidak dapat menemukan %s dalam shared object %s: %s"

#: builtins/enable.def:422
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: dynamic builtin telah dimuat"

#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "muat fungsi untuk %s mengembalikan kegagalan (%d): tidak dimuat"

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: bukan dinamically loaded"

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: tidak dapat menghapus: %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s: bukan sebuah direktori"

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s: bukan sebuah file umum"

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s: file terlalu besar"

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: tidak dapat menjalankan berkas binary"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: tidak dapat menjalankan: %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "logout\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "bukan sebuah login shell: gunakan `exit'"

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Ada pekerjaan yang terhenti.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Ada pekerjaan yang sedang berjalan.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "perintah tidak ditemukan"

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr "spesifikasi sejarah"

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: tidak dapat membuka file sementara: %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "sekarang"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "pekerjaan %d dimulai tanpa pengontrol pekerjaan"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: pilihan tidak legal -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: pilihan membutuhkan sebuah argumen -- %c\n"

#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "hashing dinonaktifkan"

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: tabel hash kosong\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "tekan\tperintah\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Perintah shell cocok dengan kata kunci `"
msgstr[1] "Perintah shell cocok dengan kata kunci `"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"tidak ada topik bantuan yang cocok dengan `%s'. Coba `help help' atau 'man -"
"k %s' atau `info %s'."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: tidak dapat membuka: %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Perintah shell ini didefinisikan secara internal. Ketik `help' untuk melihat "
"daftar ini.\n"
"Ketik `help nama' untuk informasi lebih lanjut mengenai fungsi `nama'.\n"
"Gunakan `info bash' untuk informasi lebih lanjut mengenasi shell secara "
"umum.\n"
"Gunakan `man -k' atau `info' untuk informasi lebih lanjut mengenai perintah "
"yang tidak ada dalam daftar ini.\n"
"\n"
"Sebuah asterisk (*) disebelah dari nama berarti perintah tersebut tidak "
"aktif.\n"
"\n"

#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "tidak dapat menggunakan lebih dari satu pilihan dari -anrw"

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "posisi sejarah"

#: builtins/history.def:338
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: penanda waktu tidak valid"

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: expansi sejarah gagal"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: inlib gagal"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "tidak ada pilihan lain yang diperbolehkan dengan `-x'"

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: argumen harus diproses atau ID pekerjaan"

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Kesalahan tidak diketahui"

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "diduga sebuah ekspresi"

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: bukan sebuah indeks array"

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: spesifikasi file deskripsi tidak valid"

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: file deskriptor %s tidak valid"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s: jumlah baris tidak valid"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: asal array tidak valid"

#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: nama aksi tidak valid"

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "nama variabel array kosong"

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr "bantuan array variabel dibutuhkan"

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "`%s': hilang karakter format"

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "`%c': spesifikasi timeout tidak valid"

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "`%c': karakter format tidak valid"

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "peringatan: %s: %s"

#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr "format parsing problem: %s"

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "hilang digit hexa untuk \\x"

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "hilang digit hexa untuk \\%c"

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "tidak ada direktori lain"

#: builtins/pushd.def:360
#, c-format
msgid "%s: invalid argument"
msgstr "%s: argumen limit tidak valid"

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "<direktori saat ini>"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "direktori stack kosong"

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "index direktori stack"

#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Menampilkan daftar dari direktori yang diingat saat ini. Direktori\n"
"    menemukan jalannya kedalam daftar dengan perintah `pushd'; anda dapat "
"memperoleh\n"
"    backup melalui daftar dengan perintah `popd'.\n"
"    \n"
"    Pilihan:\n"
"      -c\tmenghapus direktori stact dengan menghapus seluruh elemen\n"
"      -l\tjangan menampilkan versi dengan tilde dari direktori relative\n"
"    \tke direkori rumah anda\n"
"      -p\tmenampilkan direktori stack dengan satu masukan per baris\n"
"      -v\tmenampilkan direktori stack dengan satu masukan per baris diawali\n"
"    \tdengan posisnya dalam stack\n"
"    \n"
"    Argumen:\n"
"      +N\tMenampilkan masukan ke N dihitung dari kiri dari daftar yang "
"ditampilkan oleh\n"
"    \tdirs ketika dipanggil tanpa pilihan, dimulai dari nol.\n"
"    \n"
"      -N\tMenampilkan masukan ke N dihitung dari kanan dari daftar yang "
"ditampilkan oleh\n"
"    \tdirs ketika dipanggil tanpa pilihan, dimulai dari nol."

#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Menambahkan sebuah direktori ke top dari direktori stack, atau merotasi\n"
"    stack, membuah top baru dari stack dari working direktori saat ini.\n"
"    Tanpa argumen, menukar top dari dua direktori.\n"
"    \n"
"    Pilihan:\n"
"    -n\tmenekan perubahan normal dari direktori ketika menambahkan "
"direktori\n"
"    \tke stack, jadi hanya stack yang dimanipulasi.\n"
"    \n"
"    Argumen:\n"
"    +N\tMerotasi stack sehingga direktori ke N (dihitung\n"
"    \tdari kiri dari daftar yang terlihat oleh `dirs', dimulai dengan\n"
"    \tnol) adalah di top.\n"
"    \n"
"    -N\tMerotasi stack sehingga direktori ke N (dihitung\n"
"    \tdari kanan dari daftar yang terliha oleh `dirs', dimulai dengan\n"
"    \tnol) adalah di top.\n"
"    \n"
"    dir\tenambahkan DIR ke direktori stack di puncak, membuatnya\n"
"    \tcurrent working directory.\n"
"    \n"
"    Builtin `dirs' menampilkan direktori stack."

#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Manghapus masukan dalam direktori stack. Tanpa argumen,\n"
"    menghapus top direktori dari stack, dan cd's ke top\n"
"    direktori baru.\n"
"    \n"
"    Pilihan:\n"
"    -n\tmenekan perubahan normal dari direktori ketika menghapus direktori\n"
"    \tdari stack, jadi hanya stack yang dimanipulasi.\n"
"    \n"
"    Argumen:\n"
"    -N\tmenghapus masukan ke N dihitung dari kiri dari daftar\n"
"    \tyang ditampilkan oleh `dirs', dimulai dari nol. Sebagai contoh: `popd "
"+0'\n"
"    \tmenghapus direktori terakhir, `popd -1' sebelum terakhir.\n"
"    \n"
"    Builtin `dirs' menampilkan direktori stack."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: spesifikasi timeout tidak valid"

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "error baca: %d: %s"

#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr "hanya dapat `return' dari sebuah fungsi atau script yang disource"

#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr "tidak dapat secara simultan unset sebuah fungsi dan sebuah variable"

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s: bukan sebuah variabel array"

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s: bukan sebuah fungsi"

#: builtins/setattr.def:194
#, c-format
msgid "%s: cannot export"
msgstr "%s: tidak dapat export"

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "shift terhitung"

#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "tidak dapat menset dan menunset pilihan shell secara bersamaan"

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: nama pilihan shell tidak valid"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "argumen nama file dibutuhkan"

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s: berkas tidak ditemukan"

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "tidak dapat suspend"

#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "tidak dapat suspend sebuah login shell"

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s sudah dialiasi ke `%s'\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s adalah sebuah shell dengan kata kunci\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s adalah sebuah fungsi\n"

#: builtins/type.def:299
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s adalah sebuah shell builtin spesial\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s adalah sebuah shell builtin\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "%s adalah %s\n"

#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s memiliki hash (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: argumen limit tidak valid"

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "`%c': perintah buruk"

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: tidak dapat get limit: %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "batas"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: tidak dapat memodifikasi batas: %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "nomor oktal"

#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "`%c': operator mode symbolic tidak valid"

#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "`%c': mode karakter symbolic tidak valid"

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " baris "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "perintah terakhir: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "membatalkan..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr "BERI TAHU: "

#: error.c:310
#, fuzzy, c-format
msgid "DEBUG warning: "
msgstr "peringatan: "

#: error.c:488
msgid "unknown command error"
msgstr "perintah error tidak diketahui"

#: error.c:489
msgid "bad command type"
msgstr "tipe perintah buruk"

#: error.c:490
msgid "bad connector"
msgstr "konektor buruk"

#: error.c:491
msgid "bad jump"
msgstr "lompat buruk"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s: variabel tidak terikat"

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "kehabisan waktu menunggu masukan: otomatis-keluar\n"

#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "tidak dapat menyalurkan masukan standar dari /dev/null: %s"

#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: `%c': karakter format tidak valid"

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: coproc [%d:%s] masih ada"

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "pipe error"

#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: maximum eval nesting level exceeded (%d)"

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: maximum source nesting level exceeded (%d)"

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: maximum function nesting level exceeded (%d)"

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr ""
"%s: dibatasi: tidak dapat menspesifikasikan '/' dalam nama nama perintah"

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s: perintah tidak ditemukan"

#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5975
#, fuzzy, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: tidak dapat menjalankan berkas binary"

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: interpreter buruk"

#: execute_cmd.c:6037
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: tidak dapat menjalankan berkas binary: %s"

#: execute_cmd.c:6123
#, c-format
msgid "`%s': is a special builtin"
msgstr "`%s': adalah sebuah shell builtin"

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "tidak dapat menduplikasikan fd %d ke fd %d"

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "expresi level rekursi terlewati"

#: expr.c:291
msgid "recursion stack underflow"
msgstr "rekursi stack underflow"

#: expr.c:478
msgid "syntax error in expression"
msgstr "syntax error dalam expresi"

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "mencoba menempatkan ke bukan sebuah variabel"

#: expr.c:531
msgid "syntax error in variable assignment"
msgstr "syntax error dalam menempatkan variabel"

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "dibagi oleh 0"

#: expr.c:593
msgid "bug: bad expassign token"
msgstr "bug: tanda expassign buruk"

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "`:' diharapkan untuk sebuah pernyataan kondisional"

#: expr.c:973
msgid "exponent less than 0"
msgstr "eksponen kurang dari 0"

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "idenfier diharapkan setelah pre-increment atau pre-decrement"

#: expr.c:1057
msgid "missing `)'"
msgstr "hilang `)'"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "syntax error: operand diharapkan"

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "syntax error: operator arithmetic tidak valid"

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (error token adalah \"%s\")"

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "basis arithmetic tidak valid"

#: expr.c:1587
msgid "invalid integer constant"
msgstr "konstanta bulat tidak valid"

#: expr.c:1603
msgid "value too great for base"
msgstr "nilai terlalu besar untuk basis"

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s: expresi error\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: tidak dapat mengakses direktori orang tua"

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "tidak dapat mereset mode nodelay untuk fd %d"

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr ""
"tidak dapat mengalokasikan berkas deskripsi bari untuk masukan bash dari fd "
"%d"

#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "simpan bash_input: buffer telah ada untuk fd %d baru"

#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp pipe"

#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "forked pid %d terlihat dalam pekerjaan yang sedang berjalan %d"

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "menghapus pekerjaan yang terhenti %d dengan proses grup %ld"

#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) ditandai dengan tetap hidup"

#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: tidak ada pid seperti itu"

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "sinyal %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Selesai"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Terhenti"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Terhenti(%s)"

#: jobs.c:1881
msgid "Running"
msgstr "Berjalan"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Selesai(%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Keluar %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "Status tidak diketahui"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(core didump) "

#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (wd: %s)"

#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "anak setpgid (%ld ke %ld)"

#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: pid %ld bukan sebuah anak dari shell ini"

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: Tidak ada catatan untuk proses %ld"

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: pekerjaan %d terhenti"

#: jobs.c:3551
#, c-format
msgid "%s: no current jobs"
msgstr "%s: tidak ada pekerjaan sekarang"

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s: pekerjaan telah selesai"

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: pekerjaan %d sudah berjalan di belakang (background)"

#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: mengaktifkan WNOHANG untuk menghindari blok tak terhingga"

#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s: baris %d: "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr " (core didump)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(wd sekarang: %s)\n"

#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp gagal"

#: jobs.c:4434
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: tidak ada kontrol pekerjaan di belakang"

#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: baris disiplin"

#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "tidak dapat menset terminal proses grup (%d)"

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "tidak ada pengontrol pekerjaan dalam shell ini"

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: gagal assertion: %s\n"

#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: assertion rusak\r\n"

#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "tidak diketahui"

#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "malloc: blok dalam daftar bebas clobbered"

#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "free: dipanggil dengan argumen blok yang sudah dibebaskan"

#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "free: dipanggil dengan argumen blok yang tidak dialokasikan"

#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: underflow terdeteksi; mh_nbytes diluar dari jangkauan"

#: lib/malloc/malloc.c:1007
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: underflow terdeteksi; magic8 terkorupsi"

#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "free: awal dan akhir dari ukuran potongan berbeda"

#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "realloc: dipanggil dengan argumen blok yang tidak teralokasikan"

#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: underflow terdeteksi; my_nbytes diluar dari jangkauan"

#: lib/malloc/malloc.c:1197
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: underflow terdeteksi; magic8 terkorupsi"

#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: awal dan akhir dari ukuran potongan berbeda"

#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: tabel alokasi penuh dengan FIND_ALLOC?\n"

#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr ""
"register_alloc: %p sudah berada dalam tabel sepertinya sudah dialokasikan?\n"

#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p sudah berada dalam tabel sebagai bebas?\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "basis tidak valid"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: host tidak diketahui"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: layanan tidak valid"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: spesifikasi jalur network buruk"

#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "operasi jaringan tidak dilayani"

#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: tidak dapat mengubah lokal (%s)"

#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: tidak dapat mengubah local (%s): %s"

#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: tidak dapat mengubah lokal (%s)"

#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: tidak dapat mengubah lokal (%s): %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Anda memiliki surat dalam $_"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Anda memiliki surat baru dalam $_"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Surat dalam %s telah dibaca\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "syntax error: membutuhkan ekspresi arithmetic"

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "syntax error: `;' tidak terduga"

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "syntax error: `((%s))'"

#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: tipe instruksi buruk %d"

#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr ""
"dokumen-disini di baris %d dibatasi oleh akhir-dari-berkas (diinginkan `%s')"

#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: instruksi redireksi `%d' diluar dari jangkauan"

#: parse.y:2428
#, c-format
msgid ""
"shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line "
"truncated"
msgstr ""
"shell_getc: shell_input_line_size (%zu) terlampaui SIZE_MAX (%lu): baris "
"terpotong"

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr "jumlah maksimal dokumen disini tercapai"

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "EOF tidak terduga ketika mencari untuk pencocokan `%c'"

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "EOF tidak terduga ketika mencari untuk `]]'"

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "syntax error dalam ekspresi kondisional: tanda `%s' tidak terduga"

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "syntax error dalam ekspresi kondisional"

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "tanda `%s' tidak terduga, diduga `)'"

#: parse.y:4543
msgid "expected `)'"
msgstr "diduga `)'"

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "argumen tidak terduga `%s' ke operator kondisional unary"

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr "argumen tidak terduga untuk operasi unary kondisional"

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "tanda `%s' tidak terduga, operator binary kondisional diduga"

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr "operator binary kondisional diduga"

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "argumen `%s' tidak terduga ke operator binary kondisional"

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr "argumen tidak terduga ke operasi binary kondisional"

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "tanda `%c' tidak terduga dalam perintah kondisional"

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "tanda `%s' tidak terduga dalam perintah kondisional"

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "tanda %d tidak terduga dalam perintah kondisional"

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "syntax error didekat tanda `%s' yang tidak terduga"

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "syntax error didekat `%s'"

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "syntax error: tidak terduga diakhir dari berkas"

#: parse.y:6151
msgid "syntax error"
msgstr "syntax error"

#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Gunakan \"%s\" untuk meninggalkan shell.\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "EOF tidak terduga ketika mencari untuk pencocokan ')'"

#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: fungsi `%s' tidak ditemukan"

#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: kemungkinan retry loop"

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULL COMPSPEC"

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: konektor buruk `%d'"

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: berkas pendeskripsi tidak valid"

#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: berkas penunjuk KOSONG"

#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != fileno xtrace fp (%d)"

#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: '%c': format karakter tidak valid"

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "berkas deskripsi diluar dari jangkauan"

#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: redirect ambigu"

#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: tidak dapat menulis berkas yang sudah ada"

#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: restricted: tidak dapat meredirect keluaran"

#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "tidak dapat membuat berkas sementara untuk dokumen disini: %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: tidak dapat meng-'assign' fd ke variabel"

#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port tidak dilayani tanpa jaringan"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "redirection error: tidak dapat menduplikasi fd"

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "tidak dapat menemukan /tmp, tolong buat!"

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "/tmp harus berupa sebuah nama direktori yang valid"

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr "mode pretty-printing diabaikan dalam shells interactive"

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: pilihan tidak valid"

#: shell.c:1343
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "tidak dapat menset uid ke %d: uid efektif %d"

#: shell.c:1354
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "tidak dapat menset gid ke %d: gid efektif %d"

#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr "tidak dapat menjalankan debugger; mode debugging tidak aktif"

#: shell.c:1658
#, c-format
msgid "%s: Is a directory"
msgstr "%s: Direktori"

#: shell.c:1907
msgid "I have no name!"
msgstr "Aku tidak memiliki nama!"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, versi %s-(%s)\n"

#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Penggunaan:\t%s [GNU pilihan panjang] [pilihan] ...\n"
"\t%s [GNU pilihan panjang] [pilihan] berkas-script ...\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "GNU pilihan panjang:\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Pilihan shell:\n"

#: shell.c:2069
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr ""
"\t-ilrsD atau -c perintah atau -O shopt_option\t\t(hanya pemanggilan)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s atau pilihan -o\n"

#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr ""
"Ketik `%s -c \"help set\"' untuk informasi lebih lanjut mengenai pilihan "
"shell.\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Ketik `%s -c help' untuk informasi lebih lanjut mengenai perintah builting "
"shell.\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Gunakan perintah 'bashbug' untuk melaporkan bugs.\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "bash halaman rumah: <http://www.gnu.org/software/bash>\n"

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr ""
"Bantuan umum menggunakan aplikasi GNU: <http:///www.gnu.org/gethelp/>\n"

#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: operasi tidak valid"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Sinyal palsu"

#: siglist.c:51
msgid "Hangup"
msgstr "Hangup"

#: siglist.c:55
msgid "Interrupt"
msgstr "Interupsi"

#: siglist.c:59
msgid "Quit"
msgstr "Berhenti"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Instruksi ilegal"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "BPT trace/trap"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Instruksi ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Instruksi EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Floating point exception"

#: siglist.c:87
msgid "Killed"
msgstr "Dibunuh"

#: siglist.c:91
msgid "Bus error"
msgstr "Bus error"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Kesalahan segmentasi"

#: siglist.c:99
msgid "Bad system call"
msgstr "Pemanggilan sistem buruk"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Pipe rusak"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Alarm clock"

#: siglist.c:111
msgid "Terminated"
msgstr "Selesai"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Kodisi IO penting"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Terhenti (sinyal)"

#: siglist.c:127
msgid "Continue"
msgstr "Melanjutkan"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Anak tewas atau berhenti"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Terhenti (tty input)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Terhenti (tty output)"

#: siglist.c:147
msgid "I/O ready"
msgstr "I/O siap"

#: siglist.c:151
msgid "CPU limit"
msgstr "Batas CPU"

#: siglist.c:155
msgid "File limit"
msgstr "Batas berkas"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Alarm (virtual)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Alarm (profile)"

#: siglist.c:167
msgid "Window changed"
msgstr "Window berubah"

#: siglist.c:171
msgid "Record lock"
msgstr "Catatan terkunci"

#: siglist.c:175
msgid "User signal 1"
msgstr "Sinyal pengguna 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Sinyal pengguna 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "HFT masukan data tertunda"

#: siglist.c:187
msgid "power failure imminent"
msgstr "Kelihatannya akan terjadi kegagalan power suply"

#: siglist.c:191
msgid "system crash imminent"
msgstr "Kelihatannya akan terjadi kerusakan sistem"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "pindahkan proses ke CPU lain"

#: siglist.c:199
msgid "programming error"
msgstr "error dalam pemrograman"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "HFT mode monitoring diberikan"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "HFT mode monitoring ditarik"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "HFTP sound sequence telah selesai"

#: siglist.c:215
msgid "Information request"
msgstr "Permintaan informasi"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Sinyal tidak diketahui #%d"

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "substitusi buruk: tidak ada penutupan `%s' dalam %s"

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: tidak dapat meng-assign daftar kedalam anggoya array"

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "tidak dapat membuat pipe untuk proses substitusi"

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "tidak dapat membuat anak untuk proses substitusi"

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "tidak dapat membuka named pipe %s untuk membaca"

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "tidak dapat membukan named pipe %s untuk menulis"

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "tidak dapat menduplikasi nama pipe %s sebagai fd %d"

#: subst.c:6370
msgid "command substitution: ignored null byte in input"
msgstr "substitusi perintah: mengabaikan byte kosong dalam masukan"

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "tidak dapat membuat pipe untuk perintah substitusi"

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "tidak dapat membuat anak untuk perintah substitusi"

#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: tidak dapat menduplikasikan pipe sebagi fd 1"

#: subst.c:7082 subst.c:10252
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: nilai dari berkas pendeskripsi penelusur tidak valid"

#: subst.c:7178 subst.c:7196 subst.c:7369
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: ekspansi tidak langsung tidak valid"

#: subst.c:7212 subst.c:7377
#, c-format
msgid "%s: invalid variable name"
msgstr "`%s': nama variabel tidak valid"

#: subst.c:7478
#, c-format
msgid "%s: parameter not set"
msgstr "%s: parameter tidak diset"

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parameter kosong atau tidak diset"

#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: substring expresi < 0"

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s: substitusi buruk"

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: tidak dapat meng-assign dengan cara ini"

#: subst.c:10111
msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr ""
"versi selanjutnya dari shell akan memaksa evaluasi dari sebuah penggantian "
"aritmetika"

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "substitusi buruk: tidak ada penutupan \"\" dalam %s"

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "tidak cocok: %s"

#: test.c:147
msgid "argument expected"
msgstr "argumen diharapkan"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: expresi integer diduga"

#: test.c:265
msgid "`)' expected"
msgstr "')' diduga"

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "`)' diduga, ditemukan %s"

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: operator binary diduga"

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: operator unary diduga"

#: test.c:896
msgid "missing `]'"
msgstr "hilang `]'"

#: test.c:914
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "syntax error: `%s' tidak terduga"

#: trap.c:220
msgid "invalid signal number"
msgstr "nomor sinyal tidak valid"

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "trap handler: maximum trap handler level exceeded (%d)"

#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: nilai buruk dalam trap_list[%d]: %p"

#: trap.c:416
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""
"run_pending_traps: sinyal handler adalah SIG_DFL, mengirimkan kembali %d "
"(%s) kediri sendiri"

#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: sinyal buruk %d"

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "error mengimpor definisi fungsi untuk `%s'"

#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "level shell (%d) terlalu tinggi, mereset ke 1"

#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: tidak ada context fungsi di scope ini"

#: variables.c:2661
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: tidak dapat meng-'assign' fd ke variabel"

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr ""

#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: memberikan integer ke berkas pendeskripsi penelusur"

#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: tidak ada context fungsi dalam scope ini"

#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "%s memiliki exportstr kosong"

#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "karakter %d tidak valid dalam exporstr untuk %s"

#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "bukan `=' dalam exportstr untuk %s"

#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""
"pop_var_context: kepala dari shell_variables bukan sebuah fungsi cbntext"

#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: bukan global_variable context"

#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr ""
"pop_scope: kepala dari shell_variables bukan sebuah scope lingkungan "
"sementara"

#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: tidak dapat membuka sebagai BERKAS"

#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: nilai dari berkas pendeskripsi penelusur tidak valid"

#: variables.c:6450
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: diluar jangkauan"

#: version.c:46 version2.c:46
#, fuzzy
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "Hak Cipta (C) 2020 Free Software Foundation, Inc."

#: version.c:47 version2.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"Lisensi GPLv3+: GNU GPL versi 3 atau sesudahnya <http://gnu.org/licenses/gpl."
"html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, versi %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr ""
"Ini adalah perangkat lunak bebas; anda bebas untuk mengubah dan "
"mendistribusikannya."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "TIDAK ADA GARANSI, selama masih diijinkan oleh hukum yang berlaku."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: tidak dapat mengalokasikan %lu bytes (%lu bytes teralokasi)"

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: tidak dapat mengalokasikan %lu bytes"

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: tidak dapat mengalokasikan %lu bytes (%lu bytes teralokasi)"

#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s: %d: tidak dapat teralokasi %lu bytes"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [name[=nilai] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] name [nama ...]"

#: builtins.c:53
msgid ""
"bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpvsPVSX] [-m keymap] [-f nama berkas] [-q nama] [-u nama] [-r "
"keyseq] [-x keyseq:perintah-shell] [keyseq:readline-function atau readline-"
"command]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [shell-builtin [arg ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "pemanggil [expr]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [direktori]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "perintah [-pVv] perintah [argumen ...]"

#: builtins.c:78
#, fuzzy
msgid ""
"declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] "
"[name ...]"
msgstr "declare [-aAfFgiIlnrtux] [-p] [name[=nilai] ...]"

#: builtins.c:80
#, fuzzy
msgid ""
"typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] "
"[name ...]"
msgstr "typeset [-aAfFgiIlnrtux] [-p] name[=nilai] ..."

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [pilihan] name[=nilai] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [arg ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [arg ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f nama berkas] [name ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [argumen ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts nama optstring [arg ...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a nama] [perintah [argumen ...]] [redireksi ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr ""
"fc [-e ename] [-lnr] [pertama] [terakhir] atau fc -s [pat=rep] [perintah]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [spesifikasi pekerjaan]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [spesifikasi pekerjaan ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p nama jalur] [-dt] [nama ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "bantuan [-dms] [pola ...]"

#: builtins.c:123
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"sejarah [-c] [-d ofset] [n] atau history -anrw [nama berkas] atau history -"
"ps arg [arg...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [spesifikasi pekerjaan ...] atau jobs -x perintah [args]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [spesifikasi pekerjaan ... | pid ...]"

#: builtins.c:134
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s spesifikasi sinyal | -n nomor sinyal | -sigspec] pid | jobsepc ... "
"atau kill -l [sigspec]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "biarkan arg [argumen ...]"

#: builtins.c:138
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a array] [-d pembatas] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
#, fuzzy
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCHP] [-o nama-pilihan] [--] [argumen ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [name ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [name[=nilai] ...] atau export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [name[=nilai] ...] atau readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source nama berkas [argumen]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". nama berkas [argumen]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [expr]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ arg... ]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[arg] spesifikasi sinyal ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] nama [name ...]"

#: builtins.c:171
#, fuzzy
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPT] [batas]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [mode]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p var] [id ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [pid ...]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NAMA [in WORDS ...] ; do PERINTAH; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( exp1; exp2; exp3 )); do PERINTAH; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NAMA [ in WORDS ... ;] do PERINTAH; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] pipeline"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case WORD in [POLA [| POLA]...) PERINTAH ;;]... esac"

#: builtins.c:194
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if PERINTAH; then PERINTAH; [ elif PERINTAH; then PERINTAH; ]... [ else "
"PERINTAH; ] fi"

#: builtins.c:196
#, fuzzy
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while PERINTAH; do PERINTAH; done"

#: builtins.c:198
#, fuzzy
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until PERINTAH; do PERINTAH; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NAMA] perintah [redireksi]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function name { PERINTAH; } atau name () { PERINTAH ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ PERINTAH ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "job_spec [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( expressi ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ expressi ]]"

#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr "variabel - Nama dan arti dari beberapa shell variabel"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | dir]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [optname ...]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] format [argumen]"

#: builtins.c:231
msgid ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-"
"W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o pilihan] [-A action] [-G globpat] "
"[-W daftar kata] [-F fungsi] [-C perintah] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"

#: builtins.c:235
msgid ""
"compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-"
"F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o pilihan] [-A aksi] [-G globpat] [-W wordlist] [-"
"F fungsi] [-C perintah] [-X filterpat] [-P prefix] [-S suffix] [word]"

#: builtins.c:239
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o pilihan] [-DEI] [nama ...]"

#: builtins.c:242
msgid ""
"mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"mapfile [-d pembatas] [-n jumlah] [-O asal] [-s jumlah] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"

#: builtins.c:244
msgid ""
"readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"readarray [-d pembatas] [-n jumlah] [-O asal] [-s jumlah] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"

#: builtins.c:256
#, fuzzy
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"Definisikan atau tampilkan aliases.\n"
"    \n"
"    `alias' dengan tanpa argumen atau dengan pilihan -p menampilkan daftar\n"
"    dari aliases dalam bentuk alias NAMA=NILAI di keluaran standar.\n"
"    \n"
"    Jika tidak, sebuah alias didefinisikan untuk setiap NAMA yang NILAI-nya "
"diberikan.\n"
"    sebuah tambahan spasi dalam NILAI menyebabkan kata selanjutnyan untuk "
"diperikasi untuk\n"
"    pengganti alias ketika alias diexpand.\n"
"    \n"
"    Pilihan:\n"
"      -p\tTampilkan seluruh alias yang terdefinisi dalam format yang "
"berguna\n"
"    \n"
"    Status Keluar:\n"
"    alias mengembalikan true sampai sebuah NAMA diberikan yang mana belum "
"ada alias yang\n"
"    terdefinisi."

#: builtins.c:278
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Hapus setiap NAMA dari daftar yang mendefinisikan aliases.\n"
"    \n"
"    Pilihan:\n"
"      -a\thapus semua definisi alias\n"
"    \n"
"    Mengembalikan sukses kecuali sebuah NAMA bukan alias yang sudah ada."

#: builtins.c:291
#, fuzzy
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated "
"commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Set Readline kunci pengikat dan variabel.\n"
"    \n"
"    Ikat sebuah urutan kunci ke fungsi readline atau sebuah macro, atau set\n"
"    sebuah variabel readline. Argumen bukan-pilihan syntax yang equivalent\n"
"    yang ditemukan dalam ~/.inputrc, tetapi harus dilewatkan sebagai sebuah "
"argumen tunggal:\n"
"    yang terikat '\"\\C-x\\C-r\": membaca kembali berkas inisialisasi.\n"
"    \n"
"    Pilihan:\n"
"        -m keymap        Gunakan `keymap' sebagai keymap untuk durasi dari "
"perintah\n"
"                         ini. Nama keymap yang diterima adalah emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, dan vi-insert.\n"
"        -l               Daftar dari nama fungsi.\n"
"        -p               Daftar dari nama fungsi dan bindings.\n"
"        -p               Daftar dari fungsi dan bindings dalam bentuk yang "
"dapat digunakan sebagai\n"
"                         masukan.\n"
"        -S               Daftar urutan kunci yang memanggil macros "
"dannilainya\n"
"        -s               Daftar urutan kunci yang memanggil macros "
"dannilainya\n"
"                         dalam sebuah bentuk yang dapat digunakan sebagai "
"sebuah masukan.        -V               Daftar nama variabel dan nilai\n"
"        -v               Daftar nama variabel dan nilai dalam bentuk yang "
"dapat digunakan\n"
"                         sebagai masukan.\n"
"        -q nama-fungsi   Minta tentang kunci mana yang dipanggil oleh fungsi "
"yang disebut.\n"
"        -u nama-fungsi   Unbind semua kunci yang terikat dengan nama-"
"fungsi.\n"
"        -r keyseq        Hapus binding untuk KEYSEQ.\n"
"        -f namafile      Baca kunci bindings dari NAMAFILE.\n"
"        -x keyseq:shell-command\tMenyebabkan SHELL-COMMAND untuk dijalankan "
"ketika\n"
"      \t\t\t\tKEYSEQ dimasuki.\n"
"      \n"
"      Status Keluar:\n"
"      bind memberikan kembalian 0 kecuali sebuah pilihan tidak dikenal "
"diberikan atau sebuah error terjadi."

#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Keluar dari for, while, atau until loops.\n"
"    \n"
"    Keluar untuk FOR, WHILE atau UNTIL loop. Jika N dispesifikasikan, keluar "
"N yang melingkupi\n"
"    loops.\n"
"    \n"
"    Status Keluar:\n"
"    Status keluar adalah 0 kecuali N tidak lebih besar atau sama dengan 1."

#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Melanjutkan for, while, atau until loops.\n"
"    \n"
"    Melanjutkan ke iterasi selanjutnya dari loop yang dilingkupi oleh FOR, "
"WHILE, atau UNTIL.\n"
"    Jika N dispesifikasikan, melanjutkan di posisi ke N dari loop yang "
"dilingkupi.    \n"
"    Status Keluar:\n"
"    Status keluar adalah 0 kecuali N tidak lebih besar atau sama dengan 1."

#: builtins.c:354
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Menjalankan shell builtins.\n"
"    \n"
"    Menjalankan SHELL-BUILTIN dengan argumen ARGs tanpa menjalankan "
"pencarian\n"
"    perintah. Ini berguna ketika anda menginginkan untuk mengimplementasikan "
"sebuah shell builtin\n"
"    sebagai sebuah fungsi shell, tetapi butuh untuk menjalankan builtin "
"dalah fungsi.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status keluar dari SHELL-BUILTIN, atau salah jika SHELL-"
"BUILTIN adalah\n"
"    bukan sebuah shell builtin."

#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Mengembalikan context dari panggilan subroutine saat ini.\n"
"    \n"
"    Tanpa EXPR, mengembalikan \"$line $filename\". Dengan EXPR,\n"
"    mengembalikan \"$line $subroutine $filename\"; informasi extra ini\n"
"    dapat digunakan untuk menyediakan jejak stack.\n"
"    \n"
"    Nilai dari EXPR mengindikasikan bagaimana banyak panggilan frames "
"kembali sebelum\n"
"    yang ada; Top frame adalah frame 0.    \n"
"    Status Keluar:\n"
"    Mengembalikan 0 kecuali shell sedang tidak menjalankan sebuah fungsi "
"shell atau EXPR\n"
"    tidak valid."

#: builtins.c:387
#, fuzzy
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname "
"component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully "
"when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Pindah direktori kerja shell.\n"
"    \n"
"    Pindah direktori saat ini ke DIR. Variabel $HOME adalah\n"
"    default DIR.\n"
"    \n"
"    Variabel CDPATH mendefinisikan jalur pencarian untuk\n"
"    direktori yang berisi DIR. Alternatif nama direktori dalam CDPATH\n"
"    dipisahkan oleh sebuah colon (:). Sebuah nama direktori kosong adalah "
"sama dengan\n"
"    direktori saat ini. i.e. `.'. Jika DIR dimulai dengan sebuah slash (/),\n"
"    maka CDPATH tidak digunakan.\n"
"    \n"
"    Jika direktori tidak ditemukan, dan\n"
"    pilihan shell cdable_vars' diset, maka coba kata sebagai sebuah nama\n"
"    variabel. Jika variabel itu memiliki sebuah nilai, maka  nilai dari "
"variabel itu yang digunakan\n"
"    \n"
"    Pilihan:\n"
"      -L\tmemaksa link simbolik untuk diikuti\n"
"      -P\tgunakan struktur physical direktori tanpa mengikuti link\n"
"    symbolik\n"
"    \n"
"    Default adalah mengikuti link simbolik, seperti dalam `-L' "
"dispesifikasikan.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan 0 jika direktori berubah; bukan nol jika tidak."

#: builtins.c:425
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Menampilkan nama dari direktori yang digunakan sekarang.\n"
"    \n"
"    Pilihan:\n"
"      -L\tmenampilkan nilai dari $PWD jika ini nama dari direktori\n"
"    \t\tyang digunakan sekarang\n"
"      -P\tmenampilkan direktori pisik, tanpa link simbolik apapun\n"
"    \n"
"    Secara default, `pwd' berlaku seperi jika pilihan `-L' "
"dispesifikasikan.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan 0 kecuali jika sebuah pilihan tidak valid diberikan atau "
"direktori sekarang\n"
"    tidak bisa dibaca."

#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Perintah kosong.\n"
"    \n"
"    Tidak ada efek; perintah tidak melakukan apa-apa.\n"
"    \n"
"    Status Keluar:\n"
"    Selalu sukses."

#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Mengembalikan sebuah hasil yang sukses.\n"
"    \n"
"    Status Keluar:\n"
"    Selalu sukses."

#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Mengembalikan sebuah kembaliah yang tidak sukses.\n"
"    \n"
"    Status Keluar:\n"
"    Selalu gagal."

#: builtins.c:471
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Menjalankan sebuah perintah sederhana atau menampilkan informasi mengenai "
"perintah.\n"
"    \n"
"    Menjalankan PERINTAH tanpa ARGS menekan fungsi pencarian shell, atau "
"menampilkan\n"
"    informasi mengenasi PERINTAH tertentu. Dapat digunakan untuk memanggil "
"perintah\n"
"    dalam disk ketika sebuah fungsi dengan nama yang sama ada.\n"
"    \n"
"    Pilihan:\n"
"      -p    gunakan sebuah nilai default untuk PATH yang menjamin untuk "
"mencari seluruh\n"
"            penggunaan stadar\n"
"      -v    menampilkan deskripsi dari PERINTAH sama dengan `type' builtin\n"
"      -V    menampilkan lebih jelas deskripsi dari setiap PERINTAH\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status keluar dari PERINTAH, atau gagal jika PERINTAH "
"tidak ditemukan."

#: builtins.c:490
#, fuzzy
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Menset nilai variabel dan atribut.\n"
"    \n"
"    Variabel deklarasi dan memberikan atribut untuknya. Jika tidak ada NAMA "
"yang diberikan,\n"
"    tampilkan atribut dan nilai dari seluruh variabel.\n"
"    \n"
"    Pilihan:\n"
"      -f\tbatasi aksi atau tampilkan nama fungsi dan definisi\n"
"      -F\tbatasi tampilan ke nama fungsi saja (tambahkan nomor baris dan\n"
"    \tsumber berkas ketika debugging)\n"
"      -p\ttampilkan atribut dan nilai dari setiap NAMA\n"
"    \n"
"    Pilihan yang menset atribut:\n"
"      -a\tuntuk membuat NAMA idex array (jika didukung)\n"
"      -A\tuntuk membuat NAMA assosiasi array (jika didukung)\n"
"      -i\tuntuk membuat NAMA memiliki atribut `integer'\n"
"      -l\tuntuk mengubah NAMA ke huruf kecil dalam assignment\n"
"      -r\tuntuk membuah NAMA baca-saja\n"
"      -u\tuntuk mengubah NAMA ke huruf besar dalam penempatan\n"
"      -x\tuntuk membuah NAMA export\n"
"    \n"
"    Menggunakan `+' daripada `-' menonaktifkan atribut yang diberikan.\n"
"    \n"
"    Variabel dengan atribut integer memiliki evaluasi aritmetic (lihat\n"
"    perintah `let') ditampilkan ketika variabel diberi sebuah nilai.\n"
"    \n"
"    Ketika digunakan dalam sebuah fungsi, `declare' membuat NAMA lokal, "
"seperti dengan\n"
"    perintah `local'.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan atau "
"sebuah error terjadi."

#: builtins.c:532
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Menset nilai variabel dan atribut.\n"
"    \n"
"    Sama dengan `declare'. Lihat `help declare'."

#: builtins.c:540
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Mendefinisikan variabel lokal.\n"
"    \n"
"    Membuat sebuah variabel locak dipanggil NAMA, dan memberikan kepadanya "
"NILAI. OPSI dapat\n"
"    berupa semua pilihan yang diterima oleh `declare'.\n"
"    \n"
"    Variabel lokal hanya dapat digunakan dalam sebuah fungsi; mereka hanya\n"
"    dapat dilihat ke fungsi dimana mereka terdefinisi dan anaknya.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan, "
"sebuah error terjadi.\n"
"    atau shell tidak menjalankan sebuah fungsi."

#: builtins.c:557
#, fuzzy
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by "
"a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value "
"HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal "
"value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Tulis argumen ke standar keluaran.\n"
"    \n"
"    Menampilkan ARG ke standar keluaran diikuti oleh baris baru.\n"
"    \n"
"    Pilihan:\n"
"      -n\tjangan menambahkan sebuah baris baru\n"
"      -e\taktifkan interpretasi dari karakter backslash\n"
"      -E\tsecara eksplisit tekan interpretasi dari karakter backslash\n"
"    \n"
"    `echo' menginterpretasikan karakter backslash-escaped berikut:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress karakter baris baru yang tersisa\n"
"      \\E\tescape karakter\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tkarakter yang memiliki kode ASCII NNN (oktal). NNN dapat "
"berupa\n"
"    \t0 sampai 3 oktal digit\n"
"      \\xHH\tdelapan-bit karakter yang nilainya adalah HH (hexadesimal). HH\n"
"    \tdapat satu dari dua bilangan hex\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah penulisan error terjadi."

#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Menulis argumen ke standar output.\n"
"    \n"
"    Menampilkan ARG ke standard keluaran diikuti dengan sebuah baris baru.\n"
"    \n"
"    Pilihan:\n"
"      -n\tjangan menambahkan sebuah baris baru\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah penulisan error terjadi."

#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Aktifkan dan non-aktifkan shell builtins.\n"
"    \n"
"    Aktifkan dan non-aktifkan perintah builtin shell. Menonaktifkan "
"membolehkan anda untuk\n"
"    menjalankan sebuah perintah disk yang memiliki nama yang sama dengan "
"shell builtin\n"
"    tanpa menggunakan sebuah nama jalur yang lengkap.\n"
"    \n"
"    Pilihan:\n"
"      -a\ttampilkan daftar dari builtins memperlihatkan aktif atau tidak "
"setiap diaktifkan\n"
"      -n\tmenonaktifkan setiap NAMA atau tampilkan daftar dari builtin yang "
"tidak aktif\n"
"      -p\ttampilkan daftar dari builtins dalam format yang berguna\n"
"      -s\ttampilkan yang nama dari Posix `special' builtins\n"
"   \n"
"   Pilihan mengontrol dynamic loading:\n"
"      -f\tLoad builtin NAMA dari shared object NAMA BERKAS\n"
"      -d\tHapus sebuah builtin diload dengan -f\n"
"   \n"
"   Tanpa pilihan, untuk setiap NAMA di aktifkan.\n"
"   \n"
"   Untuk menggunakan `test' ditemukan dalam $PATH daripada dalam shell "
"builtin\n"
"   versi, ketik `enable -n test'.\n"
"   \n"
"   Status Keluar:\n"
"   Mengembalikan sukses kecuali NAMA bukan sebuah shell builtin atau sebuah "
"error terjadi."

#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Menjalankan argumen sebagai sebuah perintah shell.\n"
"    \n"
"    Mengkombinasikan ARG dalam sebuah string tunggal, gunakan hasil sebagai "
"masukan dalam shell,\n"
"    dan jalankan hasil dari perintah.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status keluar dari perintah atau sukses jika perintah "
"adalah kosong."

#: builtins.c:652
#, fuzzy
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Ambil argumen pilihan.\n"
"    \n"
"    Getops digunakan oleh shell procedures untuk memparse parameter posisi.\n"
"    \n"
"    OPTSTRING berisi huruf pilihan yang dikenali; jika sebuah huruf\n"
"    diikuti oleh sebuah colon, pilihan diduga akan berupa argumen,\n"
"    yang seharusnya dipisahkan dari itu oleh spasi.\n"
"    \n"
"    Setiap waktu ini dipanggil, getopts akan menempatkan pilihan selanjutnya "
"dalam\n"
"    $name shell variabel, menginisialisasi nama jiki ini tidak ada, dan\n"
"    index dari argumen selanjutnya untuk diproses kedalam shell\n"
"    variabel OPTIND. OPTIND diinisialisasi ke 1 setiap shell atau\n"
"    sebuah shell script dipanggil. Ketika sebuah pilihan membutuhkan sebuah "
"argumen,\n"
"    getopts menempatkan argumen itu kedalam variabel shell OPTARG.\n"
"    \n"
"    getopts melaporkan error dalam satu dari dua cara. Jika karakter "
"pertama\n"
"    dari OPTSTRING adalah sebuah colon, getopts menggunakan silent error "
"laporan. Dalam\n"
"    Mode ini, tidak ada pesan error yang ditampilkan. Jika sebuah pilihan "
"tidak valid terlihat\n"
"    getops menempatkan karakter pilihan yang ditemukan ke OPTARG. Jika "
"sebuah\n"
"    argumen yang dibutuhkan tidak ditemukan, getopts menempatkan sebuah ':' "
"kedalam NAME dan\n"
"    menset OPTARG ke pilihan karakter yang ditemukan. Jika getopts tidak "
"dalam\n"
"    mode silent, dan sebuah pilihan tidak valid terlihat getopts menempatkan "
"'?' kedalam\n"
"    variabel NAME, OPTARG tidak diset, dan sebuah pesan analisis\n"
"    tampilkan.\n"
"    \n"
"    Jika sebuah variabel shell OPTERR memiliki sebuah nilai 0, getopts "
"mendisable\n"
"    pencetakan dari pesan error, bahkan jika karakter pertama dari\n"
"    OPTSTRING bukan sebuah colon. OPTERR memiliki nilai 1 secara default.\n"
"    \n"
"    Getopts secara normal memparse parameter posisi ($0 - $9), tetapi jika\n"
"    lebih dari satu argumen diberikan, mereka diparse.    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses jika sebuah pilihan ditemukan; gagal jika akhir "
"dari pilihan\n"
"    ditemui atau sebuah error terjadi."

#: builtins.c:694
#, fuzzy
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""
"Mengganti shell dengan perintah yang diberikan.\n"
"    \n"
"    Jalankan PERINTAH, ganti shell ini dengan aplikasi yang "
"dispesifikaskan.\n"
"    ARGUMEN menjadi argumen dari PERINTAH. Jika PERINTAH tidak "
"dispesifikasikan,\n"
"    setiap redireksi akan memiliki afek dalam shell sekarang.\n"
"    \n"
"    Pilihan:\n"
"      -a nama\tlewatkan NAMA sebagai argumen ke nol ke PERINTAH\n"
"      -c\t\tjalankan PERINTAH dengan sebuah environment kosong\n"
"      -l\t\ttempatkan sebuah dash dalam argumen ke nol ke PERINTAH\n"
"    \n"
"    Jika perintah tidak dapat dijalankan, sebuah non-interaktif shell "
"keluar, kecuali\n"
"    pilihan shell `execfail' diset.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali PERINTAH tidak ditemukan atau sebuah "
"redireksi error terjadi."

#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Keluar dari shell.\n"
"    \n"
"    Keluar dari shell dengan status dari N. Jika N diabaikan, status "
"keluaran\n"
"    adalah status dari perintah terakhir yang dijalankan."

#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""
"Keluar dari sebuah login shell.\n"
"    \n"
"    Keluar sebuah login shell dengan status keluar N. Mengembalikan sebuah "
"error jika tidak dijalankan\n"
"    dalam sebuah login shell."

#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""
"Tampilkan atau jalankan perintah dari daftar sejarah.\n"
"    \n"
"    fc biasa digunakan untuk mendaftar atau mengubah dan menjalankan "
"perintah dari daftar sejarah.\n"
"    PERTAMA dan TERAKHIR dapat berupa nomor yang menspesifikasikan "
"jangkauan, atau PERTAMA dapat berupa sebuah\n"
"    string, yang berarti adalah perintah yang berawal dengan string.\n"
"    \n"
"    Pilihan:\n"
"       -e ENAME\tmemilih editor yang akan digunakan. Default adalah FCEDIT, "
"kemudian EDITOR,\n"
"    \t\tkemudian vi.\n"
"       -l \tdaftar baris daripada mengubahnya.\n"
"       -n \tabaikan nomor baris ketika MENDAFTAR.\n"
"       -r \tmembalik urutan dari baris (membuat yang terbaru terdaftar "
"pertama).\n"
"    \n"
"    Dengan `fc -s [pat=rep ...] [perintah]' format, perintah\n"
"    dijalankan setelah substitusi OLD=NEW dilakukan.\n"
"    \n"
"    Sebuah alias yang berguna yang digunakan dengan ini r='fc -s', jadi "
"mengetikan `r cc'\n"
"    menjalankan perintah terakhir yang diawali dengan `cc' dan mengetikan "
"'r' menjalankan kembali\n"
"    perintah terakhir.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses atau status dari perintah yang dijalankan; tidak-"
"nol jika sebuah error terjadi."

#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Pindahkan pekerjaan di foreground.\n"
"    \n"
"    Tempatkan JOB_SPEC di foreground, dan buat ini pekerjaan saat ini. Jika\n"
"    JOB_SPEC tidak ada, shell notion dari pekerjaan saat ini\n"
"    yang digunakan.\n"
"    \n"
"    Status Keluar:\n"
"    Status dari perintah yang ditempatkan di foreground, atau gagal jika "
"sebuah error terjadi."

#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Pindahkan pekerjaan ke background.\n"
"    \n"
"    Tempatkan setiap JOB_SPEC dalam background, seperti jika ini telah "
"dimulai dengan\n"
"    `&'. Jika JOB_SPEC tidak ada, notion shell's dari pekerjaan\n"
"    yang saat berjalan digunakan.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali pengontrol pekerjaan tidak aktif atau "
"sebuah error terjadi."

#: builtins.c:793
#, fuzzy
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Ingat atau tampilkan lokasi aplikasi.\n"
"    \n"
"    Tentukan dan ingat nama jalur lengkap dari setiap NAMA perintah. Jika\n"
"    tidak ada argumen yang diberikan, informasi mengenai perintah yang "
"diingat akan ditampilkan.\n"
"    \n"
"    Pilihan:\n"
"      -d\t\tlupakan lokasi yang diingat untuk setiap NAMA\n"
"      -l\t\ttampilkan dalam format yang bisa digunakan sebagai masukan\n"
"      -p pathname\tgunakan NAMA JALUR yang nama jalur lengkap dari NAMA\n"
"      -r\t\tlupakan semua lokasi yang diingat\n"
"      -t\t\ttampilkan lokasi yang diingat untuk setiap NAMA, diawali\n"
"   \t\tuntuk setiap lokasi diberikan NAMA yang sesuai jika multiple\n"
"   \t\tNAMA diberikan\n"
"   Argumen:\n"
"      NAMA\t\tSetiap NAMA yang ditemukan dalam $PATH dan ditambahkan dalam "
"daftar\n"
"   \t\tdari perintah yang diingat.\n"
"   \n"
"   Status Keluar:\n"
"   Mengembalikan sukses kecuali NAMA tidak ditemukan atau sebuah pilihan "
"tidak valid telah diberikan."

#: builtins.c:818
#, fuzzy
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""
"Tampilkan informasi mengenai perintah builtin.\n"
"    \n"
"    Tampilkan ringkasan singkat dari perintah builtin. Jika POLA\n"
"    dispesifikasikan, tampilkan bantuan lengkap di seluruh perintah yang "
"cocok dengan POLA,\n"
"    jika tidak daftar dari topik bantuan ditampilkan.\n"
"    \n"
"    Pilihan:\n"
"      -d\tkeluarkan deskripsi singkat untuk setiap topik\n"
"      -m\ttampilkan penggunaan dalam format pseudo-manpage\n"
"      -s\tkeluarkan hanya penggunaan singkat untuk setiap topik yang cocok\n"
"    \tdengan POLA\n"
"    \n"
"    Argumen:\n"
"      POLA\tPola menspesifikasikan topik bantuan\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali POLA tidak ditemukan atau pilihan tidak "
"valid diberikan."

#: builtins.c:842
#, fuzzy
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Menampilkan atau memanipulasi daftar sejarah.\n"
"    \n"
"    Menampilkan daftar sejarah dengan nomor baris. Baris yang ditampilkan "
"dengan\n"
"    sebuah `*' telah diubah. Argumen dari N mengatakan untuk menampilkan "
"hanya\n"
"    N baris terakhir.\n"
"    \n"
"    Pilihan:\n"
"      -c\tmenghapus daftar sejarah dengan cara menghapus seluruh masukan\n"
"      -d menghapus masukan sejarah di offset OFFSET.\n"
"    \n"
"      -a\tmenambahkan ke daftar sejarah dari sesi ini ke berkas sejarah.\n"
"      -n\tmembaca seluruh baris sejarah yang belum dibaca dari berkas "
"sejarah\n"
"      -r\tmembaca berkas sejarah dan menambahkan isinya ke daftar\n"
"    \tsejarah\n"
"      -w menulis sejarah sekarang ke berkas sejarah\n"
"    \tdan menambahkannya kedalam daftar sejarah\n"
"    \n"
"      -p\tjalankan expansi sejarah untuk setiap ARG dan tampilkan hasilnya\n"
"    \ttanpa menyimpannya kedalam daftar sejarah\n"
"      -s\ttambahkan ARG ke daftar sejarah sebagai sebuah masukan tunggal\n"
"    \n"
"    \n"
"    Jika NAMAFILE diberikan, maka itu digunakan sebagai berkas sejarah "
"selain itu\n"
"    jika $HISTFILE memiliki nilai, maka itu digunakan, selain itu ~/."
"bash_history.\n"
"    \n"
"    \n"
"    Jika variabel $HISTTIMEFORMAT diset dan tidak kosong, nilai ini yang "
"akan digunakan\n"
"    sebagai format untuk string untuk strftime(3) untuk mencetak timestamp "
"yang berhubungan\n"
"    dengan setiap masukan sejarah yang ditampilkan. Tidak ada time stamp "
"yang ditampilkan jika tidak.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan atau "
"sebuah error terjadi."

#: builtins.c:879
#, fuzzy
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Menampilkan status dari pekerjaan.\n"
"    \n"
"    Tampilkan pekerjaan yang aktif.  JOBSPEC membatasi keluaran ke pekerjaan "
"itu.\n"
"    Tanpa pilihan, status dari seluruh aktif job ditampilkan.\n"
"    \n"
"    Pilihan:\n"
"      -l menampilkan daftar dari proses id sebagai informasi tambahan.\n"
"      -n diberikan, hanya proses yang sudah berubah status saja sejak\n"
"    \tnotifikasi terakhir yang ditampilkan.\n"
"      -p hanya menampilkan proses id saja.\n"
"      -r membatasi keluaran ke pekerjaan yang sedang jalan\n"
"      -s membatasi keluaran ke pekerjaan yang berhenti\n"
"    \n"
"    Jika pilihan -x diberikan, PERINTAH dijalankan setelah semua spesifikasi "
"pekerjaan\n"
"    yang tampil di ARGS telah diganti dengan proses ID dari proses "
"pekerjaan\n"
"    grup leader.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecualis sebuah pilihan tidak valid diberikan atau "
"sebuah error terjadi.\n"
"    Jika -x digunakan, mengembalikan status keluar dari PERINTAH."

#: builtins.c:906
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Hapus pekerjaan dari shell sekarang.\n"
"    \n"
"    Hapus setiap JOBSPEC argumen dari tabel dari pekerjaan aktif. Tanpa\n"
"    JOBSPEC apapun, shell menggunakan indikasi ini dari pekerjaan sekarang.\n"
"    \n"
"    Pilihan:\n"
"      -a\thapus seluruh pekerjaan jika JOBSPEC tidak diberikan\n"
"      -h\ttandai setiap JOBSPEC sehingga SIGHUP tidak dikirim ke pekerjaan "
"jika\n"
"    \t\tshell menerima sebuah SIGHUP\n"
"      -r\thapus hanya pekerjaan yang sedang berjalan\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali ada sebuah pilihan tidak valid atau JOBSPEC "
"diberikan."

#: builtins.c:925
#, fuzzy
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Mengirim sebuah sinyal ke sebuah pekerjaan.\n"
"    \n"
"    Mengirim ke sebuah proses yang diidentifikasikan oleh PID atau JOBSPEC "
"dengan sinyal yang diberi name\n"
"    oleh SIGSPEC atau SIGNUM. Jika SIGSPEC atau SIGNUM tidak ada, maka\n"
"    SIGTERM diasumsikan.\n"
"    \n"
"    Pilihan:\n"
"      -s sig\tSIG adalah sebuah nama sinyal\n"
"      -n sig\tSIG adalah sebuah nomor sinyal\n"
"      -l\tdaftar dari nama sinyal; jika argumen diikuti dengan `-l' mereka "
"mengasumsikan ke\n"
"    \tnomor sinyal yang namanya ditampilkan.\n"
"    Kill adalah sebuah shell builtin untuk dua alasan; ini membolehkan "
"sebuah jobs ID untuk digunakan dari pada\n"
"    proses IDs, dan memperbolehkan proses untuk dimatikan jika batas\n"
"    dari proses yang dibuat tercapai.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan atau "
"sebuah error terjadi."

#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Evaluasi ekspresi arithmetic.\n"
"    \n"
"    Setiap ARG adalah sebuah ekspresi arithmetic yang dievaluasi. Evaluasi\n"
"    dilakukan dalam fixed-width integers dengan tidak ada pemeriksaan untuk "
"overflow, walaupun\n"
"    pembagian dengan 0 ditangkap dan ditandai sebagai error. Berikut\n"
"    daftar dari operator yang dikelompokkan dalam tingkat tingkat dari equal "
"precedence operators.\n"
"    Tingkat yang ditampilkan dalam urutan dari decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariabel post-increment, post-decrement\n"
"    \t++id, --id\tvariabel pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical dan bitwise negasi\n"
"    \t**\t\texponential\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+. -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shift\n"
"    \t<=. >=, <, >\tperbandingan\n"
"    \t==, !=\t\tpersamaan, dan ketidak samaan\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\toperator kondisional\n"
"    \t=, *=, /=, %=,\n"
"    \t+=. -=. <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Variabel shell dibolehkan sebagai operand. Nama dari variabel\n"
"    digantikan oleh nilainya (coerced ke fixed-width integer) dalam\n"
"    sebuah expresi. Variabel tidak butuh atribut integer\n"
"    dinyalakan untuk digunakan dalam sebuah expresi.\n"
"    \n"
"    Operator yang dievaluasi dalam urutan precedence. Sub-expresi dalam\n"
"    parentheses dievaluasi terlebih dahulu dan boleh dioverride precedence\n"
"    aturan diatasnya.\n"
"    \n"
"    Status Keluar:\n"
"    Jika ARG terakhir dievaluasi ke 0, membiarkan kembali ke 1; 0 "
"dikembalikan Jika tidak."

#: builtins.c:994
#, fuzzy
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters. By default, the backslash character escapes delimiter "
"characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, "
"unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out\n"
"    (in which case it's greater than 128), a variable assignment error "
"occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Membaca sebuah baris dari standar masukan dan membaginya dalam bagian "
"bagian.\n"
"    \n"
"    Satu baris dibaca dari masukan standar, atau dari berkas deskripsi FD "
"jika\n"
"    pilihan -u diberikan, dan kata pertama diberikan ke NAMA pertama,\n"
"    kata kedua ke NAMA kedua, dan seterusnya. dengan kata yang tersisa "
"ditempatkan\n"
"    ke NAMA terakhir. Hanya karakter yang ditemukan dalam $IFS yang dikenal "
"sebagai pembatas\n"
"    kata.\n"
"   \n"
"    Jika tidak ada NAMA yang diberikan, baris yang dibaca disimpan dalam "
"variabel BALASAN\n"
"    \n"
"    Pilihan:\n"
"      -a array\tditempatkan kata dibaca secara berurutan indice dari array\n"
"    \t\tvariabel ARRAY, dimulai dari nol\n"
"      -d delim\tdilanjutkan sampai karakter pertama dari PEMBATAS dibaca, "
"daripada\n"
"    \t\tbaris baru\n"
"      -e\t\tgunakan Readline untuk memperoleh baris dalam sebuah shell "
"interaktif\n"
"      -i text\tGunakan TEXT sebagai text inisial untuk Readline\n"
"      -n nchars\tkembali setelah membaca NCHARS characters daripada "
"menunggu\n"
"    \t\tuntuk sebuah baris baru\n"
"      -N nchars\thanya kembali setelah membaca tepat NCHARS karakter, "
"kecuali\n"
"    \t\tEOF ditemui atau waktu habis dalam pembacaan, abaikan pembatas "
"apapun\n"
"      -p prompt\tkeluarkan string PROMPT tanpa tambahan baris baru sebelum\n"
"    \t\tmencoba untuk membaca\n"
"      -r\t\tjangan ijinkan backslash untuk mengeluarkan karakter apapun\n"
"      -s\t\tjangan echo masukan yang datang dari sebuah terminal\n"
"      -t menyebabkan pembacaan untuk time out dan kembali gagal jika sebuah "
"baris lengkap\n"
"    \t\tdari masukan tidak dibaca dalam TIMEOUT detik. Jika variabel TMOUT "
"terset,\n"
"    \t\tnilai ini akan menjadi nilai default timeout. TIMEOUT mungkin "
"sebuah\n"
"    \t\tbilangan fraksional. Status keluaran lebih besar dari 128 jika\n"
"    \t\ttimeout dilewati\n"
"      -u fd\t\tbaca dari berkas deskripsi FD daripada standar masukan\n"
"    \n"
"    Status Keluar:\n"
"    Kode kembali adalah nol, kecuali akhir-dari-berkas ditemui, baca "
"kehabisan waktu,\n"
"    atau sebuah berkas deskripsi disupply sebagai sebuah argumen ke pilihan -"
"u."

#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Kembali dari sebuah fungsi shell.\n"
"    \n"
"    Menyebabkan sebuah fungsi atau sebuah script untuk keluar dengan nilai "
"kembali\n"
"    yang dispesifikasikan oleh N. Jika N diabaikan, status kembalian adalah\n"
"    perintah terakhir yang dijalankan dalam fungsi atau script.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan N, atau gagal jika shell tidak menjalan sebuah fungsi atau "
"script."

#: builtins.c:1055
#, fuzzy
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell "
"functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Set atau unset nilai dari pilihan shell dan parameter posisi.\n"
"    \n"
"    Ubah nilai dari atribut shell dan parameter posisi, atau\n"
"    tampilkan nama dan nilai dari variabel shell.\n"
"    \n"
"    Pilihan:\n"
"         -a Tandai variabel yang telah termodifikasi atau dibuat untuk "
"export.\n"
"         -b Notifikasi penyelesaian pekerjaan secara langsung.\n"
"         -e Keluar langsung jika sebuah perintah keluar dengan status tidak "
"nol.\n"
"         -f Menonaktifkan pembuatan nama berkas (globbing).\n"
"         -h Ingat lokasi dari perintah sebagai mereka dicari.\n"
"         -k Semua argumen assignment ditempatkan dalam environment untuk "
"sebuah\n"
"            perintah, tidak hanya mengawali nama perintah.\n"
"         -m Pengendali pekerjaan diaktifkan.\n"
"         -n Baca perintah tapi jangan menjalankan perintah tersebut.\n"
"         -o nama-pilihan\n"
"            Set variabel menurut nama-pilihan:\n"
"              allexport   sama seperti -a\n"
"              braceexpand sama seperti -B\n"
"              emacs       gunakan gaya emacs dalam line editing interface\n"
"              errexit     sama seperti -e\n"
"              errtrace    sama seperti -E\n"
"              functrace   sama seperti -T\n"
"              hashall     sama seperti -h\n"
"              histexpand  sama seperti -H\n"
"              history     aktifkan sejarah perintah\n"
"              ignoreeof   shell tidak akan keluar ketika membaca EOF\n"
"              interactive-comments\n"
"                          membolehkan komentar ada dalam perintah "
"interaktif\n"
"              keyword     sama seperti -k\n"
"              monitor     sama seperti -m\n"
"              noclobber   sama seperti -C\n"
"              noexec      sama seperti -n\n"
"              noglob      sama seperti -f\n"
"              nolog       saat ini diterima tetapi diabaikan\n"
"              notify      sama seperti -b\n"
"              nounset     sama seperti -u\n"
"              onecmd      sama seperti -t\n"
"              physical    sama seperti -P\n"
"              pipefail    nilai kembalian dari sebuah pipelie adalah status "
"dari\n"
"                          perintah terakhir yang keluar dengan sebuah status "
"tidak nol,\n"
"                          atau nol jika tidak ada perintah yang keluar "
"dengan status tidak nol\n"
"              posix       ubah perilaku dari bash dimana operasi\n"
"                          default berbeda dari 1003.2 standar ke\n"
"                          sesuai dengan standar\n"
"              privileged  sama seperti -p\n"
"              verbose     sama seperti -v\n"
"              vi          gunakan sebuah gaya vi dalam line editing "
"interface.\n"
"              xtrace      sama seperti -x\n"
"         -p Aktif ketika real dan efektif id pengguna tidak cocok.\n"
"            Menonaktifkan pemrosesan dari berkas $ENV dan mengimpor dari "
"fungsi\n"
"            shell. Mengubah pilihan ini off menyebabkan efektif uid dan\n"
"            gid untuk diset ke real uid dan gid.\n"
"         -t Keluar setelah  membaca dan menjalankan satu perintah.\n"
"         -u Perlakukan variabel yang tidak diset sebagai error ketika "
"mensubstitusi.\n"
"         -v Tampilkan baris masukan shell seperti ketika dibaca.\n"
"         -x Tampilkan perintah dan argumennya ketika menjalankan perintah "
"tersebut.\n"
"         -B Shell akan melakukan expansi brace\n"
"         -C Jika diset, melarang berkas regular yang telah ada untuk "
"ditulis\n"
"            oleh keluaran redirection.\n"
"         -E Jika diset, trap ERR diturunkan oleh fungsi shell.\n"
"         -H Mengaktifkan ! gaya pengubahan sejarah.  Tanda ini aktif\n"
"            secara default ketika shell interaktif.\n"
"         -P Jika diset, jangan ikuti symbolic link ketika menjalankan "
"perintah\n"
"            seperti cd ketika mengubah direktori kerja sekarang.\n"
"         -T Jika diset, Debug trap diturunkan oleh fungsi shell.\n"
"         -  Assign argumen yang tersisa ke parameter posisi.\n"
"            Pilihan -x dan -v akan dimatikan.\n"
"    \n"
"    Menggunakan + daripada - akan menyebabkan tanda untuk dimatikan. Tanda\n"
"    juga bisa digunakan dalam pemanggilan shell. Tanda yang terset\n"
"    saat ini dapat ditemukan dalam $-. ARG n yang tersisa adalah parameter\n"
"    posisi dan ditempatkan, dalam urutan, ke $1, $2, ... $n. Jika tidak ada\n"
"    ARG yang diberikan, semua shell variabel ditampilkan.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan."

#: builtins.c:1140
#, fuzzy
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Unset nilai dan atribut dari variabel shell dan fungsi.\n"
"    \n"
"    Untuk setiap NAMA, hapus variabel atau fungsi yang berhubungan.\n"
"    \n"
"    Pilihan:\n"
"      -f\tperlakukan setiap NAMA sebagai sebuah fungsi shell\n"
"      -v\tperlakukan setiap NAMA sebagai sebuah variabel shell\n"
"    \n"
"    Tanpa pilihan, unset pertama mencoba untuk menunset sebuah variabel, dan "
"jika itu gagal,\n"
"    mencoba untuk menunset sebuah fungsi.\n"
"    \n"
"    Beberapa variabel tidak dapat diunset; Lihat juga `readonly'.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan atau "
"sebuah NAMA adalah baca-saja."

#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Set export atribut untuk variabel shell.\n"
"    \n"
"    Tandai setiap NAMA untuk otomatis export ke environment setelah\n"
"    perintah dijalankan. Jika NILAI diberikan, berikan NILAI sebelum "
"export.\n"
"    \n"
"    Pilihan:\n"
"      -f\tmerujuk ke fungsi shell\n"
"      -n\thapus properti export dari setiap NAMA\n"
"      -p\ttampilkan daftar dari seluruh variabel dan fungsi yang terexport\n"
"    \n"
"    Sebuah argumen dari `--' menonaktifkan pemrosesan pilihan selanjutnya.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan atau "
"NAMA tidak valid."

#: builtins.c:1181
#, fuzzy
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Tandai variabel shell sebagai tidak bisa diubah.\n"
"    \n"
"    Tandai setiap NAMA sebagai baca-saja; nilai dari NAMA ini tidak boleh\n"
"    diubah untuk penggunaan selanjutnya. Jika NILAI diberikan, berikan "
"NILAI\n"
"    sebelum menandainya sebagai baca-saja.\n"
"    \n"
"    Pilihan:\n"
"      -a\tmerujuk ke aray index variabel\n"
"      -A\tmerujuk ke variabel aray assosiasi\n"
"      -f\tmerujuk ke fungsi shell\n"
"      -p\tmenampilkan sebuah daftar dari seluruh variabel dan fungsi baca-"
"saja\n"
"    \n"
"    Sebuah argumen dari `--' menonaktifkan pemrosesan pilihan selanjutnya.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecual sebuah pilihan tidak valid diberikan atau "
"NAMA tidak valid."

#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Geser parameter posisi.\n"
"    \n"
"    Ubah nama parameter posisi $N+1,$N+2 ... ke $1,$2 ... Jika N\n"
"    tidak diberikan, N diasumsikan 1.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali N adalah negatif atau lebih besar dari $#."

#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Jalankan perintah dari sebuah berkas dalam shell sekarang.\n"
"    \n"
"    Baca dan jalankan perintah dari FILENAME dan kembali. Nama jalur dalam\n"
"    $PATH digunakan untuk mencari direktori yang berisi NAMABERKAS. Jika "
"salah satu\n"
"    dari ARGUMENTS diberikan, mereka menjadi parameter posisi ketika\n"
"    NAMABERKAS dijalankan.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status dari perintah terakhir yang dijalankan dalam NAMA "
"BERKAS; gagal jika\n"
"    NAMA BERKAS tidak dapat dibaca."

#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Suspend eksekusi shell.\n"
"    \n"
"    Suspend eksekusi dari shell ini sampai menerima sebuah sinyal SIGCONT.\n"
"    Kecuali dipaksa, login shell tidak dapat disuspend.\n"
"    \n"
"    Pilihan:\n"
"      -f\tpaksa untuk suspend, walaupun jika shell adalah sebuah login "
"shell\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali pengontrol pekerjaan tidak aktif atau "
"sebuah error terjadi."

#: builtins.c:1262
#, fuzzy
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Evaluasi ekspresi kondisi.\n"
"    \n"
"    Keluar dengan sebuah status dari 0 (benar) atau 1 (salah) tergantung "
"dari\n"
"    evaluasi dari EXPR. Expresi dapat berupa unary atau binary. Unary\n"
"    expresi sering digunakan untuk memeriksa status dari sebuah berkas.\n"
"    Terdapat operator string juga, dan operator pembanding numerik.\n"
"    \n"
"    Operator berkas:\n"
"    \n"
"        -a BERKAS       Benar jika berkas ada.\n"
"        -b BERKAS       Benar jika berkas berupa blok spesial.\n"
"        -c BERKAS       Benar jika berkas adalah karakter spesial.\n"
"        -d BERKAS       Benar jika berkas adalah sebuah direktori.\n"
"        -e BERKAS       Benar jika berkas ada.\n"
"        -f BERKAS       Benar jika berkas ada dan berupa sebuah berkas "
"regular.\n"
"        -g BERKAS       Benar jika berkas memiliki set-grup-id.\n"
"        -h BERKAS       Benar jika berkas adalah symbolic link.\n"
"        -L BERKAS       Benar jika berkas adalah symbolic link.\n"
"        -k BERKAS       Benar jika berkas memiliki `sticky' bit diset.\n"
"        -p BERKAS       Benar jika berkas adalah named pipe.\n"
"        -r BERKAS       Benar jika berkas dapat dibaca oleh anda.\n"
"        -s BERKAS       Benar jika berkas ada dan tidak kosong.\n"
"        -S BERKAS       Benar jika berkas adalah socket.\n"
"        -t FD           Benar jika FD dibuka dalam sebuah terminal.\n"
"        -u BERKAS       Benar jika berkas memiliki set-user-id.\n"
"        -w BERKAS       Benar jika berkas dapat ditulis oleh anda.\n"
"        -x BERKAS       Benar jika berkas dapat dijalankan oleh anda.\n"
"        -O BERKAS       Benar jika berkas secara efektif dimiliki oleh "
"anda.\n"
"        -G BERKAS       Benar jika berkas secara efektif dimiliki oleh grup "
"anda.\n"
"        -N BERKAS       Benar jika berkas telah dimodifikasi sejak terakhir  "
"ini dibaca.\n"
"      \n"
"        FILE1 -nt FILE2 Benar jika file1 lebih baru dari file2 (menurut \n"
"                        tanggal modifikasi).\n"
"      \n"
"        FILE1 -ot FILE2 Benar jika file1 lebih lama dari file2.\n"
"      \n"
"        FILE1 -ef FILE2 Benar jika file1 adalah hard link ke file2.\n"
"      \n"
"      String operators:\n"
"      \n"
"           -z STRING    Benar jika string kosong.\n"
"      \n"
"           -n STRING\n"
"           STRING       Benar jika string tidak kosong.\n"
"      \n"
"           STRING1 = STRING2\n"
"                        Benar jika string sama.\n"
"           STRING1 != STRING2\n"
"                        Benar jika string tidak sama.\n"
"           STRING1 < STRING2\n"
"                        Benar jika STRING1 sorts sebelum STRING2 "
"lexicographically.\n"
"           STRING1 > STRING2\n"
"                        Benar jika STRING1 sorts sesudah STRING2 "
"lexicographically.\n"
"       \n"
"       Operator lain:\n"
"       \n"
"         -o Pilihan        Benar jika pilihan shell OPSI diaktifkan.\n"
"         ! EXPR         Benar jika expr salah.\n"
"         EXPR1 -a EXPR2 Benar jika kedua expr1 dan expr2 adalah benar.\n"
"         EXPR1 -o EXPR2 Benar jika salah satu dari expr1 atau expr2 adalah "
"benar.\n"
"       \n"
"         arg1 OP arg2   Pemeriksaan arithmetik. OP adalah salah satu dari -"
"eq, -ne,\n"
"                        -lt, -le, -gt, atau -ge.\n"
"       \n"
"       Arithmetic binary operator mengembalikan benar jika ARG1 adalah "
"equal, not-equal,\n"
"       less-than, less-than-or-equal, greater-than, atau greater-than-or-"
"equal\n"
"       than ARG2.\n"
"       \n"
"       Status Keluar:\n"
"       Mengembalikan sukses jika EKSPR mengevaluasi ke benar; gagal jika "
"EXPR mengevaluasi ke\n"
"       salah atau sebuah argumen tidak valid diberikan."

#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Evaluasi expresi kondisional.\n"
"    \n"
"    Ini sinonim untuk \"test\" builtin, tetapi argumen terakhir\n"
"    harus berupa sebuah literal `]', untuk mencocokan dengan pembukaan `['."

#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Tampilkan waktu pemrosesan.\n"
"    \n"
"    Tampilkan akumulasi waktu penggunaan pengguna dan sistem untuk shell dan "
"seluruh proses dari\n"
"    anaknya.\n"
"    \n"
"    Status Keluar:\n"
"    Selalu sukses."

#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  "
"If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or "
"a\n"
"    script run by the . or source builtins finishes executing.  A "
"SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause "
"the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""
"Tangkap sinyal dan even lainnya.\n"
"    \n"
"    Definisikan dan aktivasi handlers yang harus dijalankan ketika shell "
"menerima sinyal\n"
"    atau kondisi lain.\n"
"    \n"
"    ARG perintah dibaca dan dijalankan ketika shell menerima\n"
"    sinyal SIGNAL_SPEC. Jika ARG tidak ada (dan sebuah sinyal SIGNAL_SPEC\n"
"    diberikan) atau `-', setiap sinyal yang dispesifikasikan akan direset "
"kenilai\n"
"    original. Jika ARG adalah string kosong untuk setiap SIGNAL_SPEC "
"diabaikan oleh\n"
"    shell dan oleh perintah yang dipanggil.\n"
"    \n"
"    Jika sebuah SIGNAL_SPEC adalah EXIT(0) perintah ARG dijalankan pada saat "
"keluar dari shell. Jika\n"
"    sebuah SIGNAL_SPEC adalah DEBUG, ARG dijalankan setiap perintah "
"sederhana.\n"
"    \n"
"    Jika tidak ada argumen yang diberikan, trap menampilkan daftar dari "
"perintah yang berasosiasi\n"
"    dengan setiap sinyal.\n"
"    \n"
"    Pilihan:\n"
"      -l\tmenampilkan sebuah daftar dari nama sinyal dan nomor yang "
"berhubungan\n"
"      -p\tmenampilkan perintah trap yang berasosiasi dengan setiap "
"SIGNAL_SPEC\n"
"    \n"
"    Setiap SIGNAL_SPEC yang ada di nama sinyal dalam <signal.h> atau nomor "
"sinyal. Nama sinyal\n"
"    adalah case insensitive dan SIG prefix adalah opsional. sebuah\n"
"    sinyal dapat dikirim ke sebuah shell dengan \"kill -signal $$\".\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah SIGSPEC adalah tidak valid atau "
"sebuah pilihan tidak valid diberikan."

#: builtins.c:1401
#, fuzzy
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""
"Tampilkan informasi tentang perintah yang diketik.\n"
"    \n"
"    Untuk setiap NAMA, indikasikan bagaimana ini akan diinterpretasikan jika "
"digunakan sebagai sebuah\n"
"    nama perintah.\n"
"    \n"
"    Pilihan:\n"
"      -a\tmenampilkan seluruh lokasi yang berisi sebuah nama NAMA yang dapat "
"dijalankan;\n"
"    \tmeliputi aliases, builtins, dan fungsi, jika dan hanya jika\n"
"    \tpilihan `-p' juga sedang tidak digunakan\n"
"      -f\tmenekan pencarian fungsi shell\n"
"      -P\tmemaksa sebuah JALUR pencarian untuk setiap NAMA, bahkan jika ini "
"adalah sebuah alias,\n"
"    \tbuiltin, atau fungsi, dan mengembalikan nama dari berkas disk\n"
"    \tyang akan dijalankan\n"
"      -p\tmengembalikan baik nama dari berkas disk yang akan dijalankan,\n"
"    \tatau tidak sama sekali jika `type -t NAME' akan mengembalikan "
"`berkas'.\n"
"      -t\tkeluarkan sebuah kata tunggal yang merupakan salah satu dari "
"`alias', `keyword',\n"
"    \t`fungsi', `builtin', `berkas', atau `', jika NAMA adalah sebuah alias, "
"shell\n"
"    \treserved word, fungsi shell, builtin shell, berkas disk, atau\n"
"    \ttidak ditemukan\n"
"    \n"
"    Argumen:\n"
"      NAMA\tNama perintah yang akan diinterpretasikan.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses jika seluruh dari NAMA ditemukan; gagal jika ada "
"yang tidak ditemukan."

#: builtins.c:1432
#, fuzzy
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Modifikasi batas sumber daya shell.\n"
"    \n"
"    memberikan kontrol terhadap sarana yang tersedia untuk proses\n"
"    yang dimulai oleh shell, dalam sistem yang mengijinkan untuk kontrol "
"tersebut.\n"
"    \n"
"    Pilihan:\n"
"        -S\tgunakan `soft' batas sarana\n"
"        -H\tgunakan `hard' batas sarana\n"
"        -a\tsemua batas ditampilkan\n"
"        -c\tukuram maksimum untuk berkas cores yang dibuat\n"
"        -d\tukuran maksimum untuk sebuah proses data segment\n"
"        -e\tprioritas antrian maksimum ('nice')\n"
"        -f\tukuran maksimum berkas yang ditulis oleh shell dan anaknya\n"
"        -l\tjumlah maksimum dari sinyal tertunda\n"
"        -m\tukuran maksimum dari resident\n"
"        -n\tjumlah maksimum dari berkas deskriptor yang terbuka\n"
"        -p\tukuran pipe buffer\n"
"        -q\tjumlah maksimum dari bytes dalam POSIX pesan antrian\n"
"        -r\tprioritas maksimum dari real-time scheduling\n"
"        -s\tukuran maksimum dari stack\n"
"        -t\tjumlah maksimum dari waktu cpu dalam detik\n"
"        -u\tjumlah maksimum dari proses pengguna\n"
"        -v\tukuran dari memori virtual\n"
"        -x\tjumlah maksimum dari berkas pengunci\n"
"    \n"
"    Jika BATAS diberikan, maka nilai baru yang dispesifikasikan untuk "
"sarana;\n"
"    nilai spesial LIMIT `soft', `hard', dan `unlimited' berarti untuk\n"
"    soft limit saat ini, jika hard limit saat ini dan no limit, "
"respectively.\n"
"    Jika tidak, nilai sekarang dari sarana yang dispesifikasikan "
"ditampilkan.\n"
"    Jika tidak ada pilihan yang diberikan, maka -f diasumsikan.\n"
"    \n"
"    Nilai adalah dalam 1024-byte increments, kecuali untuk -t, yang berarti "
"dalam detik\n"
"    -p, yang berarti increment dalam 512 bytes, dan -u, yang berarti "
"unscaled dari\n"
"    jumlah proses.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan atau "
"sebuah error terjadi."

#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Tampilkan atau set mask mode dari berkas.\n"
"    \n"
"    Set pembuatan berkas pengguna mask dengan MODE. Jika MODE diabaikan, "
"tampilkan\n"
"    nilai dari mask sekarang.\n"
"    \n"
"    Jika MODE diawali dengan sebuah digit, ini diinterpretasikan sebagai "
"sebuah bilangan oktal;\n"
"    jika tidak ini adalah sebuah mode simbolik seperti yang diterima oleh "
"chmod(1).\n"
"    \n"
"    Pilihan:\n"
"      -p\tjika MODE diabaikan, keluarkan dalam sebuah format yang bisa "
"digunakan sebagai masukan\n"
"      -S\tmembuat keluaran simbolik; jika tidak sebuah bilangan oktal adalah "
"keluarannya\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali MODE tidak valid atau sebuah pilihan tidak "
"valid diberikan."

#: builtins.c:1503
#, fuzzy
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or "
"a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of "
"IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns "
"its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, "
"before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Tunggu untuk penyelesaian pekerjaan dan kembalikan status keluar.\n"
"    \n"
"    Tunggu untuk proses yang diidentifikasikan oleh ID, yang mungkin sebuah "
"proses ID atau sebuah\n"
"    spesifikasi pekerjaan, dan laporkan status selesainya. Jika ID tidak\n"
"    diberikan, tunggu untuk seluruh proses anak yang aktif, dan status "
"kembalian\n"
"    adalah nol. Jika ID adalah sebuah spesifikasi pekerjaan, tunggu untuk "
"seluruh proses\n"
"    dalam pipeline pekerjaan.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status dari ID; gagal jika ID tidak valid atau sebuah "
"pilihan tidak\n"
"    valid diberikan."

#: builtins.c:1534
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination "
"status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an "
"invalid\n"
"    option is given."
msgstr ""
"Tunggu untuk penyelesaian proses dan kembalikan status keluar.\n"
"    \n"
"    Tunggu untuk proses yang dispesifikasikan dan laporkan status "
"selesainya. Jika\n"
"    PID tidak diberikan, maka semua aktif proses anak ditunggu,\n"
"    dan kode kembalian adalah nol. PID dapat berupa proses ID.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status dari ID; gagal jika ID tidak valid atau sebuah "
"pilihan tidak valid\n"
"    diberikan."

#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Jalankan perintah untuk setiap anggota dalam sebuah daftar.\n"
"    \n"
"    `for' loop menjalankan urutan dari perintah untuk setiap anggota dalam "
"sebuah\n"
"    daftar dari items. Jika `in KATA ...;' tidak ada, maka `in \"$@\"' yang\n"
"    menjadi asumsi. Untuk setiap elemen dalam KATA, NAMA di set untuk elemen "
"tersebut, dan\n"
"    PERINTAH dijalankan.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status dari perintah terakhir yang dijalankan."

#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Arithmetic untuk loop.\n"
"    \n"
"    Sama dengan\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tPERINTAH\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, dan EXP3 adalah expresi arithmetic. Jika setiap expresi\n"
"    diabaikan, ini berjalan seperti jika dievaluasi ke 1.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status dari perintah terakhir yang dijalankan."

#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Pilih kata dari sebuah daftar dan jalankan perintah.\n"
"    \n"
"    WORDS diexpand, menghasilkan daftar dari kata.\n"
"    set dari kata yang diexpand ditampilkan dalam standar error, setiap\n"
"    keluaran diawali dengan sebuah nomor. Jika `in WORDS' tidak ada, `in \"$@"
"\"'\n"
"    diasumsikan. Kemudian PS3 prompt ditampilkan dan sebuah baris dibaca\n"
"    dari standar masukan. Jika baris berisi dari nomor yang\n"
"    berhubungan dengan salah sata kata yang ditampilkan, maka NAMA diset\n"
"    ke WORD tersebut. Jika baris kosong, WORDS dan prompt\n"
"    ditampilkan kembali. Jika EOF dibaca, perintah selesai. Baris yang "
"dibaca disimpan\n"
"    dalam variabel REPLY. PERINTAH dijalankan setelah setiap seleksi\n"
"    sampai perintah break dijalankan.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status dari perintah terakhir yang dijalankan."

#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Melaporkan waktu yang dihabiskan dalam menjalan eksekusi pipeline.\n"
"    \n"
"    Jalankan PIPELINE dan tampilkan ringkasan dari real time, user CPU "
"time,\n"
"    dan sistem CPU time yang dihabiskan dalam menjalankan PIPELINE ketika "
"ini selesai.\n"
"    \n"
"    Pilihan:\n"
"      -p\tmenampilkan ringkasan waktu dalam format portable Posix\n"
"    \n"
"    Status Keluar:\n"
"    Status kembali adalah status kembali dari PIPELINE."

#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Menjalankan perintah berdasarkan pencocokan pola.\n"
"    \n"
"    Secara selektif menjalankan PERINTAH berdasarkan dari KATA yang cocok "
"dengan POLA.\n"
"    `|' digunakan untuk memisahkan beberapa pola.    \n"
"    Status Keluar:\n"
"    Mengembalikan setatus dari perintah terakhir yang dijalankan."

#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Menjalankan perintah berdasarkan kondisi.\n"
"    \n"
"    Daftar `if PERINTAH' dijalankan. Jika ini memberikan status keluaran "
"nol, maka\n"
"    daftar `then PERINTAH' dijalankan. Jika tidak, setiap daftar dari `elif "
"PERINTAH'    \n"
"    dijalankan satu satu, dan jika ini memberikan status keluaran nol, untuk "
"setiap\n"
"    daftar dari `then PERINTAH' yang dijalankan maka perintah `if' selesai. "
"Jika tidak,\n"
"    daftar `else PERINTAH' dijalankan, jika ada. Status keluaran dari    \n"
"    seluruh construct adalah status keluaran dari perintah terakhir yang "
"dijalankan, atau nol\n"
"    jika tidak ada kondisi yang diperiksa benar.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status dari perintah terakhir yang dijalankan."

#: builtins.c:1648
#, fuzzy
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Menjalankan perintah sepanjang pemeriksaan sukses.\n"
"    \n"
"    Expand dan jalankan PERINTAH sepanjang akhir perintah dari\n"
"    PERINTAH `while' telah memberikan status keluaran nol.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status dari perintah terakhir yang dijalankan."

#: builtins.c:1660
#, fuzzy
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Menjalankan perintah sepanjang pemeriksaan tidak sukses.\n"
"    \n"
"    Expand dan jalankan PERINTAH sepanjang akhir perintah dari\n"
"    PERINTAH `until' telah memberikan status keluaran bukan nol.    \n"
"    Status Keluar:\n"
"    Mengembalikan status dari perintah terakhir yang dijalankan."

#: builtins.c:1672
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Buat sebuah koproses dengan nama NAMA.\n"
"    \n"
"    Jalankan PERINTAH secara tidak sinkron, dengan standar keluaran dan\n"
"    standar masukan dari perintah terhubung melalui sebuah pipa berkas\n"
"    pipa deskripsi yang ditandai dengan 0 dan 1 dari sebuah susunan NAMA\n"
"    variabel dalam shell yang dijalankan.\n"
"    Nama baku adalah \"COPROC\".\n"
"    \n"
"    Status Keluar:\n"
"    Perintah coproc mengembalikan status keluar 0."

#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Definisikan fungsi shell.\n"
"    \n"
"    Buat sebuah fungsi shell dengan nama NAMA. Ketika dipanggil sebagai "
"sebuah perintah sederhana,\n"
"    NAMA menjalankan PERINTAH dalam context shell pemanggil. Ketika NAMA "
"dipanggil,\n"
"    argumen dilewatkan ke fungsi sebagai $1...$n, dan nama fungsi\n"
"    dalam $FUNCNAME.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali NAMA adalah baca-saja."

#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Grup perintah sebagai sebuah unit.\n"
"    \n"
"    Jalankan sebuah set dari perintah dalam grup. Ini adalah salah satu cara "
"untuk meredirect\n"
"    seluruh set dari perintah.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status dari perintah terakhir yang dieksekusi."

#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Melanjutkan pekerjaan dalam foreground.\n"
"    \n"
"    Sama dengan JOB_SPEC argumen untuk perintah `fg'. Melanjutkan sebuah\n"
"    pekerjaan yang telah berhenti atau menjadi background. JOB_SPEC dapat "
"dispesifikasikan dengan nama job\n"
"    atau nomor job. JOB_SPEC diikuti dengan sebuah `&' menempatkan job "
"dalam\n"
"    background, seperti dalam spesifikasi pekerjaan yang telah "
"dispesifikasikan sebagai sebuah\n"
"    argumen untuk `bg'.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan status dari pekerjaan yang dilanjutkan."

#: builtins.c:1727
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Evaluasi ekspresi arithmetic.\n"
"    \n"
"    EXPRESI dievaluasi berdasarkan dalam aturan evaluasi\n"
"    arithmetic. Sama dengan `let \"EXPRESI\"'.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan 1 jika EXPRESI dievaluasi ke 0; mengembalikan 0 jika tidak."

#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Menjalankan perintah kondisional.\n"
"    \n"
"    Mengembalikan sebuah status dari 0 atau 1 tergantung dari evaluasi dari\n"
"    kondisi expresi EXPRESI. Expresi disusun dari primari yang sama dari "
"yang digunakan\n"
"    oleh `test' builtin, dan boleh dikombinasikan dengan menggunakan "
"operator berikut\n"
"    \n"
"      ( EXPRESI )\tMengembalikan nilai dari EXPRESI\n"
"      ! EXPRESI\t\tBenar jika kedua EXPR1 dan EXPR2 adalah benar; selain itu "
"salah\n"
"      EXPR1 && EXPR2\tBenar jika kedua EXPR1 dan EXPR2 adalah benar; selain "
"itu salah\n"
"      EXPR1 || EXPR2\tBenar jika salah satu EXPR1 atau EXPR2 adalah benar; "
"selain itu salah\n"
"    \n"
"    Ketika operator `==' dan `!=' digunakan, string yang disebelah kanan "
"dari     \n"
"    operator yang digunakan sebagai sebuah pola dan pencocokan pola "
"dilakukan.\n"
"    Ketika operator `=~' digunakan, string yang dikanan dari operator\n"
"    dicocokan sebagai sebuah ekspresi regular.\n"
"    \n"
"    Operator && dan || tidak mengevaluasi EXPR2 jika EXPR1 tidak mencukupi "
"untuk\n"
"    menentukan nilai dari expresi.\n"
"    \n"
"    Status Keluar:\n"
"    0 atau 1 tergantun dari nilai dari EKSPRESI."

#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Nama variabel shell umum dan penggunaannya.\n"
"    \n"
"    BASH_VERSION\tInformasi versi dari Bash ini.\n"
"    CDPATH\tSebuah daftar yang dipisahkan oleh titik dua dari direktori "
"untuk mencari\n"
"    \t\tdirektori yang diberikan sebagai argumen untuk `cd'.\n"
"    GLOBIGNORE\tSebuah daftar pola yang dipisahkan dengan titik dua "
"menjelaskan nama berkas yang\n"
"    \t\tdiabaikan oleh pathname expansion.\n"
"    HISTFILE\tNama dari berkas dimana sejara perintah anda disimpan.\n"
"    HISTFILESIZE\tJumlah maksimum dari baris dimana berkas ini berisi.\n"
"    HISTSIZE\tJumlah maksimum dari baris sejarah yang sedang berjalan\n"
"    \t\tketika shell sedang menaksesnya.\n"
"    HOME\tNama jalur lengkap ke direktori login anda.\n"
"    HOSTNAME\tNama dari host saat ini.\n"
"    HOSTTYPE\tTipe dari CPU dari veri Bash yang sedang berjalan.\n"
"    IGNOREEOF\tKendalikan aksi dari shell ketika menerima sebuah EOF\n"
"    \t\tkarakter sebagai masukan. Jika diset, maka nilai\n"
"    \t\tdari jumlah karakter EOF yang bisa diterima\n"
"    \t\tdalam sebuah baris dalam baris kosong sebelum shell keluar\n"
"    \t\t(default 10). Ketika diunset, EOF menandakan akhir dari masukan.\n"
"    MACHTYPE\tSebuah kata yang menjelaskan system yang berjalan ketika Bash "
"berjalan.\n"
"    MAILCHECK\tSeberapa sering, dalam detik, Bash memeriksa pesan baru.\n"
"    MAILPATH\tDaftar dari nama berkas yang dipisahkan oleh titik-dua dimana "
"Bash memeriksa\n"
"    \t\tpesan baru.\n"
"    OSTYPE\tVersi Unix dari Versi Bash yang sedang berjalan.\n"
"    PATH\tDaftar direktori yang dipisahkan oleh titik-dua untuk mencari "
"ketika\n"
"    \t\tmencari perintah.\n"
"    PROMPT_COMMAND\tSebuah perintah yang dijalankan sebelum menampilkan "
"setiap\n"
"    \t\tmasukan utama.\n"
"    PS1\t\tKata prompt utama.\n"
"    PS2\t\tKata prompt kedua.\n"
"    PWD\t\tNama jalur lengkat dari direktori sekarang.\n"
"    SHELLOPTS\tDaftar dari shell pilihan yang dipisahkan oleh titik-dua.\n"
"    TERM\tNama dari tipe terminal sekarang.\n"
"    TIMEFORMAT\tFormat keluaran dari statistik waktu yang ditampilkan oleh\n"
"    \t\t`time' kata yang direserved.\n"
"    auto_resume\tTidak kosong berarti sebuah kata perintah akan munncul di "
"sebuah baris dengan\n"
"    \t\tsendirinya adalah pertama dicari dalam daftar dari\n"
"    \t\tpekerjaan yang terhenti sekarang. Jika ditemukan disana, maka "
"pekerjaan intu di foregroundkan.\n"
"    \t\tNila dari  `exact' berarti kata perintah harus\n"
"    \t\tcocok secara tepat dalam daftar  dari pekerjaan yang terhenti. "
"Sebuah\n"
"    \t\tNila dari `substring' berarti bahwa kata perintah harus cocok\n"
"    \t\tdengan substring dari pekerjaan. Nilai yang lain berarti\n"
"    \t\tperintah harus diawali dari sebuah pekerjaan yang terhenti.\n"
"    histchars\tKarakter pengendali history expansion dan pensubstitusi\n"
"    \t\tcepat. Karakter pertama adalah karakter\n"
"    \t\tpengganti sejarah, biasanya `!'. Karakter kedua\n"
"    \t\tdari `quick substitution', biasanya `^'. Karakter\n"
"    \t\tketiga adalah karakter `history comment'. biasanya `#',\n"
"    HISTIGNORE\tSebuah daftar pola yang dipisahkan oleh titik dua yang "
"digunakan untuk menentukan dimana\n"
"    \t\tperintah seharusnya disimpan dalam daftar sejarah.\n"

#: builtins.c:1822
#, fuzzy
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Menambahkan direktori ke stack.\n"
"    \n"
"    Menambahkan sebuah direktori ke top dari direktori stack, atau merotasi\n"
"    stack, membuah top baru dari stack dari working direktori saat ini.\n"
"    Tanpa argumen, menukar top dari dua direktori.\n"
"    \n"
"    Pilihan:\n"
"    -n\tmenekan perubahan normal dari direktori ketika menambahkan "
"direktori\n"
"    \tke stack, jadi hanya stack yang dimanipulasi.\n"
"    \n"
"    Argumen:\n"
"    +N\tMerotasi stack sehingga direktori ke N (dihitung\n"
"    \tdari kiri dari daftar yang terlihat oleh `dirs', dimulai dengan\n"
"    \tnol) adalah di top.\n"
"    \n"
"    -N\tMerotasi stack sehingga direktori ke N (dihitung\n"
"    \tdari kanan dari daftar yang terliha oleh `dirs', dimulai dengan\n"
"    \tnol) adalah di top.\n"
"    \n"
"    dir\tenambahkan DIR ke direktori stack di puncak, membuatnya\n"
"    \tdirektori kerja sekarang.\n"
"    \n"
"    Builtin `dirs' menampilkan direktori stack.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali ada sebuah argumen tidak valid diberikan "
"atau pemindahan\n"
"    direktori gagal."

#: builtins.c:1856
#, fuzzy
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Hapus direktori dari stack.\n"
"    \n"
"    Manghapus masukan dalam direktori stack. Tanpa argumen,\n"
"    menghapus top direktori dari stack, dan cd's ke top\n"
"    direktori baru.\n"
"    \n"
"    Pilihan:\n"
"      -n\tmenekan perubahan normal dari direktori ketika menghapus "
"direktori\n"
"    \tdari stack, jadi hanya stack yang dimanipulasi.\n"
"    \n"
"    Argumen:\n"
"      +N\tmenghapus masukan ke N dihitung dari kiri dari daftar\n"
"    \tyang ditampilkan oleh `dirs', dimulai dari nol. Sebagai contoh: `popd "
"+0'\n"
"    \tmenghapus direktori terakhir, `popd +1' sebelum terakhir.\n"
"    \n"
"      -N\tmenghapus masukan ke N dihitung dari kanan dari daftar\n"
"    \tyang ditampilkan oleh `dirs', dimulai dari nol. Sebagai contoh: `popd "
"-0'\n"
"    \tmenghapus direktori terakhir, `popd -1' sebelum terakhir.\n"
"    \n"
"    Builtin `dirs' menampilkan direktori stack.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali ada sebuah argumen tidak valid diberikan "
"atau pemindahan\n"
"    direktori gagal."

#: builtins.c:1886
#, fuzzy
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Menampilkan direktori stack.\n"
"    \n"
"    Menampilkan daftar dari direktori yang diingat saat ini. Direktori\n"
"    menemukan jalannya kedalam daftar dengan perintah `pushd'; anda dapat "
"memperoleh\n"
"    backup melalui daftar dengan perintah `popd'.\n"
"    \n"
"    Pilihan:\n"
"      -c\tmenghapus direktori stack dengan menghapus seluruh elemen.\n"
"      -l\tjangan menampilkan versi yang diawali tilde dari direktori yang "
"relatif\n"
"    \tke direktori rumah anda\n"
"      -p\tmenampilkan direktori stack dengan satu masukan setiap baris\n"
"      -v\tmenampilkan direktori stack dengan satu masukan setiap baris "
"diawali\n"
"    \tdengan posisinya dalam stack\n"
"    Argumen:\n"
"      +N\tmenampilkan masukan ke N dihitung dari kiri dari daftar yang "
"ditampilkan oleh\n"
"    \tdirs ketika dijalankan tanpa pilihan, dimulai dari nol.\n"
"    \n"
"      -N\tmenampilkan masukan ke N dihitung dari kanan dari daftar yang "
"ditampilkan oleh\n"
"    \tdirs ketika dijalankan tanpa pilihan, dimulai dari nol.    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali ada sebuah pilihan tidak valid diberikan "
"atau sebuah error terjadi."

#: builtins.c:1917
#, fuzzy
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Set dan unset pilihan shell.\n"
"    \n"
"    Ubah setting untuk setiap pilihan shell OPTNAME. Tanpa pilihan\n"
"    argumen apapun, tampilkan daftar shell pilihan dengan sebuah indikasi\n"
"    ya atau tidak setiap pilihan di set.\n"
"    \n"
"    Pilihan:\n"
"      -o\tbatasi OPTNAME ke definisi untuk digunakan dengan `set -o'\n"
"      -p\ttampilkan setiap pilihan shell dengan sebuah indikasi dari "
"statusnya\n"
"      -q\ttekan keluaran\n"
"      -s\taktifkan (set) setiap OPTNAME\n"
"      -u\tnonaktifkan (unset) setiap OPTNAME\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses jika OPTNAME diaktifkan; gagal jika sebuah pilihan "
"tidak valid diberikan\n"
"    atau OPTNAME dinonaktifkan."

#: builtins.c:1938
#, fuzzy
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in "
"printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a "
"format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as "
"appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""
"Format dan tampilkan ARGUMEN dalam kontrol dari FORMAT.\n"
"    \n"
"    Pilihan:\n"
"      -v var\tkeluaran ditempatkan dalam sebuah nilai dari variabel\n"
"    shell VAR daripada dikirimkan ke keluaran standar.\n"
"    \n"
"    FORMAT adalah sebuah karakter string yang berisi dari tiga tipe dari "
"objects: plain\n"
"    karakter, yang disalin secara sederhana dari keluaran standar, karakter "
"escape\n"
"    sequences yang mengubah dan menyalin keluaran standar, dan\n"
"    spesifikasi format, yang selalu menampilkan  argumen\n"
"    \n"
"    Tambahan dari spesifikasi standar printf(1) formats dan\n"
"    printf(3), printf menginterprestasikan:\n"
"    \n"
"      %b berarti untuk menexpand backslash escape sequences dalam argumen "
"yang sesuai\n"
"      %q berarti meng-quote argumen dalam sebuah cara yang dapat digunakan "
"sebagai masukan shell.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan atau "
"sebuah penulisan atau penempatan\n"
"    error terjadi."

#: builtins.c:1974
#, fuzzy
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are "
"supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -"
"I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Spesifikasikan bagaimana argumen akan diselesaikan oleh Readline.\n"
"    \n"
"    Untuk setiap NAMA, spesifikasikan bagaimana argumen akan diselesaikan. "
"Jika tidak ada pilihan\n"
"    yang diberikan, spesifikasi penyelesaian yang sudah ada akan ditampilkan "
"dalam cara\n"
"    yang diperbolehkan untuk digunakan sebagai masukan.\n"
"    \n"
"    Pilihan:\n"
"      -p\ttampilkan spesifikasi penyelesaian yang telah ada dalam format "
"yang berguna\n"
"      -r\thapus sebuah spesifikasi penyelesaian untuk setiap NAMA, atau jika "
"tidak ada\n"
"    \tNAMA yang diberikan, seluruh spesifikasi penyelesaian\n"
"      -D\taplikasikan pelengkapan dan aksi sebagai perintah baku tanpa "
"pelengkapan\n"
"    \tspesifik yang didefinisikan\n"
"      -E\taplikasikan pelengkapan dan aksi ke perintah \"empty\" --\n"
"    \tpelengkapan dilakukan di baris kosong\n"
"    \n"
"    Ketika penyelesaian dicoba, aksi yang dilakukan dalam urutan\n"
"    huruf besar pilihan yang ditampilkan diatas.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan atau "
"sebuah error terjadi."

#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Menampilkan kemungkinan penyelesaian tergantung dari pilihan.\n"
"    \n"
"    Ditujukan  untuk digunakan dari dalam sebuah fungsi shell yang "
"menghasilkan kemungkinan untuk completions.\n"
"    Jika argumen WORD opsional yang diberikan, cocok dengan WORD telah\n"
"    dihasilkan.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan atau "
"sebuah error terjadi."

#: builtins.c:2019
#, fuzzy
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Modifikasi atau tampilkan pilihan penyelesaian.\n"
"    \n"
"    Modifikasi pilihan penyelesaian untuk setiap NAMA, atau, jika tidaka ada "
"NAMA yang diberikan,\n"
"    penyelesaian mulai dijalankan. Jika tidak ada OPSI yang diberikan, "
"tampilkan\n"
"    pilihan penyelesaian untuk setiap NAMA atau spesifikasi penyelesaian "
"sekarang.\n"
"    \n"
"    Pilihan:\n"
"    \t-o option\tSet pilihan penyelesaian OPSI untuk setiap NAMA\n"
"    \t-D\t\tUbah pilihan untuk perintah pelengkapan \"default\"\n"
"    \t-E\t\tUbah pilihan untuk perintah pelengkapan \"empty\"\n"
"    \n"
"    Gunakan `+o' daripada `-o' matikan pilihan yang dispesifikasikan.\n"
"    \n"
"    Argumen:\n"
"    \n"
"    Setiap NAMA yang dirujuk dalam sebuah perintah untuk sebuah spesifikasi "
"penyelesaian harus\n"
"    sebelumnya telah didefinisikan dengan menggunakan builtin `complete'. "
"Jika tidak ada NAMA\n"
"    yang diberikan, compopt harus dipanggil oleh sebuah fungsi yang dibuat "
"oleh penyelesaian sekarang,\n"
"    dan pilihan untuk menjalankan penyelesaian sekarang\n"
"    telah dimodifikasi.\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan atau "
"NAMA tidak memiliki\n"
"    spesifikasi penyelesaian yang terdefinisi."

#: builtins.c:2050
#, fuzzy
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable "
"ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable "
"MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard "
"input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly "
"or\n"
"    not an indexed array."
msgstr ""
"Baca baris dari standar masukan kedalam sebuah susunan variabel.\n"
"    \n"
"    Baca baris dari standar masukan kedalam variabel array ARRAY, atau dari\n"
"    berkas deskripsi FD jika pilihan -u diberikan. Variabel MAPFILE adalah\n"
"    ARRAY baku.\n"
"    \n"
"    Pilihan:\n"
"      -n count\tSalin di baris COUNT. Jika COUNT adalah 0, semua baris "
"disalin.\n"
"      -O origin\tAwal penempatan ke ARRAY di index ORIGIN. Indeks baku "
"adalah 0.\n"
"      -s count \tAbaikan baris COUNT pertama yang dibaca.\n"
"      -t\t\tHapus sebuah akhiran baris baru dari setiap baris yang dibaca.\n"
"      -u fd\t\tBaca baris dari berkas deskripsi FD daripada dari masukan "
"standar.\n"
"      -C callback\tEvaluasi CALLBACK untuk setiap waktu QUANTUM baris adalah "
"baca.\n"
"      -c quantum\tSpesifikasikan jumlah dari baris yang dibaca diantara "
"setiap pemanggilan ke CALLBACK.\n"
"    \n"
"    Argumen:\n"
"      ARRAY\t\tNama variabel array yang digunakan untuk berkas data.\n"
"    \n"
"    Jika -C Diberikan tanpa -c, default quantum adalah 5000. Ketika "
"CALLBACK\n"
"    dievaluasi , ini diberikan ke indeks dari element 'array' selanjutnya\n"
"    untuk di-'assign' sebagai sebuah argumen tambahan.\n"
"    \n"
"    Jika tidak diberikan dengan asal secara eksplisit, berkas peta akan "
"menghapus ARRAY sebelum\n"
"    ditempatkan kepadanya\n"
"    \n"
"    Status Keluar:\n"
"    Mengembalikan sukses kecuali sebuah pilihan tidak valid diberikan atau "
"ARRAY adalah baca-saja."

#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Baca baris dari sebuah berkas kedalam sebuah susunan variabel.\n"
"    \n"
"    Sebuah sinonim untuk `mapfile'."

#, c-format
#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: kunci array assosiasi tidak valid"

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns "
#~ msgstr ""
#~ "Mengembalikan konteks dari panggilan subroutine saat ini.\n"
#~ "    \n"
#~ "    Tanpa EXPR, kembali "

#~ msgid "add_process: process %5ld (%s) in the_pipeline"
#~ msgstr "add_process: process %5ld (%s) dalam the_pipeline"

#~ msgid "Unknown Signal #"
#~ msgstr "Sinyal tidak diketahui #"

#~ msgid "Copyright (C) 2013 Free Software Foundation, Inc."
#~ msgstr "Hak Cipta (C) 2013 Free Software Foundation, Inc."

#~ msgid ":"
#~ msgstr ":"

#~ msgid "true"
#~ msgstr "benar"

#~ msgid "false"
#~ msgstr "salah"

#~ msgid "times"
#~ msgstr "kali"

#~ msgid ""
#~ ".  With EXPR, returns\n"
#~ "    "
#~ msgstr ""
#~ ".  Dengan EXPR, kembali\n"
#~ "    "

#~ msgid ""
#~ "; this extra information can be used to\n"
#~ "    provide a stack trace.\n"
#~ "    \n"
#~ "    The value of EXPR indicates how many call frames to go back before "
#~ "the\n"
#~ "    current one; the top frame is frame 0."
#~ msgstr ""
#~ "; informasi tambahan ini dapat digunakan untuk\n"
#~ "    menyediakan penelusuran 'stack'.\n"
#~ "    \n"
#~ "    Nilai dari EXPR mengindikasikan berapa banyak panggilan 'frame' untuk "
#~ "kembali\n"
#~ "    sebelum saat ini; 'frame' paling atas adalah 'frame' 0."

#~ msgid "Copyright (C) 2009 Free Software Foundation, Inc.\n"
#~ msgstr "Hak Cipta (C) 2009 Free Software Foundation, Inc.\n"

#~ msgid ""
#~ "License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl."
#~ "html>\n"
#~ msgstr ""
#~ "Lisensi GPLv2+: GNU GPL versi 2 atau sesudahnya <http://gnu.org/licenses/"
#~ "gpl.html>\n"

#~ msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr ""
#~ "xrealloc: tidak dapat menrealokasikan %lu bytes (%lu bytes teralokasikan)"

#~ msgid "xrealloc: cannot allocate %lu bytes"
#~ msgstr "xrealloc: tidak dapat mengalokasikan %lu bytes"

#~ msgid "xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr ""
#~ "xrealloc: %s: %d: tidak dapat melakukan reallokasi %lu bytes (%lu bytes "
#~ "teralokasi)"

#~ msgid " "
#~ msgstr " "

#~ msgid "Without EXPR, returns returns \"$line $filename\".  With EXPR,"
#~ msgstr ""
#~ "Tanpa EXPR, mengembalikan kembalian \"$line $filename\". Dengan EXPR,"

#~ msgid "returns \"$line $subroutine $filename\"; this extra information"
#~ msgstr ""
#~ "mengembalikan \"$line $subroutine $filename\"; informasi tambahan ini"

#~ msgid "can be used used to provide a stack trace."
#~ msgstr "dapat digunakan untuk menyediakan jejak sebuah stack."

#~ msgid ""
#~ "The value of EXPR indicates how many call frames to go back before the"
#~ msgstr ""
#~ "Nilai dari EXPR mengindikasikan berapa banyak call frames untuk kembali "
#~ "sebelum"

#~ msgid "current one; the top frame is frame 0."
#~ msgstr "salah satu ini; top frame adalah frame 0."

#~ msgid "%s: invalid number"
#~ msgstr "%s: nomor invalid"

#~ msgid "Shell commands matching keywords `"
#~ msgstr "Perintah shell cocok dengan kata kunci `"

#~ msgid "Display the list of currently remembered directories.  Directories"
#~ msgstr "Tampilkan daftar dari direktori yang diingat sekarang. Direktori"

#~ msgid "find their way onto the list with the `pushd' command; you can get"
#~ msgstr ""
#~ "menemukan jalannya sendiri kedalam daftar dengan perintah `pushd'; anda "
#~ "dapat memperoleh"

#~ msgid "back up through the list with the `popd' command."
#~ msgstr "bantuan melalui daftar dari perintah `popd'."

#~ msgid ""
#~ "The -l flag specifies that `dirs' should not print shorthand versions"
#~ msgstr ""
#~ "Flag -l menspesifikasikan bahwa `dirs' seharusnya tidak menampilkan versi "
#~ "pendek"

#~ msgid ""
#~ "of directories which are relative to your home directory.  This means"
#~ msgstr "dari direktori yang relatif dari direktori home anda. Ini berarti"

#~ msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
#~ msgstr ""
#~ "bahwa `~/bin' mungkin ditampilkan sebagai `/homes/bfox/bin'. Pilihan -v"

#~ msgid "causes `dirs' to print the directory stack with one entry per line,"
#~ msgstr ""
#~ "menyebabkan `dirs' ditampilkan di stack direktori dengan satu masukan per "
#~ "baris,"

#~ msgid ""
#~ "prepending the directory name with its position in the stack.  The -p"
#~ msgstr "mendahului nama direktori dengan posisinya dalam stack. Pilihan -p"

#~ msgid "flag does the same thing, but the stack position is not prepended."
#~ msgstr "melakukan hal yang sama, tetapi posisi stack tidak didahului."

#~ msgid ""
#~ "The -c flag clears the directory stack by deleting all of the elements."
#~ msgstr ""
#~ "Pilihan -c menghapus direktori stack dengan cara menghapus seluruh elemen."

#~ msgid ""
#~ "+N   displays the Nth entry counting from the left of the list shown by"
#~ msgstr ""
#~ "+N   menampilkan masukan ke N dihitung dari kiri dari daftar yang "
#~ "ditampilkan oleh"

#~ msgid "     dirs when invoked without options, starting with zero."
#~ msgstr "     dirs ketika dipanggil tanpa pilihan, dimulai dengan nol."

#~ msgid ""
#~ "-N   displays the Nth entry counting from the right of the list shown by"
#~ msgstr ""
#~ "-N   menampilkan masukan ke N dihitung dari kanan dari daftar yang "
#~ "ditampilkan dengan"

#~ msgid "Adds a directory to the top of the directory stack, or rotates"
#~ msgstr ""
#~ "menambahkan sebuah direktori ke ujung atas dari direktori stack, atau "
#~ "memutar"

#~ msgid "the stack, making the new top of the stack the current working"
#~ msgstr "stack, membuat sebuah top baru dari stack direktori yang dipakai"

#~ msgid "directory.  With no arguments, exchanges the top two directories."
#~ msgstr "saat ini. Tanpa argumen, menukar top dari dua direktori."

#~ msgid "+N   Rotates the stack so that the Nth directory (counting"
#~ msgstr "+N   Memutar stack sehingga direktori ke N (dihitung"

#~ msgid "     from the left of the list shown by `dirs', starting with"
#~ msgstr ""
#~ "     dari kiri dari daftar yang ditampilkan oleh `dirs', dimulai dari"

#~ msgid "     zero) is at the top."
#~ msgstr "     nol) ini dilakukan di top."

#~ msgid "-N   Rotates the stack so that the Nth directory (counting"
#~ msgstr "-N   Memutar stact sehingga direktori ke N (dihitung"

#~ msgid "     from the right of the list shown by `dirs', starting with"
#~ msgstr ""
#~ "     dari kanan dari daftar yang ditampilkan oleh `dirs', dimulai dengan"

#~ msgid "-n   suppress the normal change of directory when adding directories"
#~ msgstr ""
#~ "-n   menekan perubahan normal dari direktori ketika menambahkan direktori"

#~ msgid "     to the stack, so only the stack is manipulated."
#~ msgstr "     ke stack, jadi hanya stack yang dimanipulasi."

#~ msgid "dir  adds DIR to the directory stack at the top, making it the"
#~ msgstr "dir  menambahkan DIR ke direktori stack di top, membuatnya "

#~ msgid "     new current working directory."
#~ msgstr "     menjadi direktori baru untuk bekerja."

#~ msgid "You can see the directory stack with the `dirs' command."
#~ msgstr "Anda dapat melihat direktori stack dengan perintah `dirs'."

#~ msgid "Removes entries from the directory stack.  With no arguments,"
#~ msgstr "Hapus masukan dari direktori stack. Tanpa argumen,"

#~ msgid "removes the top directory from the stack, and cd's to the new"
#~ msgstr "menghapus top direktori dari stack, dan pindah ke"

#~ msgid "+N   removes the Nth entry counting from the left of the list"
#~ msgstr "+N   menghapus masukan ke-N dihitung dari kiri dari daftar"

#~ msgid "     shown by `dirs', starting with zero.  For example: `popd +0'"
#~ msgstr "     yang terlihat oleh `dirs', dimulai dari nol. Contoh: `popd +0'"

#~ msgid "     removes the first directory, `popd +1' the second."
#~ msgstr "     menghapus direktori pertama, `popd +1' kedua."

#~ msgid "-N   removes the Nth entry counting from the right of the list"
#~ msgstr "-N   menghapus masukan ke N dihitung dari kanan dari daftar"

#~ msgid "     shown by `dirs', starting with zero.  For example: `popd -0'"
#~ msgstr "     yang terlihat oleh `dirs', dimulai dari nol. Contoh: `popd -0'"

#~ msgid "     removes the last directory, `popd -1' the next to last."
#~ msgstr ""
#~ "     menghapus direktori terakhir, `popd -1' selanjutnya ke terakhir."

#~ msgid ""
#~ "-n   suppress the normal change of directory when removing directories"
#~ msgstr ""
#~ "-n   menekan perubahan normal dari direktori ketika menghapus direktori"

#~ msgid "     from the stack, so only the stack is manipulated."
#~ msgstr "     dari stack, sehingga hanya stack yang dimanipulasi."

#~ msgid "allocated"
#~ msgstr "teralokasi"

#~ msgid "freed"
#~ msgstr "terbebaskan"

#~ msgid "requesting resize"
#~ msgstr "meminta resize"

#~ msgid "just resized"
#~ msgstr "just resized"

#~ msgid "bug: unknown operation"
#~ msgstr "bug: operasi tidak diketahui"

#~ msgid "malloc: watch alert: %p %s "
#~ msgstr "malloc: watch alert: %p %s "

#~ msgid ""
#~ "Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,\n"
#~ "    break N levels."
#~ msgstr ""
#~ "Keluar dari dalam sebuah FOR, WHILE, atau UNTIL loop. jika N "
#~ "dispesifikasikan,\n"
#~ "    break N levels."

#~ msgid ""
#~ "Run a shell builtin.  This is useful when you wish to rename a\n"
#~ "    shell builtin to be a function, but need the functionality of the\n"
#~ "    builtin within the function itself."
#~ msgstr ""
#~ "Jalankan sebuah builtin shell. Ini akan  berguna ketika anda mengharapkan "
#~ "untuk mengganti nama sebuah\n"
#~ "    shell builting ke sebuah fungsi, tetapi membutuhkan sebuah "
#~ "fungsionalitas dari\n"
#~ "    sebuah fungsi builtin itu sendiri."

#~ msgid ""
#~ "Print the current working directory.  With the -P option, pwd prints\n"
#~ "    the physical directory, without any symbolic links; the -L option\n"
#~ "    makes pwd follow symbolic links."
#~ msgstr ""
#~ "Tampilkan direktori yang sedang digunakan saat ini. Dengan pilihan -P, "
#~ "pwd menampilkan\n"
#~ "    direktori physical, tanpa symbolic link yang lain; dengan pilihan -L\n"
#~ "    membuat pwd mengikuti symbolic links."

#~ msgid "Return a successful result."
#~ msgstr "Mengembalikan sebuah kembalian yang sukses."

#~ msgid ""
#~ "Runs COMMAND with ARGS ignoring shell functions.  If you have a shell\n"
#~ "    function called `ls', and you wish to call the command `ls', you can\n"
#~ "    say \"command ls\".  If the -p option is given, a default value is "
#~ "used\n"
#~ "    for PATH that is guaranteed to find all of the standard utilities.  "
#~ "If\n"
#~ "    the -V or -v option is given, a string is printed describing "
#~ "COMMAND.\n"
#~ "    The -V option produces a more verbose description."
#~ msgstr ""
#~ "Menjalankan PERINTAH dengan ARGS mengabaikan fungsi shell. Jika anda "
#~ "memiliki sebuah shell\n"
#~ "    fungsi yang memanggil `ls', dan anda berharap untuk memanggil "
#~ "perintah `ls', anda dapat\n"
#~ "    mengatakan \"command ls\". Jika pilihan -p diberikan, sebuah nilai "
#~ "default digunakan\n"
#~ "    untuk PATH yang menjamin untuk mencari semua utilitis standar. Jika\n"
#~ "    pilihan -V atau -v diberikan, sebuah string ditampilkan "
#~ "mendeskripsikan PERINTAH.\n"
#~ "    Pilihan -V menghasilkan deskripsi yang lebih detail."

#~ msgid ""
#~ "Declare variables and/or give them attributes.  If no NAMEs are\n"
#~ "    given, then display the values of variables instead.  The -p option\n"
#~ "    will display the attributes and values of each NAME.\n"
#~ "    \n"
#~ "    The flags are:\n"
#~ "    \n"
#~ "      -a\tto make NAMEs arrays (if supported)\n"
#~ "      -f\tto select from among function names only\n"
#~ "      -F\tto display function names (and line number and source file name "
#~ "if\n"
#~ "    \tdebugging) without definitions\n"
#~ "      -i\tto make NAMEs have the `integer' attribute\n"
#~ "      -r\tto make NAMEs readonly\n"
#~ "      -t\tto make NAMEs have the `trace' attribute\n"
#~ "      -x\tto make NAMEs export\n"
#~ "    \n"
#~ "    Variables with the integer attribute have arithmetic evaluation (see\n"
#~ "    `let') done when the variable is assigned to.\n"
#~ "    \n"
#~ "    When displaying values of variables, -f displays a function's name\n"
#~ "    and definition.  The -F option restricts the display to function\n"
#~ "    name only.\n"
#~ "    \n"
#~ "    Using `+' instead of `-' turns off the given attribute instead.  "
#~ "When\n"
#~ "    used in a function, makes NAMEs local, as with the `local' command."
#~ msgstr ""
#~ "Declare variabel dan/atau memberikan atribut kepada mereka. Jika tidak "
#~ "ada NAMA yang\n"
#~ "    diberikan, maka menampilkan nilai dari variabel. Pilihan -p\n"
#~ "    akan menampilkan atribut dan nilai dari setiap NAMA.\n"
#~ "    \n"
#~ "    Flags adalah:\n"
#~ "    \n"
#~ "      -a\tuntuk membuat aray NAMA (jika disupport)\n"
#~ "      -f\tuntuk memilih dari nama fungsi saja\n"
#~ "      -F\tuntuk menampilkan nama fungsi (dan nomor baris dan source nama "
#~ "file jika\n"
#~ "     \tdebugging) tanpa definisi\n"
#~ "      -i\tuntuk membuat NAMA memiliki atribut `integer'\n"
#~ "      -r\tuntuk membuat NAMA baca-saja\n"
#~ "      -t\tuntuk membuat NAMA memiliki atribut `trace'\n"
#~ "      -x\tuntuk membuat NAME export\n"
#~ "     \n"
#~ "     Variabel dengan atribut integer memiliki arithmetic evaluasi (lihat\n"
#~ "     `let') selesai ketika variabel diberikan ke.\n"
#~ "     \n"
#~ "     Ketika menampilkan nilai dari variabel, -f menampilkan sebuah nama "
#~ "fungsi\n"
#~ "     dan definisi. Pilihan -F menekan untuk menampikan nama\n"
#~ "     fungsi saja.\n"
#~ "     \n"
#~ "     Menggunakan `+' daripada `-' mematikan atribut yang diberikan. "
#~ "Ketika\n"
#~ "     sedang digunkan dalam sebuah fungsi, membuat NAMA lokal, seperti "
#~ "dalam perintah 'local'."

#~ msgid "Obsolete.  See `declare'."
#~ msgstr "Kadaluarsa. Lihat `declare'."

#~ msgid ""
#~ "Create a local variable called NAME, and give it VALUE.  LOCAL\n"
#~ "    can only be used within a function; it makes the variable NAME\n"
#~ "    have a visible scope restricted to that function and its children."
#~ msgstr ""
#~ "Membuat sebuah variabel lokal yang disebut NAMA, dan menampilkan NILAI-"
#~ "nya. LOKAL\n"
#~ "    hanya dapat digunakan dalam sebuah fungsi; ini membuat NAMA variabel\n"
#~ "    memiliki scope visibel terbatas untuk fungsi itu dan anaknya."

#~ msgid ""
#~ "Output the ARGs.  If -n is specified, the trailing newline is suppressed."
#~ msgstr ""
#~ "Keluaran dari ARGs. Jika pilihan -n dispesifikasikan, akhiran baris baru "
#~ "dihapus."

#~ msgid ""
#~ "Enable and disable builtin shell commands.  This allows\n"
#~ "    you to use a disk command which has the same name as a shell\n"
#~ "    builtin without specifying a full pathname.  If -n is used, the\n"
#~ "    NAMEs become disabled; otherwise NAMEs are enabled.  For example,\n"
#~ "    to use the `test' found in $PATH instead of the shell builtin\n"
#~ "    version, type `enable -n test'.  On systems supporting dynamic\n"
#~ "    loading, the -f option may be used to load new builtins from the\n"
#~ "    shared object FILENAME.  The -d option will delete a builtin\n"
#~ "    previously loaded with -f.  If no non-option names are given, or\n"
#~ "    the -p option is supplied, a list of builtins is printed.  The\n"
#~ "    -a option means to print every builtin with an indication of whether\n"
#~ "    or not it is enabled.  The -s option restricts the output to the "
#~ "POSIX.2\n"
#~ "    `special' builtins.  The -n option displays a list of all disabled "
#~ "builtins."
#~ msgstr ""
#~ "Enable dan disable perintah builtin shell. Ini membolehkan\n"
#~ "    anda untuk menggunakan perintah disk yang memiliki nama sama seperti "
#~ "sebuah NAMA\n"
#~ "    shell builtin tanpa menspesifikasikan sebuah pathname full. Jika "
#~ "pilihan -n digunakan,\n"
#~ "    NAMA menjadi disabled; jika tidak NAMA menjadi enabled. Contoh,\n"
#~ "    gunakan `test' ditemukan dalam $PATH daripada dalam builtin versi\n"
#~ "    builtin shell, ketik `enable -n test'. Di system mensupport dynamic\n"
#~ "    loading, pilihan -f mungkin bisa digunakan untuk menload builtin baru "
#~ "dari\n"
#~ "    shared object NAMAFILE. Pilihan -d akan menghapus sebuah builting\n"
#~ "    yang sebelumnya diload dengan pilihan -f. Jika tidak ada nama pilihan "
#~ "yang diberikan, atau\n"
#~ "    pilihan -p diberikan, daftar dari builtin ditampilkan.\n"
#~ "    Pilihan -a berarti menampilkan setiap builtin dengan sebuah indikasi "
#~ "apakah\n"
#~ "    atau tidak ini enabled. Pilihan -s membatasi keluaran ke POSIX.2\n"
#~ "    `special' builtins. Pilihan -n menampilkan daftar dari semua yang "
#~ "builtins yang disabled."

#~ msgid ""
#~ "Read ARGs as input to the shell and execute the resulting command(s)."
#~ msgstr ""
#~ "Baca ARGs sebagai masukan ke shell dan jalankan untuk menghasilkan "
#~ "perintah(s)."

#~ msgid ""
#~ "Exec FILE, replacing this shell with the specified program.\n"
#~ "    If FILE is not specified, the redirections take effect in this\n"
#~ "    shell.  If the first argument is `-l', then place a dash in the\n"
#~ "    zeroth arg passed to FILE, as login does.  If the `-c' option\n"
#~ "    is supplied, FILE is executed with a null environment.  The `-a'\n"
#~ "    option means to make set argv[0] of the executed process to NAME.\n"
#~ "    If the file cannot be executed and the shell is not interactive,\n"
#~ "    then the shell exits, unless the shell option `execfail' is set."
#~ msgstr ""
#~ "Exec FILE, menimpa shell ini dengan aplikasi yang dispesifikasikan.\n"
#~ "    Jika FILE tidak dispesifikasikan, redirectiions mengambil efek dalam\n"
#~ "    shell ini. Jika argumen pertama adalah `-l', maka tempatkan sebuah "
#~ "dash dalam\n"
#~ "    argument ke nol yang dilewatkan ke FILE, seperti yang dilakukan oleh "
#~ "login. Jika pilihan `-c'\n"
#~ "    diberikan, FILE dijalankan dengan environmen kosong. Jika pilihan `-"
#~ "a'\n"
#~ "    berarti menset argv[0] dari proses yang dijalankan ke NAMA.\n"
#~ "    Jika berkas tidak dapat dijalankan dan shell bukan interaktif,\n"
#~ "    maka shell keluar, unless pilihan shell `execfail' diset."

#~ msgid "Logout of a login shell."
#~ msgstr "Logout dari sebuah login shell."

#~ msgid ""
#~ "For each NAME, the full pathname of the command is determined and\n"
#~ "    remembered.  If the -p option is supplied, PATHNAME is used as the\n"
#~ "    full pathname of NAME, and no path search is performed.  The -r\n"
#~ "    option causes the shell to forget all remembered locations.  The -d\n"
#~ "    option causes the shell to forget the remembered location of each "
#~ "NAME.\n"
#~ "    If the -t option is supplied the full pathname to which each NAME\n"
#~ "    corresponds is printed.  If multiple NAME arguments are supplied "
#~ "with\n"
#~ "    -t, the NAME is printed before the hashed full pathname.  The -l "
#~ "option\n"
#~ "    causes output to be displayed in a format that may be reused as "
#~ "input.\n"
#~ "    If no arguments are given, information about remembered commands is "
#~ "displayed."
#~ msgstr ""
#~ "Untuk setiap NAMA, full pathname dari perintah ditentukan dan\n"
#~ "    diingat. Jika pilihan -p diberikan, PATHNAME digunakan sebagai\n"
#~ "    full pathname dari NAME, dan tidak ada jalur pencarian yang "
#~ "dilakukan. Pilihan -r\n"
#~ "    menyebabkan shell untuk melupakan semua lokasi yang diingat. Pilihan -"
#~ "d\n"
#~ "    menyebabkan shell untuk melupakan lokasi dari setiap NAMA.\n"
#~ "    Jika pilihan -t diberikan ful pathname ke setiap NAMA\n"
#~ "    yang bersesuaian ditampilkan. Jika beberapa argumen NAMA diberikan "
#~ "dengan\n"
#~ "    pilihan -t, NAME ditampilkan sebelum hashed full pathname. Pilihan -"
#~ "l\n"
#~ "    menyebabkan keluaran untuk ditampilkan dalam format yang biasa "
#~ "digunakan sebagai masukan.\n"
#~ "    Jika tidak ada argumen yang diberikan, informasi mengenai perintah "
#~ "yang diingat akan ditampilkan."

#~ msgid ""
#~ "Display helpful information about builtin commands.  If PATTERN is\n"
#~ "    specified, gives detailed help on all commands matching PATTERN,\n"
#~ "    otherwise a list of the builtins is printed.  The -s option\n"
#~ "    restricts the output for each builtin command matching PATTERN to\n"
#~ "    a short usage synopsis."
#~ msgstr ""
#~ "Menampilkan informasi yang berharga mengenai perintah builtin. Jika "
#~ "PATTERN\n"
#~ "    dispesifikasikan, memberikan bantuan detail mengenail seluruh "
#~ "perintah yang cocok dengan PATTERN,\n"
#~ "    jika tidak sebuah daftar dari builtings akan ditampilkan. Pilihan -s\n"
#~ "    membatasi keluaran dari setiap perintah builtin yang cocok dengan "
#~ "PATTERN ke\n"
#~ "    ringkasan penggunaan singkat."

#~ msgid ""
#~ "By default, removes each JOBSPEC argument from the table of active jobs.\n"
#~ "    If the -h option is given, the job is not removed from the table, but "
#~ "is\n"
#~ "    marked so that SIGHUP is not sent to the job if the shell receives a\n"
#~ "    SIGHUP.  The -a option, when JOBSPEC is not supplied, means to remove "
#~ "all\n"
#~ "    jobs from the job table; the -r option means to remove only running "
#~ "jobs."
#~ msgstr ""
#~ "Secara default, menghapus setiap JOBSPEC argumen dari tabel actif jobs.\n"
#~ "    Jika pilihan -n diberikan, pekerjaan tidak dihapus dari tabel, tetap "
#~ "ditandai\n"
#~ "    sehingga ketika SIGHUP tidak terkirim ke job ketika shell menerima "
#~ "sebuah\n"
#~ "    SIGHUP. Pilihan -a, ketika JOBSPEC tidak diberikan, berarti menghapus "
#~ "seluruh\n"
#~ "    pekerjaan dari job tabel; Pilihan -r berarti hanya menghapus "
#~ "pekerjaan yang berjalan."

#~ msgid ""
#~ "Causes a function to exit with the return value specified by N.  If N\n"
#~ "    is omitted, the return status is that of the last command."
#~ msgstr ""
#~ "Menyebabkan sebuah fungsi untuk keluar dengan nilai kembalian "
#~ "dispesifikasikan oleh N. Jika N\n"
#~ "    diabaikan, maka status kembalian adalah status dari perintah terakhir."

#~ msgid ""
#~ "For each NAME, remove the corresponding variable or function.  Given\n"
#~ "    the `-v', unset will only act on variables.  Given the `-f' flag,\n"
#~ "    unset will only act on functions.  With neither flag, unset first\n"
#~ "    tries to unset a variable, and if that fails, then tries to unset a\n"
#~ "    function.  Some variables cannot be unset; also see readonly."
#~ msgstr ""
#~ "Untuk setiap NAMA, hapus variabel atau fungsi yang berhubungan. Dengan\n"
#~ "    pilihan `-v', unset hanya berlaku di variabel. Dengan pilihan `-f',\n"
#~ "    unset hanya berlaku untuk fungsi. Dengan tidak menggunakan dua "
#~ "pilihan itu,\n"
#~ "    pertama akan mencoba mengunset variabel, dan jika itu gagal maka "
#~ "akan\n"
#~ "    mencoba untuk mengunset sebuah fungsi. Beberapa variabel tidak dapat "
#~ "diunset. Lihat readonly."

#~ msgid ""
#~ "NAMEs are marked for automatic export to the environment of\n"
#~ "    subsequently executed commands.  If the -f option is given,\n"
#~ "    the NAMEs refer to functions.  If no NAMEs are given, or if `-p'\n"
#~ "    is given, a list of all names that are exported in this shell is\n"
#~ "    printed.  An argument of `-n' says to remove the export property\n"
#~ "    from subsequent NAMEs.  An argument of `--' disables further option\n"
#~ "    processing."
#~ msgstr ""
#~ "NAMA ditandai untuk otomatis export ke environment dari\n"
#~ "    perintah yang akan dijalankan selanjutnya. Jika pilihan -f "
#~ "diberikan,\n"
#~ "    NAMA akan menunjuk ke fungsi. Jika tidak ada NAMA diberikan, atau "
#~ "jika pilihan `-p'\n"
#~ "    diberikan, daftar dari seluruh nama yang diexport dalam shell ini\n"
#~ "    ditampilkan. Sebuah argumen dari pilihan `-n' mengatakan untuk "
#~ "menghapus expor properti\n"
#~ "    dari NAMA selanjutnya. Sebuah argumen dari `--' menonaktifkan "
#~ "pemrosesan\n"
#~ "    pilihan selanjutnya."

#~ msgid ""
#~ "The given NAMEs are marked readonly and the values of these NAMEs may\n"
#~ "    not be changed by subsequent assignment.  If the -f option is given,\n"
#~ "    then functions corresponding to the NAMEs are so marked.  If no\n"
#~ "    arguments are given, or if `-p' is given, a list of all readonly "
#~ "names\n"
#~ "    is printed.  The `-a' option means to treat each NAME as\n"
#~ "    an array variable.  An argument of `--' disables further option\n"
#~ "    processing."
#~ msgstr ""
#~ "NAMA yang diberikan ditandai secara baca-saja dan nilai dari NAMA ini "
#~ "tidak\n"
#~ "    boleh diubah oleh assignmen selanjutnya. Jika pilihan -f diberikan,\n"
#~ "    maka fungsi yang berhubungan dengan NAMA akan ditandai. Jika tidak\n"
#~ "    ada argumen yang diberikan, atau jika pilihan `-p' diberikan, sebuah "
#~ "daftar dari seluruh nama baca-saja\n"
#~ "    ditampilkan. Pilihan `-a' berarti memperlakukan setiap NAMA sebagai\n"
#~ "    sebuah variabel array. Sebuah argumen dari `--' menonaktifkan "
#~ "pemrosesan\n"
#~ "    pilihan selanjutnya."

#~ msgid ""
#~ "The positional parameters from $N+1 ... are renamed to $1 ...  If N is\n"
#~ "    not given, it is assumed to be 1."
#~ msgstr ""
#~ "Parameter posisi dari $N+1 ... diubah namanya menjadi $1 ... Jika N\n"
#~ "    tidak diberikan, ini diasumsikan untuk menjadi 1."

#~ msgid ""
#~ "Suspend the execution of this shell until it receives a SIGCONT\n"
#~ "    signal.  The `-f' if specified says not to complain about this\n"
#~ "    being a login shell if it is; just suspend anyway."
#~ msgstr ""
#~ "Suspend eksekusi dari shell ini sampai ini menerima sebuah sinyal "
#~ "SIGCONT\n"
#~ "   Jika pilihan `-f' dispesifikasikan maka tidak komplain tentang ini "
#~ "menjadi\n"
#~ "   sebuah login shell jika emang begitu. Hanya lakukan suspend saja."

#~ msgid ""
#~ "Print the accumulated user and system times for processes run from\n"
#~ "    the shell."
#~ msgstr ""
#~ "Tampilkan waktu yang terakumulasi oleh pengguna dan system untuk proses "
#~ "yang berjalan dari\n"
#~ "    shell."

#~ msgid ""
#~ "For each NAME, indicate how it would be interpreted if used as a\n"
#~ "    command name.\n"
#~ "    \n"
#~ "    If the -t option is used, `type' outputs a single word which is one "
#~ "of\n"
#~ "    `alias', `keyword', `function', `builtin', `file' or `', if NAME is "
#~ "an\n"
#~ "    alias, shell reserved word, shell function, shell builtin, disk "
#~ "file,\n"
#~ "    or unfound, respectively.\n"
#~ "    \n"
#~ "    If the -p flag is used, `type' either returns the name of the disk\n"
#~ "    file that would be executed, or nothing if `type -t NAME' would not\n"
#~ "    return `file'.\n"
#~ "    \n"
#~ "    If the -a flag is used, `type' displays all of the places that "
#~ "contain\n"
#~ "    an executable named `file'.  This includes aliases, builtins, and\n"
#~ "    functions, if and only if the -p flag is not also used.\n"
#~ "    \n"
#~ "    The -f flag suppresses shell function lookup.\n"
#~ "    \n"
#~ "    The -P flag forces a PATH search for each NAME, even if it is an "
#~ "alias,\n"
#~ "    builtin, or function, and returns the name of the disk file that "
#~ "would\n"
#~ "    be executed."
#~ msgstr ""
#~ "Untuk setiap NAMA, mengindikasikan bagaimana ini akan diinterpretasikan "
#~ "jika digunakan sebagai sebuah\n"
#~ "    nama perintah.\n"
#~ "    \n"
#~ "    Jika sebuah pilihan -t digunakan, `type' mengeluarkan sebuah kata "
#~ "tunggal yang salah satu dari\n"
#~ "    `alias', `keyword', `function', `builtin', `file', atau `', jika NAMA "
#~ "adalah sebuah\n"
#~ "    alias, shell kata yang dipesan, shell fungsi, shell builtin, disk "
#~ "file,\n"
#~ "    atau tidak ditemukan, respectively.\n"
#~ "    \n"
#~ "    Jika flag -p digunakan, `type' menampilkan semua dari tempat yang "
#~ "berisi\n"
#~ "    nama executable `file'. Ini meliputi aliases, builtings, dan\n"
#~ "    fungsi, jika dan hanya jika flag -p juga tidak digunakan.\n"
#~ "    \n"
#~ "    Flag -f menekan seluruh fungsi shell lookup.\n"
#~ "    \n"
#~ "    Flag -P memaksa sebuah JALUR pencarian untuk setiap NAMA, bahkan jika "
#~ "ini merupakan sebuah alias,\n"
#~ "    builtin, atau fungsi, dan mengembalikan nama ke disk file yang akan\n"
#~ "    dijalankan."

#~ msgid ""
#~ "The user file-creation mask is set to MODE.  If MODE is omitted, or if\n"
#~ "    `-S' is supplied, the current value of the mask is printed.  The `-"
#~ "S'\n"
#~ "    option makes the output symbolic; otherwise an octal number is "
#~ "output.\n"
#~ "    If `-p' is supplied, and MODE is omitted, the output is in a form\n"
#~ "    that may be used as input.  If MODE begins with a digit, it is\n"
#~ "    interpreted as an octal number, otherwise it is a symbolic mode "
#~ "string\n"
#~ "    like that accepted by chmod(1)."
#~ msgstr ""
#~ "File-creation mask pengguna diset ke MODE. Jika MODE diabaikan, atau "
#~ "jika\n"
#~ "    `-S' diberikan, nilai sekaran dari mask ditampilkan. Pilihan `-S'\n"
#~ "    membuah keluaran symbolic; jika tidak sebuah bilangan octal "
#~ "dikeluarkan.\n"
#~ "    Jika pilihan `-p' diberikan, dan MODE diabaikan, keluaran adalah "
#~ "dalam format\n"
#~ "    yang bisa digunakan sebagai masukan. Jika MODE dimulai dengan sebuah "
#~ "digit, ini\n"
#~ "    diinterpretasikan sebagai sebuah bilangan octal, jika tidak ini "
#~ "adalah sebuah symbolic mode string\n"
#~ "    yang diterima oleh chmod(1)."

#~ msgid ""
#~ "Wait for the specified process and report its termination status.  If\n"
#~ "    N is not given, all currently active child processes are waited for,\n"
#~ "    and the return code is zero.  N is a process ID; if it is not given,\n"
#~ "    all child processes of the shell are waited for."
#~ msgstr ""
#~ "Menunggu sampai proses yang dispesifikasikan dan laporkan status "
#~ "selesainya. Jika\n"
#~ "    N tidak diberikan, semua proses anak yang masih aktif ditunggu "
#~ "untuk,\n"
#~ "    dan mengembalikan kode kembalian nol. N adalah sebuah proses ID; jika "
#~ "ini tidak diberikan,\n"
#~ "    semua proses anak dari shell ditunggu."

#~ msgid ""
#~ "Create a simple command invoked by NAME which runs COMMANDS.\n"
#~ "    Arguments on the command line along with NAME are passed to the\n"
#~ "    function as $0 .. $n."
#~ msgstr ""
#~ "Buat sebuah perintah sederhana yang memanggil dengan NAMA yang "
#~ "menjalankan PERINTAH.\n"
#~ "    Argumen dalam baris perintah dengan NAMA dilewatkan ke\n"
#~ "    fungsi sebagai $0 .. $n."

#~ msgid ""
#~ "Toggle the values of variables controlling optional behavior.\n"
#~ "    The -s flag means to enable (set) each OPTNAME; the -u flag\n"
#~ "    unsets each OPTNAME.  The -q flag suppresses output; the exit\n"
#~ "    status indicates whether each OPTNAME is set or unset.  The -o\n"
#~ "    option restricts the OPTNAMEs to those defined for use with\n"
#~ "    `set -o'.  With no options, or with the -p option, a list of all\n"
#~ "    settable options is displayed, with an indication of whether or\n"
#~ "    not each is set."
#~ msgstr ""
#~ "Ubah nilai dari variabel yang mengontrol perilaku opsional.\n"
#~ "    Pilihan -s berarti untuk mengaktifkan (set) setiap OPTNAME; pilihan -"
#~ "u\n"
#~ "    mengunset setiap OPTNAME. tanda -q menekan keluaran; status keluaran\n"
#~ "    mengindikasikan apakah setiap OPTNAME diset atau diunset. Pilihan -o\n"
#~ "    membatasi OPTNAME ke nilai yang didefinisikan untuk digunakan dengan\n"
#~ "    `set -o'. Tanpa pilihan, atau dengan pilihan -p, sebuah daftar dari "
#~ "seluruh\n"
#~ "    pilihan yang bisa diset ditampilkan, tanpa sebuah indikasi apakah "
#~ "salah satu atau\n"
#~ "    bukan setiap dari variabel diset."

#~ msgid ""
#~ "For each NAME, specify how arguments are to be completed.\n"
#~ "    If the -p option is supplied, or if no options are supplied, "
#~ "existing\n"
#~ "    completion specifications are printed in a way that allows them to "
#~ "be\n"
#~ "    reused as input.  The -r option removes a completion specification "
#~ "for\n"
#~ "    each NAME, or, if no NAMEs are supplied, all completion "
#~ "specifications."
#~ msgstr ""
#~ "Untuk setiap NAMA, spesifikasikan bagaimana argumen akan diselesaikan.\n"
#~ "    Jika pilihan -p diberikan, atau tidak ada pilihan yang diberikan, "
#~ "completion\n"
#~ "    spesifikasi yang telah ada ditampilkan dalam sebuah cara yang "
#~ "membolehkan mereka untuk\n"
#~ "    digunakan sebagai masukan. Pilihan -r menghapus sebuah spesifikasi "
#~ "completion untuk\n"
#~ "    setiap NAMA, atau jika tidak ada NAMA yang diberikan, untuk semua "
#~ "spesifikasi completion."
