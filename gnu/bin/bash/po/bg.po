# Bulgarian translation of bash po-file.
# Copyright (C) 2007, 2010, 2012, 2013, 2014, 2015, 2016, 2018, 2020, 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Alexander Shopov <ash@kambanaria.org>, 2007, 2010, 2012, 2013, 2014, 2015, 2016, 2018, 2020, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: bash-5.2-rc1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2022-06-18 14:33+0200\n"
"Last-Translator: Alexander Shopov <ash@kambanaria.org>\n"
"Language-Team: Bulgarian <dict@ludost.net>\n"
"Language: bg\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "грешен индекс на масив"

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: изтриване на атрибута за указател от променливата"

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: масивът не може да бъде преобразуван към речник"

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: не може да се присвоява на нецифров индекс"

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: при присвояване към речник трябва да се използва индекс"

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: не може да се създаде: %s"

#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr ""
"изпълнение на команда на Юникс от bash: не може да се открие подредбата на\n"
"функциите на клавишите за командата"

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: първият непразен знак не е „\"“"

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "в %2$s липсва затварящ знак „%1$c“"

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: разделителят „:“ липсва"

#: bashline.c:4733
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "„%s“: неуспешно премахне на присвояване в подредбата на функциите на клавишите"

#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "заместване на изразите с фигурни скоби: неуспешно заделяне на памет за „%s“"

#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "заместване на изразите с фигурни скоби: неуспешно заделяне на памет за %u елемента"

#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "заместване на изразите с фигурни скоби: неуспешно заделяне на памет за „%s“"

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "„%s“: грешно име на синоним"

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "редактирането на командния ред не е включено"

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "„%s“: грешно име на подредбата на функциите на клавишите"

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: не може да се прочете: %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "„%s“:  име на непозната функция"

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s не е зададена на никой клавиш.\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s може да се извика чрез "

#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "„%s“: не може да се премахне присвояване"

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "брой цикли"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "валидно само за циклите с „for“, „while“ и „until“"

#: builtins/caller.def:136
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Връщане на контекста на текущото извикване на подпрограма.\n"
"    \n"
"    Без ИЗРАЗ връща „$line $filename“.  С ИЗРАЗ връща\n"
"    „$line $subroutine $filename“.  Допълнителната информация може да се\n"
"    използва за получаване на информация за състоянието на стека.\n"
"    \n"
"    Стойността на ИЗРАЗа показва за колко рамки спрямо текущата да се изведе\n"
"    информация.  Най-горната рамка е 0."

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "Променливата „HOME“ не е зададена"

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "прекалено много аргументи"

#: builtins/cd.def:342
msgid "null directory"
msgstr "нулева директория"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "Променливата „OLDPWD“ не е зададена"

#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "ред %d: "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "предупреждение: "

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s: употреба: "

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: опцията изисква аргумент"

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: изисква се числов аргумент"

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s: не е открит"

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s: грешна опция"

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s: грешно име на опция"

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "„%s“: грешен идентификатор"

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "грешно осмично число"

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "грешно шестнайсетично число"

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "грешно число"

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: грешно указване на сигнал"

#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "„%s“: грешен идентификатор на процес или задача"

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s: променлива с права само за четене"

#: builtins/common.c:273
#, c-format
msgid "%s: cannot assign"
msgstr "%s: не може да се присвои"

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s е извън допустимия диапазон"

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "аргументът"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s е извън допустимия диапазон"

#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s: няма такава задача"

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s: няма управление на задачите"

#: builtins/common.c:301
msgid "no job control"
msgstr "няма управление на задачите"

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s: ограничена обвивка"

#: builtins/common.c:313
msgid "restricted"
msgstr "ограничена обвивка"

#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: не е команда вградена в обвивката"

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "грешка при запис: %s"

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "грешка при задаване на атрибутите на терминала: %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "грешка при получаване на атрибутите на терминала: %s"

#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: грешка при получаване на текущата директория: %s: %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: нееднозначно указана задача"

#: builtins/common.c:971
msgid "help not available in this version"
msgstr "помощта не е включена в тази версия"

#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: не може да се премахне: %s е само за четене"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s: не може да се премахне"

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s: грешно име на действие"

#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s: не е указано дописване"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "предупреждение: опцията „-F“ може да не работи според очакванията ви"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "предупреждение: опцията „-C“ може да не работи според очакванията ви"

#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "в момента не се изпълнява функция за дописване"

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "може да се използва само във функция"

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "„-f“ не може да се използва за създаването на функции"

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s: функция с права само за четене"

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: променливата-указател не може да е масив"

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: променливата-указател не може да сочи към себе си"

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr "%s: цикъл в променливите-указатели"

#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "„%s“: неправилно име за променлива-указател"

#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: променливите за масиви не могат да се унищожават така"

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: речник не може да се преобразува в масив"

#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: съставното присвояване на масив чрез цитат е остаряло"

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "липсва възможност за динамично зареждане"

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "споделеният обект „%s“ не може да бъде зареден: %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "„%s“ не може да се открие в споделения обект %s: %s"

#: builtins/enable.def:422
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: вградената команда вече е динамично заредена"

#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "зареждащата функция за „%s“ върна грешка (%d): не е зареден"

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: не е зареден динамично"

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: не може да се изтрие: %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s: е директория"

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s: не е обикновен файл"

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s: файлът е прекалено голям"

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: двоичният файл не може да бъде изпълнен"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: не може да се изпълни: %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "изход\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "това не е входна обвивка: използвайте „exit“"

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Има спрени задачи.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Има изпълнявани задачи.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "не е открита команда"

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr "указване на историята"

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: не може да се отвори временен файл: %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "текуща"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "задача %d е стартирана без управление на задачите"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: непозволена опция — %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: опцията изисква аргумент — %c\n"

#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "хеширането е изключено"

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: таблицата с хешове е празна\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "съвпад.\tкоманда\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Команди на обвивката, които напасват на ключовата дума „"
msgstr[1] "Команди на обвивката, които напасват на ключовите думи „"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"“\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"няма теми в помощта, които да отговарят на „%s“.  Опитайте с\n"
"„help help“, „man -k %s“ или „info %s“."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: не може да се отвори: %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Тези команди на интерпретатора са дефинирани вътрешно.\n"
"Напишете „help“, за да видите списъка.\n"
"Напишете „help ИМЕ_НА_ФУНКЦИЯ“ за повече информация за съответната функция.\n"
"Напишете „info bash“ за повече информация за обвивката като цяло.\n"
"Напишете „man -k“ или „info“ за повече информация за командите извън списъка.\n"
"\n"
"Знакът звездичка „*“ до името на команда означава, че тя е изключена.\n"
"\n"

#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "не може да се ползва едновременно повече от една от опциите „-anrw“"

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "позиция в историята"

#: builtins/history.def:338
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: грешна дата с време"

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: неуспешно заместване чрез историята"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: неуспешно извикване на inlib"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "не е позволена друга опция с „-x“"

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: аргументите трябва да са идентификатори на процеси или задачи"

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Неизвестна грешка"

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "очаква се израз"

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: не е масив"

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: грешно указване на файловия дескриптор"

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: грешен файлов дескриптор: %s"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s: грешен номер на ред"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: грешен начален индекс за масив"

#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: грешно количество редове за обработка"

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "празно име на променлива за масив"

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr "изисква се поддръжка на променливи за масиви"

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "„%s“: липсва форматиращ знак"

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "„%c“: грешен формат на времето"

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "„%c“: грешен форматиращ знак"

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "предупреждение: %s: %s"

#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr "неуспешен анализ на форма̀та: %s"

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "липсва шестнадесетична цифра за \\x"

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "липсва цифра за Уникод за \\%c"

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "няма друга директория"

#: builtins/pushd.def:360
#, c-format
msgid "%s: invalid argument"
msgstr "%s: грешен аргумент"

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "«няма текуща директория»"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "стекът с директории е празен"

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "индекс за стека с директории"

#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Извежда списъка с текущо запомнените директории.  Списъкът се попълва чрез\n"
"    командата „pushd“.  Можете да вадите директории от списъка с командата\n"
"    „popd“.\n"
"    \n"
"    Опции:\n"
"      -c  изчиства стека на директориите като изтрива всички елементи.\n"
"      -l  кара командата „dirs“ да извежда пълните имена на директориите,\n"
"          а не съкратените със тилда „~“.\n"
"      -p  поредово отпечатване на стека на директориите.\n"
"      -v  поредово отпечатване на стека на директориите заедно с номера в\n"
"          стека.\n"
"    \n"
"    Аргументи:    \n"
"      +N  извежда N-тия елемент отляво в списъка отпечатан от командата „dirs“,\n"
"          когато е стартирана без опции.  Брои се от 0.\n"
"    \n"
"      -N  извежда N-тия елемент отдясно в списъка отпечатан от командата „dirs“,\n"
"          когато е стартирана без опции.  Брои се от 0."

#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Добавя директория в стека на директориите или превърта стека\n"
"    като най-горна директория става текущата директория.  Без\n"
"    аргументи сменя най-горните две директории.\n"
"    \n"
"    Опции:\n"
"      -n  подтискане на нормалното преминаване към директория при добавянето на\n"
"          директории към стека, така че се променя само той.\n"
"    \n"
"     Аргументи:\n"
"      +N   Превърта стека, така че N-тата директория (като се брои от лявата\n"
"           страна на списъка, отпечатан от командата „dirs“ като се почва от 0)\n"
"           да е най-отгоре.\n"
"    \n"
"      -N   Превърта стека, така че N-тата директория (като се брои от дясната\n"
"           страна на списъка, отпечатан от командата „dirs“ като се почва от 0)\n"
"           да е най-отгоре.\n"
"    \n"
"      dir  Добавя ДИР най-отгоре в стека на директориите, като я прави новата\n"
"           текуща работна директория.\n"
"    \n"
"    Можете да изведете стека на директорията с командата „dirs“."

#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Маха директории от стека с тях. Без аргументи премахва последната директория в\n"
"    стека и влиза в новата последна директория.\n"
"    \n"
"    Опции:\n"
"      -n  подтискане на нормалното преминаване към директория при махането на\n"
"          директория от стека — само той се променя.\n"
"    \n"
"    Аргументи:\n"
"      +N  премахва N-тия елемент като се брои отляво в списъка отпечатан от\n"
"          командата „dirs“, като се брои от 0.  Напр.: „popd +0“ премахва\n"
"          първата директория, „popd +1“ - втората.\n"
"    \n"
"      -N  премахва N-тия елемент като се брои отдясно в списъка отпечатан от\n"
"          командата „dirs“, като се брои от 0.  Напр.: „popd -0“ премахва\n"
"          последната директория, „popd -1“ - предпоследната.\n"
"    \n"
"    Можете да изведете стека на директорията с командата „dirs“."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: грешно указване на изтичането на времето"

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "грешка при четене: %d: %s"

#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr "„return“ е възможен само от функция или изпълнен в текущата обвивка скрипт"

#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr "не може едновременно да се премахват задаванията на функция и променлива"

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s: не е променлива за масив"

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s: не е функция"

#: builtins/setattr.def:194
#, c-format
msgid "%s: cannot export"
msgstr "%s: не може да се изнесе"

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "брой на преместванията"

#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "не може едновременно да се задават и да се премахват опции на обвивката"

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: грешно име на опция на обвивката"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "изисква се аргумент име на файл"

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s: файлът не е открит"

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "не може да бъде временно спряна"

#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "входната обвивка не може да бъде временно спряна"

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s е синоним на „%s“\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s е ключова дума на обвивката\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s е функция\n"

#: builtins/type.def:299
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s е специална, вградена команда в обвивката\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s е вградена команда в обвивката\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "%s е %s\n"

#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s е хеширан (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: грешен аргумент за ограничение"

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "„%c“: грешна команда"

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: ограничението не може да бъде получено: %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "ограничение"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: ограничението не може да бъде променено: %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "осмично число"

#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "„%c“: неправилен оператор за описателен режим"

#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "„%c“: неправилен знак за описателен режим"

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " ред "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "последна команда: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Преустановяване…"

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr "ИНФОРМАЦИЯ: "

#: error.c:310
#, c-format
msgid "DEBUG warning: "
msgstr "ПРЕДУПРЕЖДЕНИЕ: "

#: error.c:488
msgid "unknown command error"
msgstr "неизвестна грешка в команда"

#: error.c:489
msgid "bad command type"
msgstr "грешен вид команда"

#: error.c:490
msgid "bad connector"
msgstr "грешна връзка"

#: error.c:491
msgid "bad jump"
msgstr "грешен преход"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s: променлива без стойност"

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aвремето за изчакване на вход изтече: следва автоматично излизане от системата\n"

#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "стандартният вход не може да бъде пренасочен от „/dev/null“: %s"

#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "в променливата $TIMEFORMAT: „%c“: грешен форматиращ знак"

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: копроцесът [%d:%s] все още съществува"

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "грешка в програмен канал"

#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: превишено е максималното ниво на влагане на „eval“ (%d)"

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: превишено е максималното ниво на влагане на код (%d)"

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: превишено е максималното ниво на влагане на функции (%d)"

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: ограничение: в имената на командите не може да присъства знакът „/“"

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s: командата не е открита"

#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5975
#, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: не може да се изпълни — липсва необходим файл "

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: лош интерпретатор"

#: execute_cmd.c:6037
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: двоичният файл не може да бъде изпълнен: %s"

#: execute_cmd.c:6123
#, c-format
msgid "`%s': is a special builtin"
msgstr "„%s“ е вградена команда в обвивката"

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "файловият дескриптор %d не може да се дублира като дескриптор %d"

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "максималният брой нива за рекурсия в израз бяха преминати"

#: expr.c:291
msgid "recursion stack underflow"
msgstr "отрицателно препълване на стека за рекурсии"

#: expr.c:478
msgid "syntax error in expression"
msgstr "синтактична грешка в израз"

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "опит за присвояване на стойност на нещо, което не е променлива"

#: expr.c:531
msgid "syntax error in variable assignment"
msgstr "синтактична грешка при присвояване на променлива"

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "деление на 0"

#: expr.c:593
msgid "bug: bad expassign token"
msgstr "програмна грешка: неправилна лексема за присвояване на израз"

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "за условен израз се изисква „:“"

#: expr.c:973
msgid "exponent less than 0"
msgstr "степента е по-малка от 0"

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "очаква се идентификатор след предварително увеличаване или намаляване"

#: expr.c:1057
msgid "missing `)'"
msgstr "липсва „)“"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "синтактична грешка: очаква се оператор"

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "синтактична грешка: грешен аритметичен оператор"

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (грешната лексема е „%s“)"

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "грешна аритметична основа на бройна система"

#: expr.c:1587
msgid "invalid integer constant"
msgstr "неправилна целочислена константа"

#: expr.c:1603
msgid "value too great for base"
msgstr "стойността е прекалено голяма за основата"

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s: грешка в израза\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: няма достъп до родителските директории"

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "неуспешно изчистване на режима без забавяне на файловия дескриптор %d"

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "неуспешно заделяне на нов файлов дескриптор за вход на bash от дескриптор %d"

#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "запазване на входа на bash: вече съществува буфер за новия файлов дескриптор %d"

#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr ""
"стартиране на програмен канал: не може да се комуникира с водача на канала\n"
"(pgrp pipe)"

#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: ЦИКЪЛ: psi (%d) == storage[psi].bucket_next"

#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: ЦИКЪЛ: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "стартираният процес %d е в изпълняваната задача %d"

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "изтриване на спряната задача %d в групата процеси %ld"

#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "добавяне на процес: процесът %5ld (%s) е отбелязан като още жив"

#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "описателен идентификатор на процес: %ld: няма такъв идентификатор на процес"

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "Сигнал %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Завършен"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Спрян"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Спрян (%s)"

#: jobs.c:1881
msgid "Running"
msgstr "Изпълняван"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Завършен (%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Изход %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "Непознато състояние"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(паметта е разтоварена)"

#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (wd: %s)"

#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "дъщерният процес смени групата при изпълнение (от %ld на %ld)"

#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "изчакване: процесът с идентификатор %ld не е дъщерен на тази обвивка"

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "изчакване: липсват данни за процес с идентификатор %ld"

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "изчакване на задача: задачата %d е спряна"

#: jobs.c:3551
#, c-format
msgid "%s: no current jobs"
msgstr "%s: няма текуща задача"

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s: задачата е приключила"

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: задача %d вече е във фонов режим"

#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr ""
"изчакване на дъщерен процес: включване на незабавното излизане от функцията\n"
"чрез WNOHANG, за да се избегне недефиниран блок"

#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s: ред %d: "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr " (паметта е разтоварена)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(работната директория е: %s)\n"

#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "инициализация на контрола на задачите: неуспешно изпълнение на getpgrp"

#: jobs.c:4434
msgid "initialize_job_control: no job control in background"
msgstr "инициализация на контрола на задачите: няма управление на задачите във фонов режим"

#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "инициализация на контрола на задачите: дисциплина на линията"

#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "инициализация на контрола на задачите: задаване на група при изпълнение (setpgid)"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "групата на процесите на терминала не може да бъде зададена (%d)"

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "в тази обвивка няма управление на задачите"

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "заделяне на памет: грешно предположение: %s\n"

#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"заделяне на памет: %s:%d: предположението е отпечатано\r\n"

#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "непознат"

#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "заделяне на памет: блок в списъка със свободни блокове е зает или неподходящ"

#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "изчистване на памет: извикано е с блоков аргумент, който вече е изчистен"

#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "изчистване на памет: извикано е с незаделен блоков аргумент"

#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr ""
"изчистване на памет: открито е отрицателно препълване с mh_nbytes извън\n"
"допустимия диапазон"

#: lib/malloc/malloc.c:1007
msgid "free: underflow detected; magic8 corrupted"
msgstr ""
"изчистване на памет: открито е отрицателно препълване, неправилна стойност\n"
"за magic8"

#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "изчистване на памет: късовете на началната и крайната области се различават"

#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "презаделяне: извикано е с аргумент с незаделен блок"

#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr ""
"презаделяне: открито е отрицателно препълване с mh_nbytes извън допустимия\n"
"диапазон"

#: lib/malloc/malloc.c:1197
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "презаделяне: открито е отрицателно препълване,  неправилна стойност за magic8"

#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "презаделяне: късовете на началната и крайната области се различават"

#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "регистриране на презаделяне: таблицата за заделянията е пълна с FIND_ALLOC?\n"

#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "регистриране на презаделяне: %p вече е в таблицата като заделен?\n"

#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "регистриране на свободни: %p вече е в таблицата като свободен?\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "грешна основа на бройна система"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: непознат хост"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: неправилна услуга"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: неправилно указан мрежов път"

#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "не се поддържат мрежови операции"

#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: локалът не може да бъде сменен (%s)"

#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: локалът не може да бъде сменен (%s): %s"

#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: локалът не може да бъде сменен (%s)"

#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: локалът не може да бъде сменен (%s): %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Имате поща в $_"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Имате нова поща в $_"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Пощата в %s вече е прочетена\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "синтактична грешка: изисква се аритметичен израз"

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "синтактична грешка: неочакван знак „;“"

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "синтактична грешка: „((%s))“"

#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "вътрешен документ с „<<“: неправилен вид инструкция %d"

#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "вътрешният документ на ред %d е отделен със знак за нов ред (а трябва да е „%s“)"

#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "пренасочване: инструкцията за пренасочване „%d“ е извън допустимия диапазон"

#: parse.y:2428
#, c-format
msgid "shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"
msgstr "shell_getc: shell_input_line_size (%zu) надвишава SIZE_MAX (%lu): редът е отрязан"

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr "превишен е максималният брой възможни вътрешни документи"

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "неочакван знак за край на файл „EOF“, а се очакваше съответстващ знак „%c“"

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "неочакван знак за край на файл „EOF“, а се очакваше „]]“"

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "синтактична грешка в условен израз: неочаквана лексема „%s“"

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "синтактична грешка в условен израз"

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "неочаквана лексема „%s“, а се очакваше знакът „)“"

#: parse.y:4543
msgid "expected `)'"
msgstr "очакваше се „)“"

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "неочакван аргумент „%s“ за унарен условен оператор"

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr "неочакван аргумент за унарен условен оператор"

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "неочаквана лексема „%s“, очакваше се бинарен условен оператор"

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr "очакваше се бинарен условен оператор"

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "неочакван аргумент „%s“ за бинарен условен оператор"

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr "неочакван аргумент за бинарен условен оператор"

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "неочаквана лексема „%c“ в условна команда"

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "неочаквана лексема „%s“ в условна команда"

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "неочаквана лексема %d в условна команда"

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "синтактична грешка в близост до неочакваната лексема „%s“"

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "синтактична грешка в близост до „%s“"

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "синтактична грешка: неочакван край на файл"

#: parse.y:6151
msgid "syntax error"
msgstr "синтактична грешка"

#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Използвайте „%s“, за да излезете от обвивката.\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "неочакван знак за край на файл „EOF“, очакваше се знакът „)“"

#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "дописване: функцията „%s“ не е открита"

#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: възможно зацикляне на повторните опити"

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "вмъкване на завършване на команда: %s указване на команда, което е NULL"

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "команда за печат: лош конектор „%d“"

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: грешен файлов дескриптор"

#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: указател към файл – NULL"

#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != fileno xtrace fp (%d)"

#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "отпечатване: „%c“: неправилен форматиращ знак"

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "файловият дескриптор е извън допустимия диапазон"

#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: двусмислено пренасочване"

#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: не може да се презапише съществуващ файл"

#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: поради ограничение изходът не може да се пренасочи"

#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "не може да се създаде временен файл за вътрешен документ: %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: на променлива не може да се присвои файлов дескриптор"

#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "„/dev/(tcp|udp)/host/port“ не се поддържат, ако няма поддръжка на мрежа"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "грешка при пренасочване: файловият дескриптор не може да бъде дублиран"

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "не е открита директорията „/tmp“. Създайте я!"

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "„/tmp“ трябва да е директория"

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr "режимът за красив изход се игнорира при интерактивна работа"

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: неправилна опция"

#: shell.c:1343
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr ""
"идентификаторът на потребител на процеса не може да се зададе да е %d,\n"
"ефективният идентификатор на потребител на процеса е %d"

#: shell.c:1354
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr ""
"идентификаторът на група на процеса не може да се зададе да е %d,\n"
"ефективният идентификатор на група на процеса е %d"

#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr "режимът на изчистване на грешки е недостъпен, защото е изключен"

#: shell.c:1658
#, c-format
msgid "%s: Is a directory"
msgstr "%s: е директория"

#: shell.c:1907
msgid "I have no name!"
msgstr "Не може да се получи името на текущия потребител!"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, версия %s-(%s)\n"

#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Употреба:    %s [дълга опция на GNU] [опция]…\n"
"             %s [дълга опция на GNU] [опция] файл-скрипт…\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "Дълги опции на GNU:\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Опции на обвивката:\n"

#: shell.c:2069
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "    -ilrsD или -c команда, или -O къса_опция        (само при стартиране)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "    -%s или -o опция\n"

#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "За повече информация за опциите на обвивката въведете „%s -c \"help set\"“.\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "За повече информация за вградените в обвивката команди въведете „%s -c help“.\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "За да докладвате грешки, използвайте командата „bashbug“.\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "Интернет страница на bash: <http://www.gnu.org/software/bash>\n"

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Обща помощ за програмите на GNU: <http://www.gnu.org/gethelp/>\n"

#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "маска за обработката на сигнали: %d: грешна операция"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Фалшив сигнал"

#: siglist.c:51
msgid "Hangup"
msgstr "Прекъсване на връзката"

#: siglist.c:55
msgid "Interrupt"
msgstr "Прекъсване"

#: siglist.c:59
msgid "Quit"
msgstr "Спиране"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Неправилна инструкция"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Капан за авариен изход чрез BPT"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Инструкция за прекратяване"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Капан с EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Изключение от плаваща запетая"

#: siglist.c:87
msgid "Killed"
msgstr "Убит"

#: siglist.c:91
msgid "Bus error"
msgstr "Грешка в шината"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Грешка в разделянето"

#: siglist.c:99
msgid "Bad system call"
msgstr "Грешно системно извикване"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Прекъснат програмен канал"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Аларма"

#: siglist.c:111
msgid "Terminated"
msgstr "Прекратен"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Спешно вх./изх. състояние"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Спрян (сигнал)"

#: siglist.c:127
msgid "Continue"
msgstr "Продължаване"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Смърт или спиране на дъщерен процес"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Спиране (вход от tty)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Спиране (изход към tty)"

#: siglist.c:147
msgid "I/O ready"
msgstr "Готовност за вх./изх."

#: siglist.c:151
msgid "CPU limit"
msgstr "Ограничение на процесора"

#: siglist.c:155
msgid "File limit"
msgstr "Ограничение на файловете"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Аларма (виртуална)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Аларма (по профил)"

#: siglist.c:167
msgid "Window changed"
msgstr "Преоразмерен прозорец"

#: siglist.c:171
msgid "Record lock"
msgstr "Заключен запис"

#: siglist.c:175
msgid "User signal 1"
msgstr "Потребителски сигнал 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Потребителски сигнал 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "Идват данни по конзола HFT"

#: siglist.c:187
msgid "power failure imminent"
msgstr "Предстои спиране на захранването"

#: siglist.c:191
msgid "system crash imminent"
msgstr "Предстои забиване на системата"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "Преместване на процеса на друг процесор"

#: siglist.c:199
msgid "programming error"
msgstr "Програмна грешка"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "Дадено право за управление чрез конзола HFT"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "Отнето право за управление чрез конзола HFT"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "Завършена звукова поредица през HFT"

#: siglist.c:215
msgid "Information request"
msgstr "Заявка за информация"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Непознат сигнал #%d"

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "лошо заместване: липсва затварящ знак „%s“ в %s"

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: на член от масив не може да се присвои списък"

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "не може да се създаде програмен канал за заместване на процеси"

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "не може да се създаде дъщерен процес за заместване на процеси"

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "именуваният програмен канал %s не може да се отвори за четене"

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "именуваният програмен канал %s не може да се отвори за запис"

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr ""
"именуваният програмен канал %s не може да се\n"
"дублира като файловия дескриптор %d"

#: subst.c:6370
msgid "command substitution: ignored null byte in input"
msgstr "заместване на команди: знакът „null“ във входа е прескочен"

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "не може да се създаде програмен канал за заместване на команди"

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "не може да се създаде дъщерен процес за заместване на команди"

#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "заместване на команди: каналът не може да се дублира като fd 1"

#: subst.c:7082 subst.c:10252
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: неправилно име за променлива-указател"

#: subst.c:7178 subst.c:7196 subst.c:7369
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: грешно непряко заместване"

#: subst.c:7212 subst.c:7377
#, c-format
msgid "%s: invalid variable name"
msgstr "„%s“: грешно име на променлива"

#: subst.c:7478
#, c-format
msgid "%s: parameter not set"
msgstr "%s: аргументът не е зададен"

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: аргументът е „null“ или не е зададен"

#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: изразът от подниза е < 0"

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s: лошо заместване"

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: не може да се задава по този начин"

#: subst.c:10111
msgid "future versions of the shell will force evaluation as an arithmetic substitution"
msgstr ""
"бъдещите версии на обвивката ще използват изчисляване като аритметично\n"
"заместване"

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "лошо заместване: липсва затварящ знак „`“ в %s"

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "няма съвпадение: %s"

#: test.c:147
msgid "argument expected"
msgstr "очаква се аргумент"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: очаква се целочислен израз"

#: test.c:265
msgid "`)' expected"
msgstr "очаква се „)“"

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "очаква се „)“, а е получено %s"

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: очаква се бинарен оператор"

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: очаква се унарен оператор"

#: test.c:896
msgid "missing `]'"
msgstr "липсва „]“"

#: test.c:914
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "синтактична грешка: неочакван знак/ци „%s“"

#: trap.c:220
msgid "invalid signal number"
msgstr "неправилен номер на сигнал"

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "eval: превишено е максималното ниво на влагане на „eval“ (%d)"

#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr ""
"стартиране на предстоящите прихващания: неправилна стойност в\n"
"trap_list[%d]: %p"

#: trap.c:416
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""
"стартиране на предстоящите прихващания: обработката на сигнали е SIG_DFL.\n"
"%d (%s) е преизпратен на текущата обвивка"

#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "обработка на прихващания: неправилен сигнал %d"

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "грешка при внасянето на дефиницията на функция за „%s“"

#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "нивото на обвивката (%d) е прекалено голямо. Задава се да е 1"

#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr ""
"създаване на локална променлива: липсва контекст на функция в текущата област\n"
"на видимост"

#: variables.c:2661
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: на тази променлива не може да се присвои стойност"

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr "%s: не може да се наследи стойност от несъвместим вид"

#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: присвояване на число на променлива-указател"

#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr ""
"всички локални променливи: липсва контекст на функция в текущата област на\n"
"видимост"

#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "%s: аргументът за низа за изнасяне не трябва да е „null“"

#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "неправилен знак на позиция %d в низа за изнасяне за %s"

#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "липсва „=“ в низа за изнасяне за %s"

#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""
"изваждане на контекст на променливи: в началото на структурата за променливи на\n"
"обвивката (shell_variables) е нещо, което не е контекст на функция"

#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr ""
"изваждане на контекст на променливи: липсва контекст за глобални променливи\n"
"(global_variables)"

#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr ""
"изваждане на област: в началото на структурата за променливи на обвивката\n"
"(shell_variables)  е нещо, което не е временна област в обкръжението"

#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s не може да се отвори като ФАЙЛ"

#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: грешен файлов дескриптор за файла за трасиране"

#: variables.c:6450
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: е извън допустимия диапазон"

#: version.c:46 version2.c:46
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "Авторски права © 2022 Free Software Foundation, Inc."

#: version.c:47 version2.c:47
msgid "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
msgstr "Лиценз GPLv3+: ОПЛ на GNU, версия 3 или по-висока <http://gnu.org/licenses/gpl.html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, версия %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr "Това е свободен софтуер. Можете да го променяте и разпространявате."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "Няма НИКАКВИ ГАРАНЦИИ до степента позволена от закона."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: не могат да се заделят %lu байта (заделени са %lu байта)"

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: не могат да се заделят %lu байта"

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: не могат да се заделят %lu байта (заделени са %lu байта)"

#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: не могат да се заделят %lu байта"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [ИМЕ[=СТОЙНОСТ]…]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] ИМЕ [ИМЕ…]"

#: builtins.c:53
msgid "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpsvPSVX] [-m ПОДРЕДБА_НА_КЛАВИАТУРАТА] [-f ИМЕ_НА_ФАЙЛ]\n"
"     [-q ИМЕ] [-u ИМЕ] [-r ПОСЛЕДОВАТЕЛНОСТ_ОТ_КЛАВИШИ]\n"
"     [-x ПОСЛЕДОВАТЕЛНОСТ_ОТ_КЛАВИШИ:КОМАНДА_НА_ОБВИВКАТА]\n"
"     [ПОСЛЕДОВАТЕЛНОСТ_ОТ_КЛАВИШИ:КОМАНДА_НА_ОБВИВКАТА или КОМАНДА_НА_READLINE]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [БРОЙ]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [БРОЙ]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [ВГРАДЕНА_КОМАНДА [АРГУМЕНТ…]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [ИЗРАЗ]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [ДИРЕКТОРИЯ]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] команда [АРГУМЕНТ…]"

#: builtins.c:78
msgid "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]"
msgstr "declare [-aAfFgiIlnrtux] [ИМЕ[=СТОЙНОСТ]…] или declare -p [-aAfFilnrtux] [ИМЕ…]"

#: builtins.c:80
msgid "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]"
msgstr "typeset [-aAfFgiIlnrtux] ИМЕ[=СТОЙНОСТ]… или typeset -p [-aAfFilnrtux] [ИМЕ…]"

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [ОПЦИЯ] ИМЕ[=СТОЙНОСТ]…"

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [АРГУМЕНТ…]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [АРГУМЕНТ…]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f ФАЙЛ] [АРГУМЕНТ…]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [АРГУМЕНТ…]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts НИЗ_С_ОПЦИИ ИМЕ [АРГУМЕНТ…]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a ИМЕ] [КОМАНДА [АРГУМЕНТ…]] [ПРЕНАСОЧВАНЕ…]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [ЦИФРОВ_КОД]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [ЦИФРОВ_КОД]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e РЕДАКТОР] [-lnr] [ПЪРВИ] [ПОСЛЕДЕН] или fc -s [ШАБЛОН=ЗАМЕСТИТЕЛ…] [КОМАНДА]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [ЗАДАЧА]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [ЗАДАЧА…]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p ПЪТ] [-dt] [ИМЕ…]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [ШАБЛОН…]"

#: builtins.c:123
msgid "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"
msgstr ""
"history [-c] [-d ОТМЕСТВАНЕ] [БРОЙ] или \n"
"history -anrw [ИМЕ_НА_ФАЙЛ] или\n"
"history -ps АРГ [АРГ…]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [ИД_ЗАДАЧА…] или jobs -x КОМАНДА [АРГУМЕНТИ]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [ИД_ЗАДАЧА… | ИД_ПРОЦЕС…]"

#: builtins.c:134
msgid "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"
msgstr ""
"kill [-s СИГНАЛ | -n НОМЕР_НА_СИГНАЛ | -СИГНАЛ] ИД_ПРОЦЕС | ИД_ЗАДАЧА…\n"
"или\n"
"kill -l [СИГНАЛ]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let АРГУМЕНТ [АРГУМЕНТ…]"

#: builtins.c:138
msgid "read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a МАСИВ] [-d РАЗДЕЛИТЕЛ] [-i ТЕКСТ] [-n БРОЙ_ЗНАЦИ]\n"
"     [-N БРОЙ_ЗНАЦИ] [-p ПОДСКАЗКА] [-t БРОЙ_ЗНАЦИ] [-u ФАЙЛОВ_ДЕСКРИПТОР]\n"
"     [ИМЕ…]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [ЦИФРОВ_КОД]"

#: builtins.c:142
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCEHPT] [-o ОПЦИЯ] [--] [АРГУМЕНТ…]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [ИМЕ…]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [ИМЕ[=СТОЙНОСТ]…] или export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [ИМЕ[=СТОЙНОСТ]…] или readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [БРОЙ]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source ФАЙЛ [АРГУМЕНТИ]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". ФАЙЛ [аргументи]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [ИЗРАЗ]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ АРГУМЕНТ…]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[АРГУМЕНТ] СИГНАЛ…]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] ИМЕ [ИМЕ…]"

#: builtins.c:171
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPRT] [ОГРАНИЧЕНИЕ]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [МАСКА]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p ПРОМЕНЛИВА] [ИД…]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [ИД_ПР…]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for ИМЕ [in ДУМИ…] ; do КОМАНДИ; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( ИЗРАЗ_1; ИЗРАЗ_2; ИЗРАЗ_3 )); do КОМАНДИ; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select ИМЕ [in ДУМИ…;] do КОМАНДИ; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] ПРОГРАМЕН_КАНАЛ"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case ДУМА in [ШАБЛОН [| ШАБЛОН]…) КОМАНДИ ;;]… esac"

#: builtins.c:194
msgid "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"
msgstr "if КОМАНДИ; then КОМАНДИ; [ elif КОМАНДИ; then КОМАНДИ; ]… [ else КОМАНДИ; ] fi"

#: builtins.c:196
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while КОМАНДИ; do КОМАНДИ_2; done"

#: builtins.c:198
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until КОМАНДИ; do КОМАНДИ_2; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [ИМЕ] КОМАНДА [ПРЕНАСОЧВАНИЯ]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function name { КОМАНДИ ; } или name () { КОМАНДИ ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ КОМАНДИ ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "%ЗАДАЧА [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( ИЗРАЗ ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ ИЗРАЗ ]]"

#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr "variables имена и значение на някои от променливите на обвивката"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | ДИР]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [ОПЦИЯ…]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v ПРОМЕНЛИВА] ФОРМАТ [АРГУМЕНТИ]"

#: builtins.c:231
msgid "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o ОПЦИЯ] [-A ДЕЙСТВИЕ]\n"
"         [-G ШАБЛОН] [-W ДУМИ] [-F ФУНКЦИЯ] [-C КОМАНДА] [-X ФИЛТЪР]\n"
"         [-P ПРЕДСТАВКА] [-S НАСТАВКА] [ИМЕ…]"

#: builtins.c:235
msgid "compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o ОПЦИЯ] [-A ДЕЙСТВИЕ] [-G ШАБЛОН]\n"
"        [-W ДУМИ] [-F ФУНКЦИЯ] [-C КОМАНДА] [-X ФИЛТЪР] [-P ПРЕДСТАВКА]\n"
"        [-S НАСТАВКА] [ДУМА]"

#: builtins.c:239
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o ОПЦИЯ] [-DEI] [ИМЕ…]"

#: builtins.c:242
msgid "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr ""
"mapfile [-d РАЗДЕЛИТЕЛ] [-n БРОЙ] [-O НАЧАЛО] [-s БРОЙ] [-t]\n"
"        [-u ФАЙЛ_ДЕСКР] [-C ФУНКЦИЯ] [-c КВАНТ] [МАСИВ]"

#: builtins.c:244
msgid "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr ""
"readarray [-d РАЗДЕЛИТЕЛ] [-n БРОЙ] [-O НАЧАЛО] [-s БРОЙ] [-t]\n"
"          [-u ФАЙЛ_ДЕСКР] [-C ФУНКЦИЯ] [-c КВАНТ] [МАСИВ]"

#: builtins.c:256
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"Дефиниране или извеждане на синоними.\n"
"    \n"
"    „alias“ без аргументи или с опцията „-p“ отпечатва списъка със\n"
"    синонимите във формат „ИМЕ=СТОЙНОСТ“ на стандартния изход.\n"
"    \n"
"    В противен случай за всяко ИМЕ, за което е зададена стойност, се\n"
"    дефинира синоним.  Интервал в края на СТОЙНОСТ-та предизвиква синонимно\n"
"    заместване на следващата дума при заместването на синонима.\n"
"    \n"
"    Опции:\n"
"      -p  Извежда всички синоними във формат за последващо използване\n"
"    \n"
"    Изходен код:\n"
"    alias връща 0, освен в случаите, когато се зададе ИМЕ, за което\n"
"    не е дефиниран синоним."

#: builtins.c:278
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Премахване на ИМЕната от списъка с дефинираните синоними.\n"
"    \n"
"    Опции:\n"
"      -a  премахване на всички синоними.\n"
"    \n"
"    Изходен код:\n"
"    Връща 0, освен в случаите, когато се зададе ИМЕ, за което\n"
"    не е дефиниран синоним."

#: builtins.c:291
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Задаване на клавишни комбинации и променливи на readline.\n"
"    \n"
"    Присвояване на последователност от клавиши на функция или макрос от\n"
"    readline или задаване на променлива на readline.  Синтаксисът с\n"
"    аргументи без опции е еквивалентен на този във файла „~/.inputrc“, но\n"
"    трябва да се подаде като единствен аргумент.  Напр:\n"
"    bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Опции:\n"
"      -m  ПОДРЕДБА    \n"
"              Използване на ПОДРЕДБАта като подредба на функциите на клавишите\n"
"              докато командата се изпълнява.  Валидни са следните имена:\n"
"              „emacs“, „emacs-standard“, „emacs-meta“, „emacs-ctlx“, „vi“,\n"
"              „vi-move“, „vi-command“ и „vi-insert“.\n"
"      -l      Списък с имената на функциите.\n"
"      -P      Списък с имената на функциите и присвояванията.\n"
"      -p      Списък с имената на функциите и присвояванията във вид, който може\n"
"              да се използва за вход.\n"
"      -S      Списък с клавишните последователности, които извикват макроси и\n"
"              стойностите им.\n"
"      -s      Списък с клавишните последователности, които извикват макроси и\n"
"              стойностите им във вид, който може да се използва за вход.\n"
"      -V      Списък с имената на променливите и стойностите им.\n"
"      -v      Списък с имената на променливите и стойностите им във вид, който\n"
"              може да се използва за вход.\n"
"      -q  ИМЕ_НА_ФУНКЦИЯ\n"
"              Проверка кои клавиши извикват функцията с това име.\n"
"      -u  ИМЕ_НА_ФУНКЦИЯ\n"
"              Премахване на присвояванията към всички клавиши на функцията с\n"
"              това име.\n"
"      -r  КЛАВИШНА_ПОСЛЕДОВАТЕЛНОСТ\n"
"              Премахване на присвоената функция от КЛАВИШНАта_ПОСЛЕДОВАТЕЛНОСТ.\n"
"      -f  ФАЙЛ\n"
"              Прочитане на присвояванията на клавиши от ФАЙЛа.\n"
"      -x  КЛАВИШНА_ПОСЛЕДОВАТЕЛНОСТ:КОМАНДА_НА_ОБВИВКАТА\n"
"               Изпълнение на КОМАНДАта_НА_ОБВИВКАТА при въвеждането на\n"
"               КЛАВИШНАта_ПОСЛЕДОВАТЕЛНОСТ.\n"
"      -X  Извеждане на клавишните комбинации зададени с „-x“ и свързаните с тях\n"
"               команди във форма, която може да се ползва и за вход\n"
"    \n"
"    Изходен код:\n"
"    bind връща 0, освен когато е зададена непозната опция или възникне грешка."

#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Изход от цикли чрез „for“, „while“ или „until“.\n"
"    \n"
"    Изход от цикли организирани чрез „for“, „while“ или „until“.  Ако е зададен\n"
"    БРОЙ се излиза от толкова на БРОЙ обхващащи цикли.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е зададен БРОЙ, който е по-малък от 1."

#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Продължаване на цикъл  чрез „for“, „while“ или „until“.\n"
"    \n"
"    Продължаване със следващата итерация от цикъл, организиран с „for“, „while“\n"
"    или „until“.  Ако е зададен БРОЙ,  се продължава със следващата итерация\n"
"    на обхващащия цикъл зададен с този БРОЙ.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е зададен БРОЙ, който е по-малък от 1."

#: builtins.c:354
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Изпълнение на вградени команди.\n"
"    \n"
"    Изпълнение на ВГРАДЕНАта_КОМАНДА с АРГУМЕНТи, без да се търси нормална\n"
"    команда.  Това е полезно в случаите, когато искате да създадете вградена\n"
"    команда като функция на обвивката, но във функцията искате да изпълните\n"
"    вградената команда.\n"
"    \n"
"    Изходен код:\n"
"    Връща изходния код на ВГРАДЕНАта_КОМАНДА или лъжа, ако извиканата \n"
"    ВГРАДЕНА_КОМАНДА всъщност не е вградена команда."

#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Връщане на контекста на текущото извикване на подпрограма.\n"
"    \n"
"    Без ИЗРАЗ връща „$line $filename“.  С ИЗРАЗ връща\n"
"    „$line $subroutine $filename“.  Допълнителната информация може да се\n"
"    използва за получаване на информация за състоянието на стека.\n"
"    \n"
"    Стойността на ИЗРАЗа показва за колко рамки спрямо текущата да се изведе\n"
"    информация.  Най-горната рамка е 0.\n"
"    \n"
"    Изходен код:\n"
"    Връща 0, освен ако обвивката изпълнява функция дефинирана в обвивката или\n"
"    ИЗРАЗът е грешен."

#: builtins.c:387
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
"    A null directory name is the same as the current directory.  If DIR begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is set,\n"
"    the word is assumed to be  a variable name.  If that variable has a value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Смяна на работната директория на обвивката.\n"
"    \n"
"    Смяна на текущата директория да е ДИРЕКТОРИЯ.  Променливата „HOME“ е\n"
"    стандартната директория.\n"
"    \n"
"    Променливата „CDPATH“ определя пътя за търсене на директории, които могат да\n"
"    съдържат ДИРЕКТОРИЯта.  Директориите в „CDPATH“ са разделени с „:“. \n"
"    Липсващо име на директория означава текущата директория, т.е. „.“. Ако името\n"
"    на ДИРЕКТОРИЯта започва с наклонена черта „/“, „CDPATH“ не се ползва.\n"
"    \n"
"    Ако директорията не е открита, но е зададена опцията на обвивката\n"
"    „cdable_vars“, то думата се пробва като име на променлива.  Ако променливата\n"
"    има стойност, то директорията се сменя към стойността на тази променлива.\n"
"    \n"
"    Опции:\n"
"      -L  налага следването на символните връзки.  Символните връзки в\n"
"          ДИРЕКТОРИЯта се обработват след указателите към горна директория „..“.\n"
"      -P  налага използването на фактическата подредба на директориите, вместо\n"
"          да се следват символните връзки.  Символните връзки в ДИРЕКТОРИЯта се\n"
"          обработват след указателите към горна директория „..“.\n"
"      -e  ако е използвана опцията „-P“ и текущата директория не може да бъде\n"
"          определена, командата завършва с ненулев изход.\n"
"      -@  на системите с поддръжка на разширени атрибути файлът се представя\n"
"          като директория, в която са атрибутите.\n"
"     \n"
"    Стандартно символните връзки се следват, все едно е зададена опцията „-L“\n"
"    \n"
"    Изходен код:\n"
"    Връща 0 при смяна на директорията.  Когато е зададена опцията „-P“, 0 се\n"
"    връща при успешно задаване на променливата „PWD„.  Във всички останали\n"
"    случаи изходът е ненулев."

#: builtins.c:425
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Извеждане на името на текущата работна директория.\n"
"    \n"
"    Опции:\n"
"      -L  извежда стойността на променливата „PWD“, ако тя съответства на\n"
"          текущата директория\n"
"      -P  извежда физическата директория без символни връзки\n"
"    \n"
"    Стандартно поведението на „pwd“ без аргументи съответства на „-L“.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е подадена неправилна опция или текущата директория не може да\n"
"    бъде прочетена."

#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Нулева команда.\n"
"    \n"
"    Без ефект — командата нищо не прави.\n"
"    \n"
"    Изходен код:\n"
"    Винаги завършва успешно."

#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Връщане на успешен резултат.\n"
"    \n"
"    Изходен код:\n"
"    Винаги завършва успешно."

#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Връщане на неуспешен резултат.\n"
"    \n"
"    Изходен код:\n"
"    Винаги завършва неуспешно."

#: builtins.c:471
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Изпълнение на нормална команда или извеждане на информация за команди.\n"
"    \n"
"    Изпълнение на КОМАНДАта с АРГументи, без тя да се търси като функция на\n"
"    обвивката, или извеждане на информация за указаните КОМАНДи.  Може да се\n"
"    използва за изпълнението на външни команди, дори когато съществува функция\n"
"    със същото име.\n"
"    \n"
"    Опции:\n"
"      -p  използване на стандартна стойност на PATH.  Така могат да се открият\n"
"          всички стандартни инструменти\n"
"      -v  извежда описание на КОМАНДАта подобно на вградената команда „type“\n"
"      -V  извежда по пълно описание на всяка КОМАНДА\n"
"    \n"
"    Изходен код:\n"
"    Връща изходния код на КОМАНДАта или грешка, ако такава не е открита."

#: builtins.c:490
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Задаване на стойности на променливите и атрибутите.\n"
"    \n"
"    Деклариране на променливи и задаване на атрибутите им.  Ако не са дадени\n"
"    ИМЕна се изобразяват атрибутите и стойностите на всички променливи.\n"
"    \n"
"    Опции:\n"
"      -f    Ограничаване на действието или извеждането до имената и дефинициите\n"
"            на функциите\n"
"      -F    Ограничаване на извеждането само до имената на функциите, заедно с\n"
"            номерата на редовете и изходните файлове при изчистване на грешките\n"
"      -g    Създаване на глобална променлива, когато опцията е употребена във\n"
"            функция.  В противен случай се пренебрегва\n"
"      -I    При създаването на локална променлива атрибутите и стойността ѝ да\n"
"            се вземат от променливата със същото име в предишната област на\n"
"            видимост\n"
"      -p    Извеждане на атрибутите и стойността на всяко ИМЕ\n"
"    \n"
"    Опции за задаването на атрибути:\n"
"      -a    ИМЕната да са на индексирани масиви (ако се поддържат)\n"
"      -A    ИМЕната да са асоциативни масиви  (ако се поддържат)\n"
"      -i    ИМЕната да са с атрибут „цяло число“\n"
"      -l    При присвояване на стойност тя да се преобразува в малки букви\n"
"      -n    ИМЕто да е указател към променливата с име, което е дадено от\n"
"            стойността\n"
"      -r    ИМЕната да са само за четене\n"
"      -t    ИМЕната да са с атрибут за трасиране\n"
"      -u    При присвояване на стойност тя да се преобразува в главни букви\n"
"      -x    ИМЕната да се изнасят към средата\n"
"    \n"
"    При използването на „+“ вместо „-“ атрибутът се изключва.\n"
"    \n"
"    При присвояването на стойност на променлива със зададен атрибут за цяло\n"
"    число се извършва аритметично изчисляване (вижте командата „let“).\n"
"    the `let' command).\n"
"    \n"
"    Когато се използва във функция, командата „declare“ прави ИМЕната локални,\n"
"    все едно се изпълнява командата „local“.  Опцията „-g“ предотвратява това\n"
"    поведение.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е зададена неправилна опция или възникне грешка при задаването\n"
"    на стойност на променлива."

#: builtins.c:532
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Задаване на стойност и атрибути на променливи.\n"
"    \n"
"    Синоним на „declare“.  Виж „help declare“."

#: builtins.c:540
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Дефиниране на локални променливи.\n"
"    \n"
"    Създаване на локална променлива с това ИМЕ и зададената СТОЙНОСТ.  ОПЦИЯта\n"
"    може да е всяка приемана от вградената команда „declare“.\n"
"    \n"
"    Локалните променливи могат да се използват само във функция.  Те са видими\n"
"    само в нея и нейните наследници.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е зададена неправилна ОПЦИЯ, възникне грешка при задаването на\n"
"    стойност на променлива, или в момента не се изпълнява функция."

#: builtins.c:557
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Извеждане на аргументите на стандартния изход.\n"
"    \n"
"    Извеждане на АРГУМЕНТите на стандартния изход разделени с интервали и\n"
"    последвани от нов ред.\n"
"    \n"
"    Опции:\n"
"      -n  не се извежда знак за нов ред.\n"
"      -e  включва се интерпретирането на знаците, изброени по-долу,  екранирани\n"
"           с обратна наклонена черта — „\\“\n"
"      -Е  изрично се спира интерпретирането на долните знаци\n"
"    \n"
"    „echo“ поддържа следните екранирани знаци:\n"
"      \\a  системен звънец\n"
"      \\b  триене назад\n"
"      \\c  пропускане на знака за нов ред\n"
"      \\e  знак за екраниране\n"
"      \\E  знак за екраниране\n"
"      \\f  знак „Завършване на формуляра“ (form feed)\n"
"      \\n  знак за нов ред\n"
"      \\r  знак „Връщане на каретката“ (carriage return)\n"
"      \\t  хоризонтална табулация\n"
"      \\v  вертикална табулация\n"
"      \\\\  обратно наклонена черта\n"
"      \\0nnn\n"
"          знакът с код в ASCII NNN (в осмична бройна система).\n"
"          NNN може да се състои от 1 до 3 осмични цифри.\n"
"      \\xHH\n"
"          знакът с код в ASCII HH (в шестнайсетична бройна система).\n"
"          HH може да се състои от 1 до 2 шестнайсетични цифри.\n"
"      \\uHHHH\n"
"          знакът с код в Unicode HHHH (в шестнайсетична бройна система).\n"
"          HHHH може да се състои от 1 до 4 шестнайсетични цифри.\n"
"      \\UHHHHHHHH\n"
"          знакът с код в Unicode HHHHHHHH (в шестнайсетична бройна система).\n"
"          HHHHHHHH може да се състои от 1 до 8 шестнайсетични цифри.\n"
"    \n"
"    Изходен код:\n"
"    Връща 0, освен ако не възникне грешка при извеждането."

#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Извеждане на аргументите на стандартния изход.\n"
"    \n"
"    Извеждане на АРГументите на стандартния изход последвани от знак за нов ред.\n"
"    \n"
"    Опции:\n"
"      -n        без извеждане на знак за нов ред\n"
"    \n"
"    Изходен код:\n"
"    Връща 0, освен ако възникне грешка при извеждането."

#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Включване и изключване на вградените в обвивката команди.\n"
"    \n"
"    Включване и изключване на командите вградени в обвивката.  Изключването\n"
"    позволява извикването на външна команда със същото име като вградена без\n"
"    използването на пълното име с пътя.\n"
"    \n"
"    Опции:\n"
"      -a    Извеждане на списъка с вградените команди заедно с това дали са\n"
"            включени или не\n"
"      -n    Изключване на вградените команди с посочените ИМЕна.  Ако не са\n"
"            дадени ИМЕна, се извежда списъкът с изключените вътрешни команди\n"
"      -p    Извеждане на списъка с вътрешни команди във формат, който може да\n"
"            се ползва като вход\n"
"      -s    Извеждане само на имената на специалните вградени команди според\n"
"            POSIX\n"
"    \n"
"    Опции за динамичното зареждане:\n"
"      -f    Зареждане на вградена команда с това ИМЕ от споделения обект в\n"
"            посочения ФАЙЛ\n"
"      -d    Премахване на вътрешна команда заредена с „-f“\n"
"    \n"
"    Ако не са зададени опции, всяка от вътрешните команди с такова ИМЕ бива\n"
"    включена.\n"
"    \n"
"    За да ползвате командата „test“, която се намира в пътя за изпълнение $PATH,\n"
"    вместо вградения в обвивката вариант изпълнете: „enable -n test“.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако ИМЕто не е на вградена команда или не възникне грешка."

#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Изпълнение на аргументите като команда на обвивката.\n"
"    \n"
"    Комбинира АРГументите в общ низ, който се подава като вход на обвивка,\n"
"    която изпълнява получените команди.\n"
"    \n"
"    Изходен код:\n"
"    Връща изходния код на командата или код за успех, ако командата е нулева."

#: builtins.c:652
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Анализиране на опциите и аргументите.\n"
"    \n"
"    getopts се използва от процедурите на обвивката за анализа на позиционните\n"
"    аргументи и опции.\n"
"    \n"
"    НИЗът_С_ОПЦИИ съдържа знаците, които трябва да се разпознават като опции.\n"
"    Ако буквата е следвана от двоеточие, очаква се опцията да получава аргумент,\n"
"    който да е разделен от нея с интервал(и).\n"
"    \n"
"    При всяко извикване „getopts“ поставя следващата опция в променливата на\n"
"    обвивката „name“, като я инициализира, ако тя не съществува, а индексът на\n"
"    следващия аргумент, който трябва да се обработи, в променливата на обвивката\n"
"    „OPTIND“.  „OPTIND“ се инициализира да е 1 при всяко извикване на обвивка\n"
"    или скрипт.  Когато опцията се нуждае от аргумент, той се поставя в\n"
"    променливата на обвивката „OPTARG“.\n"
"    \n"
"    „getopts“ докладва грешки по един от два начина.  Ако първият знак на\n"
"    „OPTSTRING“ е двоеточие, „getopts“ използва тихо докладване.  В този режим\n"
"    не се извеждат никакви съобщения за грешка.  Ако се срещне неправилна опция,\n"
"    „getopts“ слага срещнатия знак за опция в „OPTARG“.  Ако липсва задължителен\n"
"    аргумент, „getopts“ слага „:“ в променливата „ИМЕ“, а в „OPTARG“ — срещнатия\n"
"    знак за опция.  Когато „getopts“ не е в режим на тихо докладване и се срещне\n"
"    неправилна опция, в променливата „ИМЕ“ се слага „?“, а „OPTARG“ се премахва,\n"
"    а ако липсва задължителен аргумент, допълнително се изписва диагностично\n"
"    съобщение.\n"
"    \n"
"    Ако променливата на обвивката „OPTERR“ е със стойност 0, „getopts“ изключва\n"
"    извеждането на диагностични съобщения, дори първият знак в „OPTSTRING“ да не\n"
"    е двоеточие.  По подразбиране „OPTERR“ е със стойност 1.\n"
"    \n"
"    „getopts“ по принцип анализира позиционните аргументи, но ако аргументите са\n"
"    дадени като стойности на АРГУМЕНТИТЕ, те биват анализирани вместо това.\n"
"    \n"
"    Изходен код:\n"
"    Връща 0 при откриването на опция.  Връща друга стойност при стигането на\n"
"    последната опция или при възникването на грешка."

#: builtins.c:694
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"Заместване на обвивката с дадената команда.\n"
"    \n"
"    Изпълняване на КОМАНДАта, като тя замества текущата обвивка.  АРГУМЕНТите\n"
"    се подават на КОМАНДАта.  Ако не е дадена КОМАНДА, пренасочванията се\n"
"    извършват в текущата обвивка.\n"
"    \n"
"    Опции:\n"
"      -a  ИМЕ   ИМЕ-то се подава като нулевия аргумент на КОМАНДАта\n"
"      -c        изпълняване на КОМАНДАта в празна среда\n"
"      -l        поставяне на тире в нулевия аргумент на КОМАНДАта\n"
"    \n"
"    Ако КОМАНДАта не може да бъде изпълнена, трябва да съществува неинтерактивна\n"
"    обвивка, освен ако не е зададена опцията на обвивката „execfail“.\n"
"    \n"
"    Изходен код:\n"
"    0, освен когато КОМАНДАта не е открита или възникне грешка при\n"
"    пренасочването."

#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Изход от обвивката.\n"
"    \n"
"    Изход от обвивката с този ЦИФРОВ_КОД.  Ако той е изпуснат, то изходният код\n"
"    е този на последната изпълнена команда."

#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"Изход от входната обвивка.\n"
"    \n"
"    Изход от входната обвивка с този ЦИФРОВ_КОД.  Връща грешка, ако е изпълнена\n"
"    в обвивка, която не е входна."

#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"Извеждане и/или изпълнение на команди от историята.\n"
"    \n"
"    fc се използва за изброяването или редактирането и повторното изпълнение на\n"
"    команди от списъка на историята.\n"
"    ПЪРВИ и ПОСЛЕДЕН са номера, които могат да указват допустимия диапазон.  Ако\n"
"    е зададен само ПЪРВИят аргумент, той задава низ, който е началото на\n"
"    команда.\n"
"    \n"
"    Опции:\n"
"      -e  РЕДАКТОР\n"
"          избор на текстов редактор, който да се използва.  Стандартно е\n"
"          указаният в променливата „FCEDIT“, след това се проверява „EDITOR“ и\n"
"          в краен случай е „vi“.\n"
"      -l  редовете да се покажат вместо редактират.\n"
"      -n  номерата на редовете да не се отпечатват.\n"
"      -r  обратна подредба (отпред да е най-новият ред).\n"
"    \n"
"    При варианта „fc -s [ШАБЛОН=ЗАМЕСТИТЕЛ…] [КОМАНДА]“ командата се изпълнява, като\n"
"    всяка поява на ШАБЛона се заменя със ЗАМЕСТителя.\n"
"    \n"
"    Удобен за използване синоним е „r='fc -s'“.  По такъв начин, ако напишете\n"
"    „r cc“, ще се изпълни последната команда, която започва с „cc“, а когато\n"
"    се въведе само „r“, ще се изпълни последната команда.\n"
"    \n"
"    Изходен код:\n"
"    Връща 0 или изхода от последната команда, който не е 0 в случай на грешка."

#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Задаване на задача да е текуща.\n"
"    \n"
"    Изважда ЗАДАЧА от фонов режим и я прави текуща задача.  Ако липсва\n"
"    аргумент ЗАДАЧА, се използва текущата задача според обвивката.\n"
"    \n"
"    Изходен код:\n"
"    Изходът от командата, която е зададена да е текуща или грешка, ако при\n"
"    поставянето на задачата от фонов към текущ режим възникне такава."

#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Поставяне на задачи във фонов режим.\n"
"    \n"
"    Поставя всяка ЗАДАЧА във фонов режим, все едно е била стартирана с „&“.\n"
"    Ако липсва аргумент ЗАДАЧА, се използва текущата задача според обвивката.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако управлението на задачи е изключено или възникне грешка."

#: builtins.c:793
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Запомняне или извеждане на местоположенията на програми.\n"
"    \n"
"    Определяне и запомняне на пълното име с пътя на всяко ИМЕ.  Ако не са дадени\n"
"    аргументи, се извежда информация за всички запомнени команди.\n"
"    \n"
"    Опции:\n"
"      -d    Забравяне на запомненото местоположение на всички ИМЕна\n"
"      -l    Извеждане във формат за преизползване като вход\n"
"      -p ПЪТ\n"
"            Използване на посочения ПЪТ като пълен път за ИМЕто\n"
"      -r    Забравяне на всички запомнени местоположения\n"
"      -t    Извеждане на запомнените местоположения на всички ИМЕна.  Ако е\n"
"            посочено повече от едно ИМЕ, всяко местоположение се предшества от\n"
"            ИМЕто\n"
"    Аргументи:\n"
"      ИМЕ    Всяко име се търси в пътя за изпълнение „PATH“ и при намирането му\n"
"             се добавя в списъка със запомнени команди.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако ИМЕто не бъде открито или е дадена неправилна опция."

#: builtins.c:818
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"Извеждане на информация за вградените команди.\n"
"    \n"
"    Извежда кратка информация за вградените команди.  Ако е указан ШАБЛОН, се\n"
"    извежда информация за напасващите команди.  В противен случай се изважда\n"
"    информация за всички команди.\n"
"    \n"
"    Опции:\n"
"      -d    Извеждане на кратко описание на всяка тема\n"
"      -m    Извеждане във формат наподобяващ страница от ръководствата\n"
"      -s    Извеждане само на кратко обобщение за използването на всяка команда,\n"
"            съвпадаща с ШАБЛОНа\n"
"    \n"
"    Аргументи:\n"
"      ШАБЛОН  Шаблон за имената на командите, за които да се изведе информация\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако никоя вградена команда не съвпада с шаблона или е дадена\n"
"    неправилна опция."

#: builtins.c:842
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Извеждане и управление на списъка на историята.\n"
"    \n"
"    Отпечатване на списъка на историята с номера на ред.  Редовете, които са\n"
"    отбелязани със знака „*“, са били променени.  Аргументът N указва да се\n"
"    извеждат само N на брой реда.\n"
"    \n"
"    Опции:\n"
"    -c  изчистване на списъка, като се изтриват всички елементи от него.\n"
"    -d ПОЗИЦИЯ\n"
"        изтрива елемента в историята намиращ се посочената ПОЗИЦИЯ.\n"
"        Отрицателните позиции се броят от края на историята\n"
"    -a  добавя историята от текущата сесия към файла с историята.\n"
"    -n  прочитане на непрочетените редове от файла с историята и добавяне към\n"
"        текущата история.\n"
"    -r  прочитане на файла с историята и добавяне на съдържанието към текущата\n"
"        история.\n"
"    -w  записване на текущата история във файла за историята.\n"
"    -p  извършване на историческо заместване за всеки АРГУМЕНТ, а резултатът да\n"
"        се изведе, без нищо да се записва в историята на командите.\n"
"    -s  аргументите, които не са опции, се добавят като един елемент към файла с\n"
"        историята.\n"
"    \n"
"    Ако аргументът ИМЕ_НА_ФАЙЛ е зададен, той се използва като файл за\n"
"    историята. Ако той липсва, се използва файлът сочен в променливата на\n"
"    средата „HISTFILE“. В противен случай се ползва „~/.bash_history“.\n"
"    \n"
"    Ако променливата „HISTTIMEFORMAT“ е зададена и не е „null“, стойността ѝ се\n"
"    използва като форматиращия низ за функцията „strftime“, за да се отбелязва\n"
"    времето свързано с всеки елемент от историята.  В противен случай времето не\n"
"    се записва.\n"
"    \n"
"    Изходен код:\n"
"    0.  Ако възникне грешка или е подадена неправилна опция връща грешка."

#: builtins.c:879
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Извежда състоянието на задачите.\n"
"    \n"
"    Извежда списък с активните задачи.  ЗАДАЧАта ограничава информацията до\n"
"    себе си.  Без опции се отпечатва състоянието на всички активни задачи.\n"
"    \n"
"    Опции:\n"
"      -l  включва и идентификатора на процесите заедно със стандартната\n"
"          информация.\n"
"      -n  извеждат се само процесите с променено състояние от последното\n"
"          извеждане на тази информация.\n"
"      -p  извежда само идентификаторите на процесите.\n"
"      -r  ограничаване на изхода само до изпълняваните задачи.\n"
"      -s  ограничаване на изхода само до спрените задачи.\n"
"    \n"
"    Ако е зададена опцията „-x“, КОМАНДАта се изпълнява, след като всички\n"
"    ЗАДАЧи, които се появяват като АРГУМЕНТи, се заменят с идентификатора на\n"
"    водача на групата процеси.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако не е дадена неправилна опция или възникни грешка.  Ако се\n"
"    ползва „-x“, връща изходното състояние на КОМАНДАта."

#: builtins.c:906
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Премахване на ЗАДАЧи от текущата обвивка.\n"
"    \n"
"    Премахва всеки аргумент-задача от таблицата на активните задачи. Ако ЗАДАЧА\n"
"    не е указана, се използва тази, която обвивката счита за текуща.\n"
"    \n"
"    Опции:\n"
"      -a     премахване на всички задачи, когато не е дадена ЗАДАЧА\n"
"      -h     предотвратяване на препращането на сигнал SIGHUP към задачата,\n"
"             когато тази обвивка получи същия този сигнал\n"
"      -r     премахване само на стартираните задачи.\n"
"    \n"
"    Изходен код:\n"
"    0, освен когато е дадена неправилна опция или несъществуваща ЗАДАЧА."

#: builtins.c:925
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Изпращане на сигнал към задача.\n"
"    \n"
"    Изпращане на СИГНАЛа на процеса с такъв ИДЕНТИФИКАТОР_НА_ПРОЦЕС (или\n"
"    задачата с такъв ИДЕНТИФИКАТОР_НА_ЗАДАЧА).  Ако сигнал с такова име или\n"
"    номер не съществува, се използва SIGTERM.\n"
"    \n"
"    Опции:\n"
"      -s СИГНАЛ\n"
"          СИГНАЛ се интерпретира като име на сигнал\n"
"      -n СИГНАЛ\n"
"          СИГНАЛ се интерпретира като номер на сигнал\n"
"      -l  изброява имената на сигналите.  Ако към командата са добавени\n"
"          аргументи, те се интерпретират като номера на сигналите чиито имена\n"
"          да се изброят.\n"
"      -L  синоним на „-l“\n"
"    \n"
"    „kill“ е команда вградена в обвивката поради две причини: позволява да се\n"
"    използват и идентификатори на задачи освен идентификатори на процеси, а и\n"
"    ако сте пуснали максимално разрешения за вас брой процеси, няма да ви се\n"
"    налага да пуснете още един процес, за да убиете друг.\n"
"    \n"
"    Изходен код:\n"
"    0.  Ако възникне грешка или е подадена неправилна опция, връща грешка."

#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Изчисляване на аритметичен израз.\n"
"    \n"
"    Всеки АРГУМЕНТ е аритметичен израз, който се бъде изчислен.  Изчисленията\n"
"    се извършват в аритметика с целочислени стойности с постоянна широчина\n"
"    без проверка за препълване.  Делението на 0 се прихваща и се отбелязва\n"
"    грешка.  Следващият списък с оператори е разделен на групи според\n"
"    приоритета на операциите.  Подредбата е с намаляващ приоритет.\n"
"    \n"
"    id++, id--     последващо увеличаване/намаляване на променлива\n"
"    ++id, --id     предварително увеличаване/намаляване на променлива\n"
"    -, +           унарни минус, плюс\n"
"    !, ~           логическо и побитово отрицания\n"
"    **             вдигане на степен\n"
"    *, /, %        умножение, деление, целочислен остатък\n"
"    +, -           събиране, изваждане\n"
"    <<, >>         побитово местене наляво и надясно\n"
"    <=, >=, <, >   сравнение\n"
"    ==, !=         равно, различно\n"
"    &              побитово И\n"
"    ^              побитово изключващо ИЛИ\n"
"    |              побитово ИЛИ\n"
"    &&             логическо И\n"
"    ||             логическо ИЛИ\n"
"    ИЗРАЗ ? ИЗРАЗ : ИЗРАЗ\n"
"                   условен оператор\n"
"     =, *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, |=\n"
"                   присвояване\n"
"    \n"
"    Разрешено е ползването на променливи на обвивката като операнди.  Името на\n"
"    променлива се замества с нейната стойност (която се преобразува до цяло\n"
"    число с постоянна широчина) в израза.  Не е необходимо променливата да е с\n"
"    атрибут за целочисленост, за да се използва в израз.\n"
"    \n"
"    Операторите се изчисляват по приоритет.  Подизразите в скоби се изчисляват\n"
"    първи и могат да променят приоритета.\n"
"    \n"
"    Изходен код:\n"
"    Ако последният АРГУМЕНТ се изчислява като 0, „let“ връща 1. В противен\n"
"    случай — връща 0."

#: builtins.c:994
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters. By default, the backslash character escapes delimiter characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times out\n"
"    (in which case it's greater than 128), a variable assignment error occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Изчитане на ред от стандартния вход и разделянето му по полета.\n"
"    \n"
"    От стандартния вход или от файловия дескриптор ФД, ако е използвана опцията\n"
"    „-u“, се прочита един ред.  Редът се разделя на полета — думи.  Първата дума\n"
"    се присвоява на първото ИМЕ, втората дума на второто ИМЕ и т.н., а на\n"
"    последното ИМЕ се присвояват оставащите думи.   Като разделители на думи се\n"
"    използват само знаците указани в променливата „IFS“.  Стандартно знакът „\\“\n"
"    екранира разделителите и новите редове.\n"
"\n"
"    Ако не са дадени ИМЕна, прочетеният ред се запазва в променливата „REPLY“.\n"
"    \n"
"    Опции:\n"
"      -a  прочетените думи се присвояват последователно на елементите на МАСИВа,\n"
"          като индексът му започва от 0.\n"
"      -d РАЗДЕЛИТЕЛ\n"
"          четенето продължава до прочитането на първия знак, който присъства в\n"
"          променливата „DELIM“, а не до минаването на нов ред.\n"
"      -e  за четене на реда се използва readline\n"
"      -i ТЕКСТ\n"
"          за първоначален текст в readline се ползва ТЕКСТ\n"
"      -n БРОЙ_ЗНАЦИ\n"
"          четенето завършва след прочитането на този БРОЙ_ЗНАЦИ, не се чака за\n"
"          нов ред.  Разделител в рамките на този БРОЙ_ЗНАЦИ се зачита.\n"
"      -N БРОЙ_ЗНАЦИ\n"
"          четенето завършва с прочитането на точно този БРОЙ_ЗНАЦИ, освен ако\n"
"          не се появи EOF или времето за изчакване на въвеждане не изтече.\n"
"          Всички разделители се пренебрегват.\n"
"      -p ПОДСКАЗКА\n"
"          извежда низа ПОДСКАЗКА без минаване на нов ред, преди да започне\n"
"          четенето на знаци от входа.\n"
"      -r  заместването на екранираните с „\\“ знаци се изключва.\n"
"      -s  входът от терминал не се отпечатва на екрана.\n"
"      -t БРОЙ_СЕКУНДИ\n"
"          задава интервал от този БРОЙ_СЕКУНДИ, в който трябва да се въведе цял\n"
"          ред.  В противен случай read завършва с грешка. Ако е зададена,\n"
"          стойността на променливата „TMOUT“ обозначава времето, за което трябва\n"
"          да се въведе редът.  За БРОЙ_СЕКУНДИ може да се ползва и нецяло число.\n"
"          Ако БРОЙ_СЕКУНДИ e 0, read незабавно завършва работа, без да се опитва\n"
"          да чете данни и връща код 0, само ако от указания файлов дескриптор\n"
"          могат да се прочетат данни.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако не се срещне знак за край на файл EOF, изтече време повече от\n"
"    указаното в БРОЙ_СЕКУНДИ, при което кодът за изход е над 128, възникне\n"
"    грешка при задаване на стойност на променлива или е зададен неправилен\n"
"    файлов дескриптор като аргумент на -u."

#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Връщане от функция на обвивката.\n"
"    \n"
"    Кара изпълняваната функция или скрипт да завършат работа със зададения\n"
"    изходен ЦИФРОВ_КОД.  Ако не е зададен ЦИФРОВ_КОД се използва изходния код на\n"
"    последно изпълнената команда във функцията или скрипта.\n"
"    \n"
"    Изходен код:\n"
"    Връща ЦИФРОВия_КОД или грешка, ако обвивката в момента не изпълнява функция\n"
"    или скрипт."

#: builtins.c:1055
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Задаване или изтриване на позиционни параметри и опции на обвивката.\n"
"    \n"
"    Промяна на стойностите на позиционните параметри и опции на обвивката,\n"
"    Извеждане на имената и стойностите на променливите на обвивката.\n"
"    \n"
"    Опции:\n"
"      -a  Отбелязване на променливите, които са създадени или променени, да\n"
"          бъдат изнесени.\n"
"      -b  Незабавно известяване на спиране на задача.\n"
"      -e  Незабавен изход, ако команда приключи команда с код, който не е 0.\n"
"      -f  Изключване на генерирането на имена на файлове (чрез „*“, „?“ и т.н.).\n"
"      -h  Запомняне на местоположението на команди при търсенето им.\n"
"      -k  Всички аргументи за присвояване се поместват в средата на команда, не\n"
"          само тези, които предхождат името на команда.\n"
"      -m  Включване на управлението на задачи.\n"
"      -n  Прочитане на команди, без да се изпълняват.\n"
"      -o  ИМЕ_НА_ОПЦИЯ\n"
"          Задаване на променливата, която отговаря на ИМЕто_НА_ОПЦИЯ:\n"
"            allexport    същото като „-a“\n"
"            braceexpand  същото като „-B“\n"
"            emacs        интерфейс за редактиране подобен на „emacs“\n"
"            errexit      същото като „-e“\n"
"            errtrace     същото като „-E“\n"
"            functrace    същото като „-T“\n"
"            hashall      същото като „-h“\n"
"            histexpand   същото като „-H“\n"
"            history      включване на историята на командите\n"
"            ignoreeof    обвивката няма да излезе при откриване на знак за край\n"
"                         на файл „EOF“.\n"
"            interactive-comments\n"
"                         позволяване на коментари в интерактивните команди\n"
"            keyword      същото като „-k“\n"
"            monitor      същото като „-m“\n"
"            noclobber    същото като „-C“\n"
"            noexec       същото като „-n“\n"
"            noglob       същото като „-f“\n"
"            nolog        тази опция се приема в момента, но се игнорира\n"
"            notify       същото като „-b“\n"
"            nounset      същото като „-u“\n"
"            onecmd       същото като „-t“\n"
"            physical     същото като „-P“\n"
"            pipefail     изходният код на програмния канал е този на последната\n"
"                         команда, която завършва с код различен от 0\n"
"            posix        промяна на поведението на „bash“ да отговаря по-добре\n"
"                         на стандарта POSIX\n"
"            privileged   същото като „-p“\n"
"            verbose      същото като „-v“\n"
"            vi           използване на интерфейс за редактиране подобен на „vi“\n"
"            xtrace       същото като „-x“\n"
"      -p  Опцията e включена, когато реалният и ефективният идентификатори на\n"
"          процеси не съвпадат.  Изключва обработката на файла посочен в\n"
"          променливата „ENV“ и внасянето на функции на обвивката.  Изключването\n"
"          на тази опция води до това ефективните идентификатори за потребител и\n"
"          група да станат равни на реалните.\n"
"      -t  Изход след прочитането и изпълнението на една команда.\n"
"      -u  Незададените променливи да се третират като грешки при заместването.\n"
"      -v  Отпечатване на входните редове към обвивката при прочитането им.\n"
"      -x  Отпечатване на командите и аргументите им при изпълнението им.\n"
"      -B  Обвивката ще извършва заместване на изразите с фигурни скоби.\n"
"      -C  Предотвратяване на презаписването на съществуващите обикновени файлове\n"
"          чрез пренасочване на изхода.\n"
"      -E  Прихващането за „ERR“ да се наследява от функциите на обвивката.\n"
"      -H  Включване на заместването чрез историята с „!“.  Стандартно тази опция\n"
"          е налична само за интерактивните обвивки.\n"
"      -P  Да не се следват символните връзки при изпълнението на команди като\n"
"          „cd“, които променят текущата директория.\n"
"      -T  Прихващането за „DEBUG“ и „RETURN“ да се наследява от функциите на\n"
"          обвивката.\n"
"      --  Оставащите аргументи да се тълкуват като позиционни.  Ако няма повече\n"
"          аргументи, се изтриват съответните позиционни.\n"
"      -   Оставащите аргументи да се тълкуват като позиционни.  Опциите „-x“ и\n"
"          „-v“ са изключени.\n"
"    \n"
"    Използването на „+“ вместо „-“ изключва опциите.  Тези опции могат да се\n"
"    използват и при стартирането на обвивката.  Текущото им състояние се намира\n"
"    в променливата „-“ (получава се с „$-“).  Останалите АРГументи са позиционни\n"
"    и се присвояват съответно на променливите с имена „1“, „2“,… „n“  (получават\n"
"    се с „$1“, „$2“,… „${n}“).  Ако не са зададени АРГументи, се извеждат\n"
"    всички променливи на средата.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако не е зададена неправилна опция."

#: builtins.c:1140
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Изтриване на стойностите и атрибутите на променливите и функциите на обвивката.\n"
"    \n"
"    За всяко ИМЕ изтрива съответната променлива или функция.\n"
"    \n"
"    Опции:\n"
"      -f    всяко ИМЕ се тълкува като функция на обвивката\n"
"      -v    всяко ИМЕ се тълкува като променлива на обвивката\n"
"      -n    всяко ИМЕ се тълкува като променлива-указател — трие се самата\n"
"            променлива, а не тази, към която тя сочи\n"
"    \n"
"    Ако не са подадени опции, командата unset първо се опитва да изтрие\n"
"    променлива и след това функция с това ИМЕ.\n"
"    \n"
"    Някои променливи не могат да бъдат изтрити.  Вижте вградената команда\n"
"    „readonly“ (само за четене).\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е зададена неправилна опция или някое от ИМЕната е само за\n"
"    четене."

#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Задаване на атрибута за изнасяне на променливите на обвивката.\n"
"    \n"
"    Обозначава всяко едно от ИМЕната за изнасяне в средата на изпълнение на\n"
"    последващо изпълнените команди.  Ако е дадена СТОЙНОСТ, тя се присвоява на\n"
"    ИМЕто преди изнасянето.\n"
"    \n"
"    Опции:\n"
"      -f    ИМЕто е на функция на обвивката\n"
"      -n    Премахване на атрибута за изнасяне от всяко от ИМЕната\n"
"      -p    Извеждане на списък с имената на всички променливи и функции за\n"
"            изнасяне\n"
"    \n"
"    Аргументът „--“ прекъсва по нататъшната обработка на опции.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е зададена неправилна опция или някое от ИМЕната е неправилно."

#: builtins.c:1181
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Задаване на променливи на обвивката като непроменливи константи.\n"
"    \n"
"    Отбелязване на всяко от ИМЕната само за четене.  Тяхната стойност не може да\n"
"    бъде променяна чрез последващо присвояване.  Ако е дадена СТОЙНОСТ, тя се\n"
"    задава на името преди задаването му като константно.\n"
"    \n"
"    Опции:\n"
"      -a    ИМЕната са на променливи-масиви\n"
"      -A    ИМЕната са на променливи-асоциативни масиви\n"
"      -f    ИМЕната са на функции на обвивката\n"
"      -p    Извеждане на имената на всички константни променливи или функции, в\n"
"            зависимост дали е зададена опцията „-f“\n"
"    \n"
"    Аргументът „--“ прекъсва по нататъшната обработка на опции.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е зададена неправилна опция или някое от ИМЕната е неправилно."

#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Изместване на позиционните параметри.\n"
"    \n"
"    Преименуване на позиционните параметри „БРОЙ+1“, „БРОЙ+2“… на 1, 2….  Така\n"
"    те стават достъпни не като ${БРОЙ+1}…, като „$1“….  Ако не е зададена\n"
"    стойност БРОЙ, се използва 1.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако БРОят е отрицателно или по-голямо от стойността „$#“."

#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Изпълняване на команди от файл в текущата обвивка\n"
"    \n"
"    Изчитане и изпълнение на командите от ФАЙЛа и изход.  Директориите описани в\n"
"    променливата „PATH“ се използват за изпълнението на командите от ФАЙЛа.  Ако\n"
"    са зададени АРГУМЕНТИ, те се превръщат в позиционни аргументи при\n"
"    изпълнението на ФАЙЛа.\n"
"    \n"
"    Изходен код:\n"
"    Връща състоянието на последно изпълнената команда във ФАЙЛа.  Ако той не\n"
"    може да бъде открит, изходът е грешка."

#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Временно спиране на изпълнението на обвивката.\n"
"    \n"
"    Спиране на работата на тази обвивка докато обвивката не получи сигнал\n"
"    SIGCONT.  Освен ако изрично не се зададе опция, входните обвивки не могат да\n"
"    бъдат спрени по този начин.\n"
"    \n"
"    Опции:\n"
"      -f    Задължително спиране, дори и ако обвивката е входяща\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако не възникне грешка или управлението на задачи е изключено."

#: builtins.c:1262
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Изчисляване на условен израз.\n"
"    \n"
"    Изход с код 0 (истина) или 1 (лъжа) в зависимост от стойността на ИЗРАЗа.\n"
"    Изразите могат да бъдат унарни или бинарни.  Унарните най-често се използват\n"
"    за проверка на състоянието на файл.  Освен тях има и оператори за числови\n"
"    сравнения и низови оператори.\n"
"    \n"
"    Поведението на тестовете зависи от броя на аргументите.  За цялостно\n"
"    описание прочетете страниците от ръководството на bash.\n"
"    \n"
"    Файлови оператори:\n"
"    \n"
"      -a ФАЙЛ    Истина, ако ФАЙЛът съществува.\n"
"      -b ФАЙЛ    Истина, ако ФАЙЛът е блоково устройство.\n"
"      -c ФАЙЛ    Истина, ако ФАЙЛът е знаково устройство.\n"
"      -d ФАЙЛ    Истина, ако ФАЙЛът е директория.\n"
"      -e ФАЙЛ    Истина, ако ФАЙЛът съществува.\n"
"      -f ФАЙЛ    Истина, ако ФАЙЛът съществува и е обикновен файл.\n"
"      -g ФАЙЛ    Истина, ако ФАЙЛът е със зададен бит за смяна на група\n"
"                 при изпълнение.\n"
"      -h ФАЙЛ    Истина, ако ФАЙЛът е символна връзка.\n"
"      -L ФАЙЛ    Истина, ако ФАЙЛът е символна връзка.\n"
"      -k ФАЙЛ    Истина, ако ФАЙЛът е със зададен лепкав бит.\n"
"      -p ФАЙЛ    Истина, ако ФАЙЛът е именуван програмен канал.\n"
"      -r ФАЙЛ    Истина, ако ФАЙЛът може да бъде прочетен от вас.\n"
"      -s ФАЙЛ    Истина, ако ФАЙЛът може да бъде записван от вас.\n"
"      -S ФАЙЛ    Истина, ако ФАЙЛът е програмно гнездо.\n"
"      -t ФДСК    Истина, ако Файловият_ДеСКриптор е отворен на терминал.\n"
"      -u ФАЙЛ    Истина, ако ФАЙЛът е със зададен бит за смяна на потребител\n"
"                 при изпълнение.\n"
"      -w ФАЙЛ    Истина, ако ФАЙЛът може да бъде записван от вас.\n"
"      -x ФАЙЛ    Истина, ако ФАЙЛът може да бъде изпълняван от вас.\n"
"      -O ФАЙЛ    Истина, ако ФАЙЛът може да бъде ефективно притежаван от вас.\n"
"      -G ФАЙЛ    Истина, ако ФАЙЛът може да бъде ефективно притежаван от вашата\n"
"                 група.\n"
"      -N ФАЙЛ    Истина, ако ФАЙЛът е бил променян от последното му прочитане.\n"
"    \n"
"      ФАЙЛ_1 -nt ФАЙЛ_2    Истина, ако ФАЙЛ_1 е по-нов от ФАЙЛ_2 (според\n"
"                           датата на промяна).\n"
"      ФАЙЛ_1 -ot ФАЙЛ_2    Истина, ако ФАЙЛ_1 е по-стар от ФАЙЛ_2 (според\n"
"                           датата на промяна).    \n"
"      ФАЙЛ_1 -ef ФАЙЛ_2    Истина, ако ФАЙЛ_1 е твърда връзка към ФАЙЛ_2.\n"
"    \n"
"    Низови оператори:\n"
"    \n"
"      -z НИЗ     Истина, ако НИЗът е празен.\n"
"      -n НИЗ     Истина, ако НИЗът не е празен.\n"
"      НИЗ        Истина, ако НИЗът не е празен.\n"
"    \n"
"      НИЗ_1  = НИЗ_2    Истина, ако низовете са равни.\n"
"      НИЗ_1 != НИЗ_2    Истина, ако низовете не са равни.\n"
"      НИЗ_1  < НИЗ_2    Истина, ако НИЗ_1 е лексикографски преди НИЗ_2.\n"
"      НИЗ_1  > НИЗ_2    Истина, ако НИЗ_1 е лексикографски след НИЗ_2.\n"
"    \n"
"    Други оператори:\n"
"    \n"
"      -o ОПЦИЯ              Истина, ако ОПЦИЯта на обвивката е зададена.\n"
"      -v ПРОМЕНЛИВА         Истина, ако ПРОМЕНЛИВАта на обвивката е зададена.\n"
"      -R ПРОМЕНЛИВА         Истина, ако ПРОМЕНЛИВАта е зададена като променлива-\n"
"                            указател.\n"
"      ! ИЗРАЗ               Истина, ако ИЗРАЗът е лъжа.\n"
"      ИЗРАЗ_1 -a ИЗРАЗ_2    Истина, ако и двата ИЗРАЗа са истина.\n"
"      ИЗРАЗ_1 -o ИЗРАЗ_2    Истина, ако поне един от ИЗРАЗите е истина.\n"
"      АРГ_1 ОПЕР АРГ_2      Аритметични тестове.  Те връщат истина, ако се\n"
"                            изпълнява математическото условие на ОПЕРатора,\n"
"                            който е един от следните (значението е в скоби):\n"
"                            „-eq“ (=),  „-ne“ (!=), „-lt“ (<), „-le“ (<=),\n"
"                            „-gt“ (>) , „-ge“ (>=).\n"
"    \n"
"    Аритметичните изрази завършват истинно, ако АРГумент_1 е съответно равен,\n"
"    неравен, по-малък, по-малък или равен, по-голям, по-голям или равен на\n"
"    АРГумент_2.\n"
"    \n"
"    Изходен код:\n"
"    0, ако ИЗРАЗът е верен.  Грешка, когато ИЗРАЗът е неверен или е даден\n"
"    неправилен аргумент."

#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Изчисляване на условен израз.\n"
"    \n"
"    Това е синоним на вградената команда „test“, но последният аргумент трябва\n"
"    задължително да е знакът „]“, който да съответства на отварящата квадратна\n"
"    скоба „[“."

#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Извеждане на времето на работа на процесите.\n"
"    \n"
"    Отпечатва общото потребителско и системно време на работа на обвивката и\n"
"    всичките ѝ дъщерни процеси.\n"
"    \n"
"    Изходен код:\n"
"    Винаги 0."

#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or a\n"
"    script run by the . or source builtins finishes executing.  A SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is given."
msgstr ""
"Прихващане на сигналите и другите събития.\n"
"    \n"
"    Дефинира и задейства функции за обработка, когато обвивката получи сигнал\n"
"    или възникне друго събитие.\n"
"    \n"
"    Командата АРГУМЕНТ ще бъде прочетена и изпълнена, когато обвивката получи\n"
"    УКАЗАНия_СИГНАЛ(и).  Ако АРГУМЕНТът липсва (и се подава единичен\n"
"    УКАЗАН_СИГНАЛ) или е „-“, то всеки УКАЗАН_СИГНАЛ се връща към първоначалната\n"
"    си стойност.  Ако АРГУМЕНТът е нулевият низ, всеки УКАЗАН_СИГНАЛ се\n"
"    пренебрегва от обвивката и командите, които се стартират през нея.\n"
"    \n"
"    Ако УКАЗАНият_СИГНАЛ е „EXIT (0)“, то командата АРГУМЕНТ се изпълнява от\n"
"    обвивката при изход.  Ако УКАЗАНият_СИГНАЛ е „DEBUG“, АРГУМЕНТът се\n"
"    изпълнява след всяка проста команда.  Ако УКАЗАНият_СИГНАЛ е „RETURN“,\n"
"    АРГУМЕНТът се изпълнява след всяко изпълнение на функция както и изпълнение\n"
"    на скрипт чрез вградените команди „.“ и „source“.  Ако УКАЗАНият_СИГНАЛ е\n"
"    „ERR“, АРГУМЕНТът се изпълнява след всяка грешка, която би предизвикала\n"
"    изход от обвивката при стартирането ѝ с опцията „-e“.\n"
"    \n"
"    Ако не са дадени аргументи, се отпечатват командите присвоени на всички\n"
"    прихващания.\n"
"    \n"
"    Опции:\n"
"      -l  отпечатва списъка с имената на сигналите и съответстващите им номера.\n"
"      -p  извеждат се командите свързани с всеки УКАЗАН_СИГНАЛ.\n"
"    \n"
"    Всеки УКАЗАН_СИГНАЛ е или име на сигнал от файла „signal.h“ или номер на\n"
"    сигнал.\n"
"    Няма разлика между главни и малки букви в имената на сигнали, а представката\n"
"    „SIG“ не е задължителна.\n"
"    Сигнал може да бъде изпратен на обвивката с командата „kill -signal $$“.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е зададен неправилен сигнал или опция."

#: builtins.c:1401
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"Извеждане на информация за вида на командата подадена като аргумент.\n"
"    \n"
"    За всяко ИМЕ се извежда как ще се интерпретира, когато се използва като\n"
"    команда.\n"
"    \n"
"    Опции:\n"
"      -a    Извеждане на всички местоположения, които съдържат изпълним файл с\n"
"            това ИМЕ.  Включва синонимите, вградените команди и функции на\n"
"            обвивката, само когато не е използвана опцията „-p“\n"
"      -f    Без търсене във функциите дефинирани в обвивката\n"
"      -P    Търсене в пътя за изпълнение указан в PATH, дори и ако съществува\n"
"            синоним, вградена команда или функция дефинирана в обвивката с това\n"
"            ИМЕ\n"
"      -p    Връща или името на файла, който ще бъде изпълнен или нищо в\n"
"            случаите, когато командата „type -t ИМЕ“ не би върнала „file“\n"
"      -t    Извеждане на една от думите „alias“ (синоним), „keyword“\n"
"            (резервирана лексема в обвивката), „function“ (функция дефинирана в\n"
"            обвивката), „builtin“ (вградена команда), „file“ (изпълним файл) или\n"
"            „“, ако ИМЕто не е открито\n"
"    \n"
"    Аргументи:\n"
"      ИМЕ    Името, за което да се изведе информация.\n"
"    \n"
"    Изходен код:\n"
"    0, ако всички подадени ИМЕна са открити, неуспех, ако някое от тях липсва."

#: builtins.c:1432
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Промяна на ресурсите на обвивката.\n"
"    \n"
"    Командата осъществява контрол върху ресурсите, които са достъпни на\n"
"    процесите стартирани през обвивката върху системите, които поддържат такова\n"
"    управление.\n"
"    \n"
"    Опции:\n"
"      -S    използване на „мекото“ ограничение на ресурс\n"
"      -H    използване на „твърдото“ ограничение на ресурс\n"
"      -a    извеждат се всички текущи ограничения\n"
"      -b    размер на буфера за програмните гнезда\n"
"      -c    максималният размер на създадените файлове със съдържание на\n"
"            паметта (core)\n"
"      -d    максималният размер на сегмента на процес за данни\n"
"      -e    максималният приоритет (nice)\n"
"      -f    максималният размер на файловете създадени от обвивката и дъщерните\n"
"            ѝ процеси\n"
"      -i    максималният брой на изчакващите сигнали\n"
"      -l    максималният размер памет, която процес може да заключи\n"
"      -m    максималният постоянно зареден в паметта сегмент\n"
"      -n    максималният брой дескриптори на отворени файлове\n"
"      -p    размер на буфера за програмни канали\n"
"      -q    максималният брой байтове в опашките за съобщения по POSIX\n"
"      -r    максималният приоритет за реално време\n"
"      -s    максималният размер на стека\n"
"      -t    максималното процесорно време в секунди\n"
"      -u    максималният брой потребителски процеси\n"
"      -v    размерът на виртуалната памет\n"
"      -x    максималният брой заключвания на файлове\n"
"      -P    максималният брой псевдотерминали\n"
"      -R    максималният брой процеси в реално време преди блокиране\n"
"      -T    максималният брой нишки\n"
"    \n"
"    Не всички ограничения са налични на всички платформи.\n"
"    \n"
"    Ако е зададено ОГРАНИЧЕНИЕ, то това е новата стойност на указания ресурс.\n"
"    Специалните стойности „soft“, „hard“ и „unlimited“ означават текущите меко,\n"
"    твърдо и никакво ограничение съответно.  В противен случай се извежда\n"
"    текущата стойност на указания ресурс.  Ако не е зададена опция, се приема,\n"
"    че е зададена „-f“.\n"
"    \n"
"    Стойностите са в блокове от по 1024 байта, с изключение на:\n"
"      ⁃ опцията „-t“, при която стойността е в секунди;\n"
"      ⁃ опцията „-p“, при която блоковете са от по 512 байта;\n"
"      ⁃ опцията „-u“, при която стойността е точният брой процеси.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако не възникни грешка или е дадена неправилна опция."

#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Извеждане или промяна на маската за достъпа до новосъздадени файлове.\n"
"    \n"
"    Задава МАСКАта за правата за достъп до новосъздадени файлове.  Ако не е\n"
"    зададена МАСКА, се извежда текущата ѝ стойност.\n"
"    \n"
"    Ако МАСКАта започва с цифра, тя се тълкува като осмично число.  В противен\n"
"    случай трябва да е низ, който би бил приет от командата chmod(1).\n"
"    \n"
"    Опции:\n"
"      -p    ако не е зададена МАСКА, изведеният низ може да бъде ползван за вход\n"
"      -S    изведената маска да е във вид на НИЗ.  Без опцията изходът е осмично\n"
"            число\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако МАСКАта или някоя от зададените опции са неправилни."

#: builtins.c:1503
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Изчакване на завършването задача и връщане на изходния код.\n"
"    \n"
"    Изчакване на всички указани ИДентификатори, които могат да са номера на\n"
"    процеси или указатели на задачи, и докладване на изходния код.  Ако не е\n"
"    зададен ИДентификатор, се изчакват всички активни дъщерни процеси, а\n"
"    изходният код е 0.  Ако ИДентификаторът е указател на задача, се изчакват\n"
"    всички процеси в конвейера на задачата.\n"
"    \n"
"    Ако е зададена опцията „-n“, се изчаква края на работата на някоя от\n"
"    задачите в списъка от указаните ИДентификатори, а ако такъв липсва — края на\n"
"    следващата задача и се връща нейния изходен код.\n"
"    \n"
"    Ако е зададена опцията „-p“, номерът на процес или указателят на задача,\n"
"    чийто изходени код се връща, се присвоява на ПРОМЕНЛИВАта, зададена като\n"
"    аргумент.  Преди първоначалното присвояване променливата няма да е зададена.\n"
"    Това е полезно, само когато е използвана опцията „-n“.\n"
"    \n"
"    Ако е зададена опцията „-f“ и управлението на задачите е включено, се\n"
"    изчаква завършването на процеса/задачата с указаните ИДентификатори вместо\n"
"    да се изчаква смяната на състоянието им.\n"
"    \n"
"    Изходен код:\n"
"    Връща изходния код на последната задача или процес.  Ако е зададена\n"
"    неправилна опция или неправилен ИДентификатор, връща грешка.  Грешка се\n"
"    връща и при задаването на опцията „-n“, а обвивката няма дъщерни процеси,\n"
"    които не се чакат."

#: builtins.c:1534
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an invalid\n"
"    option is given."
msgstr ""
"Изчакване на указания процес и докладване за изходния код.\n"
"    \n"
"    Изчакване на всички указани процеси и докладване за изходния код.  Ако не е\n"
"    зададен ИДентификатор_ПРоцeс, всички текущо активни дъщерни процеси се\n"
"    изчакват и изходният код е 0.  ИДентификатор_ПРоцeс трябва да съответства на\n"
"    някой процес.\n"
"    \n"
"    Изходен код:\n"
"    Изходния код на процеса с последния идентификатор.  Грешка, ако е даден\n"
"    неправилен идентификатор или е дадена неправилна опция."

#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Изпълнение на команда за всеки член в списък от елементи\n"
"    \n"
"    Цикълът „for“ изпълнява последователност от команди за всеки член в списък\n"
"    от елементи.  Ако блокът „в ДУМИ…“ не присъства, използва се „in \"$@\"“.\n"
"    За всеки елемент в ДУМИте, ИМЕто се задава да е елементът и се изпълняват\n"
"    КОМАНДИте.\n"
"    \n"
"    Изходен код:\n"
"    Връща изходния код на последно изпълнената команда."

#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Аритметичен цикъл чрез „for“\n"
"    Еквивалентно на:\n"
"      (( ИЗРАЗ_1 ))\n"
"      while (( ИЗРАЗ_2 )); do\n"
"        КОМАНДИ\n"
"        (( EXP_3 ))\n"
"      done\n"
"    ИЗРАЗ_1, ИЗРАЗ_2, и ИЗРАЗ_3 са аритметични изрази.  Всеки изпуснат израз се\n"
"    изчислява да е 1.\n"
"    \n"
"    Изходен код:\n"
"    Връща изходния код на последно изпълнената команда."

#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Избор на думи от списък и изпълнение на команди.\n"
"    \n"
"    ДУМИте биват замествани, което води до създаването на списък с думи.\n"
"    Наборът от заместените думи бива отпечатан на изхода за стандартната\n"
"    грешка, като всяка от тях се предшества от номер.  Ако клаузата „in ДУМИ“\n"
"    липсва, използва се „in \"$@\"“.  В такива случаи се отпечатва подсказката\n"
"    „PS3“ и от стандартния вход се прочита ред.  Ако редът се състои от номера,\n"
"    който съответства на някоя от изведените думи, ИМЕто се задава да е тази\n"
"    дума.  Ако редът е празен, отново се отпечатват ДУМИте и подсказката.  Ако\n"
"    се прочете „EOF“, командата завършва.  Всяка друга стойност присвоява „null“\n"
"    на ИМЕ.  Прочетеният ред се запазва в променливата REPLY.  КОМАНДИте се\n"
"    изпълняват след всеки избор до изпълняването на команда за прекъсване\n"
"    (break).\n"
"    \n"
"    Изходен код:\n"
"    Връща изходния код на последно изпълнената команда."

#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Отпечатване на времето за изпълнение на програмен канал.\n"
"    \n"
"    Изпълнение на ПРОГРАМНия_КАНАЛ и отпечатване на обобщение за реалното,\n"
"    потребителското и системно процесорни времена, които изпълнението на\n"
"    ПРОГРАМНия_КАНАЛ отнема.\n"
"    \n"
"    Опции:\n"
"      -p:  извеждане на статистиката за времето във формат POSIX\n"
"    \n"
"    Стойността на променливата на средата „TIMEFORMAT“ определя изходния\n"
"    формат.\n"
"    \n"
"    Изходен код:\n"
"    Изходният код е този на ПРОГРАМНия_КАНАЛ."

#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Изпълнение на команди на базата на напасване по шаблон.\n"
"    \n"
"    Избирателно се изпълняват КОМАНДИ на база ДУМА, която напасва на ШАБЛОН.\n"
"    Шаблоните се разделят със знака „|“.\n"
"    \n"
"    Изходен код:\n"
"    Изходният код е този на последно изпълнената команда."

#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Изпълнение на команда на базата на условие.\n"
"    \n"
"    Първо се изпълняват командите в блока „if КОМАНДИ“.  Ако изходният код е 0,\n"
"    то се изпълнява блокът „then КОМАНДИ“.  В противен случай последователно се\n"
"    изпълнява всеки блок „elif КОМАНДИ“ — ако изходният код е 0, то се изпълнява\n"
"    съответния блок „then КОМАНДИ“, след което завършва изпълнението на целия\n"
"    блок „if“.\n"
"    Ако изходният код на никой от блоковете „if“ и „elif“ не е бил 0,\n"
"    изпълнява се блока „else КОМАНДИ“, стига такъв да присъства.  Изходният код\n"
"    от цялата конструкция е този на последната изпълнена команда или е 0, ако\n"
"    никое тестово условие, не се е оценило като истина.\n"
"    \n"
"    Изходен код:\n"
"    Изходният код е този на последно изпълнената команда."

#: builtins.c:1648
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Изпълнение на команда докато определен тест е успешен.\n"
"    \n"
"    Заместване и изпълнение на КОМАНДИ_2 докато последната команда в блока\n"
"    КОМАНДИ е с изходен код, който е 0.\n"
"    \n"
"    Изходен код:\n"
"    Изходният код е този на последно изпълнената команда."

#: builtins.c:1660
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Изпълнение на команда докато определен тест е неуспешен.\n"
"    \n"
"    Заместване и изпълнение на КОМАНДИ_2 докато последната команда в блока\n"
"    КОМАНДИ е с изходен код, който не е 0.\n"
"    \n"
"    Изходен код:\n"
"    Изходният код е този на последно изпълнената команда."

#: builtins.c:1672
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Създаване на копроцес с даденото ИМЕ.\n"
"    \n"
"    Асинхронно изпълнение на КОМАНДАта, като стандартните вход и изход се\n"
"    пренасочват от и към файловите дескриптори, които трябва да са с индекси\n"
"    съответно 0 и 1 в променливата-масив ИМЕ в изпълняваната обвивка.  Ако не е\n"
"    дадено ИМЕ на променлива, стандартно се ползва „COPROC“.\n"
"    \n"
"    Изходен код:\n"
"    Изходният код е 0."

#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Дефиниране на функция на обвивката.\n"
"    \n"
"    Създаване на функция на обвивката със зададеното ИМЕ.  Когато се извика като\n"
"    обикновена команда, КОМАНДИте се изпълняват в контекста на  извикващата\n"
"    обвивка.  При извикването на ИМЕто, аргументите подадени на функцията са\n"
"    достъпни като $1,… , $9, а името на функцията е достъпно като $FUNCNAME.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако ИМЕто не е само за четене."

#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Изпълнение на група от команди.\n"
"    \n"
"    Изпълняване на цял набор от команди в група.  Това е един от начините да се\n"
"    пренасочи цял набор от команди.\n"
"    \n"
"    Изходен код:\n"
"    Изходният код е този на последно изпълнената команда."

#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Възобновяване на заден фон на изпълнението на задача\n"
"    \n"
"    Еквивалентно на аргумента ЗАДАЧА на командата „fg“.  Възобновява спряна\n"
"    задача или такава на заден фон.  ЗАДАЧАта може да указва или име, или\n"
"    номер на задача.  Ако след ЗАДАЧАта се въведе знакът „&“, задачата\n"
"    се изпълнява във фонов режим, все едно е била подадена като аргумент\n"
"    на командата „bg“.\n"
"    \n"
"    Изходен код:\n"
"    Изходният код е този възобновената задача."

#: builtins.c:1727
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Изчисляване на аритметичен израз\n"
"    \n"
"    ИЗРАЗът се изчислява според правилата на аритметичното оценяване.\n"
"    Еквивалентно на „let \"ИЗРАЗ\"“.\n"
"    \n"
"    Изходен код:\n"
"    1, ако резултатът на ИЗРАЗа е 0.  В противен случай — 0."

#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Изпълнение на команда-условие\n"
"    \n"
"    Връща състояние 0 или 1 в зависимост от оценката на условния ИЗРАЗ.\n"
"    Изразите са съставени от същите примитиви, както вградената команда „test“\n"
"    и могат да се съчетават чрез следните оператори:\n"
"    \n"
"      ( ИЗРАЗ )  Връща стойността на ИЗРАЗа\n"
"      ! ИЗРАЗ    Истина, ако ИЗРАЗ се оценя на лъжа, в останалите случаи е лъжа\n"
"      ИЗРАЗ_1 && ИЗРАЗ_2\n"
"                 Истина, ако едновременно ИЗРАЗ_1 и ИЗРАЗ_2 са истина, в\n"
"                 останалите случаи е лъжа.\n"
"      ИЗРАЗ_1 || ИЗРАЗ_2\n"
"                 Истина, ако поне единият от ИЗРАЗ_1 и ИЗРАЗ_2 е истина, в\n"
"                 останалите случаи е лъжа.\n"
"    \n"
"    Когато се използват операторите „==“ и „!=“, низът от дясната страна на\n"
"    оператора се използва като шаблон и се извършва напасване.  Когато се ползва\n"
"    операторът „=~“, изразът от дясната му страна се тълкува като регулярен\n"
"    израз.\n"
"    \n"
"    Операторите „&&“ и „||“ не оценят ИЗРАЗ_2, ако ИЗРАЗ_1 е достатъчен за\n"
"    определяне на стойността на израза.\n"
"    \n"
"    Изходен код:\n"
"    0 или едно според стойността на ИЗРАЗа."

#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Често използване промени на обвивката\n"
"    \n"
"    BASH_VERSION    Информация за версията на bash\n"
"    CDPATH          Списък с директории разделени с двоеточие, които да се\n"
"                    търсят като аргументи за командата „cd“\n"
"    GLOBIGNORE      Списък с шаблони на файлови имена, разделени с двоеточие,\n"
"                    които да се игнорират от заместването на пътя\n"
"    HISTFILE        Името на файла, в който се съхранява историята на командите\n"
"    HISTFILESIZE    Максималният брой редове, които горният файл може да съдържа\n"
"    HISTSIZE        Максималният брой редове, които една работеща обвивка може\n"
"                    да достъпи\n"
"    HOME            Пълният път до домашната ви директория\n"
"    HOSTNAME        Името на текущата машина\n"
"    HOSTTYPE        Видът на процесора, под който работи текущата обвивка\n"
"    IGNOREEOF       Управлява действието на обвивката при срещането на единичен\n"
"                    знак за край на файл „EOF“.  Ако променливата е зададена, тя\n"
"                    указва броя на знаците „EOF“, който могат да се срещнат\n"
"                    самостоятелно на един ред, преди обвивката да завърши работа\n"
"                    и излезе (стандартно е 10).  Когато променливата не е\n"
"                    зададена, един „EOF“ означава край на входящите данни\n"
"    MACHTYPE        Низ, който описва текущата система, на която работи bash\n"
"    MAILCHECK       Колко често bash да проверява за нови писма (в секунди)\n"
"    MAILPATH        Списък с файлове, които bash проверява за нови писма\n"
"    OSTYPE          Версията на Юникс, на която работи bash\n"
"    PATH            Списък с директории, които да се претърсват за команди\n"
"    PROMPT_COMMAND  Команда, която да се изпълнява преди отпечатването на\n"
"                    основната подсказка на командния ред\n"
"    PS1             Низ за основната подсказка\n"
"    PS2             Низ за втората подсказка\n"
"    PWD             Пълният път и име на текущата директория\n"
"    SHELLOPTS       Списък с включените опции на обвивката, разделени с\n"
"                    двоеточие\n"
"    TERM            Името на текущия вид терминал\n"
"    TIMEFORMAT      Изходният формат за статистиката за времето за изпълнение на\n"
"                    команда, който се използва от запазената дума „time“\n"
"    auto_resume     Стойност, която не е „null“, означава, че командна дума,\n"
"                    която се появява самостоятелно на ред, първо се проверява в\n"
"                    списъка с текущо спрените задачи.  Ако бъде открита там,\n"
"                    задачата се пуска и се слага на преден план.  Стойност\n"
"                    „exact“ (строго съвпадение) означава, че командната дума,\n"
"                    трябва точно да съвпада с името на команда в списъка със\n"
"                    спрени задачи.  Стойност „substring“ (съвпадение на подниз)\n"
"                    означава, че командната дума трябва да е подниз на задачата.\n"
"                    Всяка друга стойност означава, че командата думата трябва да\n"
"                    е началото на спряна задача\n"
"    histchars       Знаци, които определят бързото заместване и това по история.\n"
"                    Първият знак е за заместването по история, обикновено е „!“.\n"
"                    Вторият е за бързото заместване, обикновено е „^“.  Третият\n"
"                    е за коментарите в историята, обикновено е „#“\n"
"    HISTIGNORE      Списък с шаблони, разделени с двоеточие, които указват кои\n"
"                    команди да не се запазват в историята\n"

#: builtins.c:1822
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Добавяне на директории в стека.\n"
"    \n"
"    Добавя директория в стека на директориите или превърта стека\n"
"    като най-горна директория става текущата директория.  Без\n"
"    аргументи сменя най-горните две директории.\n"
"    \n"
"    -n  подтискане на нормалното преминаване към директория при изваждането на\n"
"        директория към стека, така че се променя само той.\n"
"    \n"
"    Аргументи:\n"
"      +N   Превърта стека, така че N-тата директория (като се брои от лявата \n"
"           страна на списъка, изведен от командата „dirs“ като се почва от 0)\n"
"           да е най-отгоре.\n"
"    \n"
"      -N   Превърта стека, така че N-тата директория (като се брои от дясната\n"
"           страна на списъка, изведен от командата „dirs“ като се почва от 0)\n"
"           да е най-отгоре.\n"
"    \n"
"    \n"
"      dir  Добавя ДИРекторията най-отгоре в стека, като я прави новата текуща\n"
"           работна директория.\n"
"    \n"
"    Можете да изведете стека на директорията с командата „dirs“.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е подаден неправилен аргумент или не може да се премине към\n"
"    съответната директория."

#: builtins.c:1856
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Изваждане на директории от стека.\n"
"    \n"
"    Маха директории от стека с тях. Без аргументи премахва последната директория\n"
"    в стека и влиза в новата последна директория.\n"
"    \n"
"    Опции:\n"
"    -n  подтискане на нормалното преминаване към директория при изваждането на\n"
"        директория към стека, така че се променя само той.\n"
"    \n"
"    Аргументи:\n"
"    \n"
"    +N  премахва N-тия елемент като се брои отляво в списъка изведен от\n"
"        командата „dirs“, като се брои от 0.  Напр.: „popd +0“ премахва\n"
"        първата директория, „popd +1“ - втората.\n"
"    \n"
"    -N  премахва N-тия елемент като се брои отдясно в списъка изведен от\n"
"        командата „dirs“, като се брои от 0.  Напр.: „popd -0“ премахва\n"
"        последната директория, „popd -1“ - предпоследната.\n"
"    \n"
"    Стекът с директориите се визуализира с командата „dirs“.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е подаден неправилен аргумент или не може да се премине към\n"
"    съответната директория."

#: builtins.c:1886
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Извеждане на стека на директориите.\n"
"    \n"
"    Отпечатва списъка с текущо запомнените директории.  Списъкът се попълва чрез\n"
"    командата „pushd“.  Можете да вадите директории от стека с командата\n"
"    „popd“.\n"
"    \n"
"    Опции:\n"
"     -c  изчистване на стека на директориите като изтрива всички елементи\n"
"     -l  извеждане на пълните имена на директориите, а не съкратените спрямо\n"
"         домашната директория имена („/homes/pesho/bin“, а не „~/bin“)\n"
"     -p  поредово отпечатване без поредния номер в стека\n"
"     -v  поредово отпечатване заедно с поредния номер в стека\n"
"    \n"
"    Аргументи: \n"
"     +N  извежда N-тия елемент отляво в списъка отпечатан от командата „dirs“,\n"
"         когато е стартирана без опции.  Брои се от 0.\n"
"     -N  извежда N-тия елемент отдясно в списъка отпечатан от командата „dirs“,\n"
"         когато е стартирана без опции.  Брои се от 0.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е дадена неправилна опция или възникне грешка."

#: builtins.c:1917
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Включване и изключване на опции на обвивката.\n"
"    \n"
"    Превключване на състоянието на всяка от дадените ОПЦИи на обвивката.  Ако не\n"
"    не са зададени аргументи, се извежда списък от с дадените ОПЦИи или всички,\n"
"    ако не са дадени такива, като се указва за всяка дали и включена или не.\n"
"    \n"
"    Опции:\n"
"      -o    ограничаване на опциите до определените за използване със „set -o“\n"
"      -p    извеждане на всяка опция с означение дали е включена или не\n"
"      -q    без извеждане на информация\n"
"      -s    включване на всяка от ОПЦИИте\n"
"      -u    изключване на всяка от ОПЦИИте\n"
"    \n"
"    Изходен код:\n"
"    0, ако ОПЦИЯта е включена, грешка, ако е зададена неправилна или изключена\n"
"    ОПЦИЯ."

#: builtins.c:1938
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output; character escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or assignment\n"
"    error occurs."
msgstr ""
"Форматиране и отпечатване на АРГУМЕНТИте според управлението на ФОРМАТа.\n"
"    \n"
"    Опции:\n"
"      -v ПРОМЕНЛИВА  изходът се поставя в ПРОМЕНЛИВАта на обвивката, вместо да\n"
"      се извежда на стандартния изход.\n"
"    \n"
"    ФОРМАТът е последователност от знаци, която съдържа три вида обекти:\n"
"    ⁃ обикновени знаци, които биват отпечатани директно на стандартния изход;\n"
"    ⁃ екраниращи знакови последователности, които биват преобразувани и\n"
"      отпечатани на стандартния изход;\n"
"    ⁃ форматиращи знакови последователности, всяка от които предизвиква\n"
"      отпечатването на следващ аргумент.\n"
"    \n"
"    Освен стандартните форматирания описани в ръководството на printf(1), printf\n"
"    приема и следните инструкции:\n"
"      %b      предизвиква заместването на екраниранията с обратно наклонени\n"
"              черти в съответния аргумент\n"
"      %q      предизвиква цитирането на аргумента, така че да може да бъде\n"
"              използван като вход за обвивката\n"
"      %Q      подобно на „%q“, но се прилага някаква точност към нецитирания\n"
"              аргумент преди цитирането му\n"
"      %(fmt)  отпечатване на низа при третиране на аргумента като дата и време\n"
"              според strftime(3)\n"
"    \n"
"    Форматът се преизползва до приемането на всички аргументи.  Ако има по-\n"
"    малко аргументи от посочените във форма̀та, поведението на допълнителните е\n"
"    все едно за аргумент да са подадени нулева стойност или празен низ.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако не е дадена неправилна опция или възникне грешка при\n"
"    извеждането на резултата или при присвояването на стойността."

#: builtins.c:1974
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    are supplied, existing completion specifications are printed in a way that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Указване на начина на автоматичното дописване на аргументите от Readline.\n"
"    \n"
"    За всяко ИМЕ се извежда начинът за дописване на аргументите.  Ако не са\n"
"    дадени никакви опции, се извеждат текущите инструкции за автоматично\n"
"    дописване във формат, който може да се използва за вход.\n"
"    \n"
"    Опции:\n"
"      -p  Извеждане на текущите инструкции за автоматично дописване във формат,\n"
"          който може да се използва за вход\n"
"      -r  Премахване на инструкциите за автоматично дописване на всяко ИМЕ, а\n"
"          когато такова не е указано — всички инструкции\n"
"      -D  Прилагане на дописванията и действията като стандартните за командите,\n"
"          без никакви специфични инструкции\n"
"      -E  Прилагане на дописванията и действията като тези на „празната“\n"
"          команда — когато все още нищо не е написано на командния ред\n"
"      -I  Прилагане на дописванията и действията към първата дума (обикновено\n"
"          това е командата)\n"
"    \n"
"    При извършване на автоматично дописване, действията се прилагат в реда на\n"
"    опциите с главна буква дадени по-горе.  Опцията „-D“ е с по-висок приоритет\n"
"    от „-E“, която има по-висок приоритет от „-I“.\n"
"    \n"
"    Изходен код:\n"
"    0, освен когато е дадена неправилна опция или възникне грешка."

#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Извеждане на възможните дописвания.\n"
"    \n"
"    Целта е да се ползва в рамките функция на обвивката, която генерира\n"
"    възможните дописвания.  Ако е зададен незадължителният аргумент ДУМА,\n"
"    генерират се напасванията с него.\n"
"    \n"
"    Изходен код:\n"
"    0, освен ако е дадена неправилна опция или възникне грешка."

#: builtins.c:2019
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, print\n"
"    the completion options for each NAME or the current completion specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Променяне или извеждане на опциите за дописване.\n"
"    \n"
"    Променяне на опциите дописване за всяко ИМЕ, или когато не са указани\n"
"    ИМЕна — дописването, което се изпълнява в момента.  Ако не са зададени\n"
"    ОПЦИи, извеждане на на опциите за дописване за всяко име или за текущо\n"
"    изпълняваното дописване.\n"
"    \n"
"    Опции:\n"
"      -o ОПЦИЯ\n"
"            Задаване ОПЦИЯта за дописване за всяко зададено ИМЕ\n"
"      -D    Задаване на опциите за „стандартното“ дописване на команда\n"
"      -E    Задаване на опциите за дописването на „празната“ команда\n"
"      -I    Задаване на опциите за дописването на първата дума\n"
"    Използването на „+o“ вместо „-o“ изключва дадената опция.\n"
"    \n"
"    Аргументи:\n"
"    \n"
"    Всяко ИМЕ указва команда, за която трябва предварително да е зададена\n"
"    спецификация за дописване чрез вградената команда „complete“.  Ако не са\n"
"    зададени ИМЕна, командата „compopt“ трябва да бъде изпълнена от функция,\n"
"    която генерира спецификациите за дописване.  В този случай опциите за текущо\n"
"    изпълнявания генератор на дописвания се променят.\n"
"    \n"
"    Изходен код:\n"
"    0, освен когато е дадена неправилна опция или липсват инструкции към ИМЕто\n"
"    за автоматично дописване."

#: builtins.c:2050
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly or\n"
"    not an indexed array."
msgstr ""
"Изчитане на редове от стандартния вход и запазване в променлива — индексиран\n"
"    низ.\n"
"    \n"
"    Прочитане на редове от стандартния вход, които след това се запазват в\n"
"    променливата МАСИВ.  Когато е дадена опцията „-u“, се чете от\n"
"    ФАЙЛов_ДЕСКРиптор.  Стандартното име на променливата-масив е MAPFILE.\n"
"    \n"
"    Опции:\n"
"      -d РАЗДЕЛИТЕЛ РАЗДЕЛяне на редовете с този знак, а не с нов ред\n"
"      -n МАКС_РЕДА  Изчитане на не повече от МАКСимум РЕДа.  Ако е 0, се\n"
"                    прочитат всички редове\n"
"      -O НАЧАЛО     Присвояването да започне при индекс НАЧАЛО в МАСИВа\n"
"                    Стандартната стойност е 0\n"
"      -s БРОЙ_ПРОП  Прескачане на първите БРОЙ за ПРОПускане прочетени реда\n"
"      -t            Премахване на последващия знак-РАЗДЕЛител от всеки ред\n"
"                    (стандартно е знакът за нов ред)\n"
"      -u ФАЙЛов_ДЕСКРиптор\n"
"                    Изчитане на редовете от ФАЙЛов_ДЕСКРиптор, а не стандартния\n"
"                    вход\n"
"      -C ФУНКЦИЯ    Функция, която се извиква при изчитането на всеки БРОЙ_РЕДА\n"
"      -c БРОЙ_РЕДА  Редове, които да се изчетат преди да се извика ФУНКЦИЯта\n"
"    \n"
"    Аргументи:\n"
"      МАСИВ         Име на променливата-масив\n"
"    \n"
"    Ако опцията „-C“ е зададена без „-c“, стандартния БРОЙ_РЕДА е 5000.  При\n"
"    извикването на ФУНКЦИЯта за аргументи ѝ се подават индекса на следващия\n"
"    елемент от масива и реда, който се счита за стойност.\n"
"    \n"
"    Ако не е дадено изрично НАЧАЛО, командата „mapfile“ изчиства МАСИВа, преди\n"
"    да започне присвояването към него.\n"
"    \n"
"    Изходен код:\n"
"    Връща 0, освен ако е дадена неправилна опция или ако МАСИВът е променлива\n"
"    само за четене или не е индексиран масив."

#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Прочитане на редове от файл и поставяне в променлива – масив.\n"
"    \n"
"    Синоним на „mapfile“."
